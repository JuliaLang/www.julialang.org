<!doctype html> <html lang=en > <meta charset=utf-8 > <meta name=viewport  content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv=x-ua-compatible  content="ie=edge"> <meta name=author  content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al."> <meta name=description  content="The official website for the Julia Language. Julia is a language that is fast, dynamic, easy to use, and open source. Click here to learn more."> <meta name=robots  content="max-image-preview:large"> <meta name="twitter:site:id" content=1237720952 > <meta name=google-site-verification  content=9VDSjBtchQj6PQYIVwugTPY7pVCfLYgvkXiRHjc_Bzw  /> <link rel=icon  href="/assets/infra/julia.ico"> <link rel=stylesheet  href="/libs/bootstrap/bootstrap.min.css"> <link rel=stylesheet  href="/css/app.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/fonts.css"> <link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel=stylesheet > <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel=stylesheet > <script async defer src="/libs/buttons.js"></script> <script type="application/javascript"> var doNotTrack = false; if (!doNotTrack) { window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-28835595-1', 'auto'); ga('send', 'pageview'); } </script> <script async src='https://www.google-analytics.com/analytics.js'></script> <title>View all GSoC/JSoC Projects</title> <meta property="og:title" content="View all GSoC/JSoC Projects"> <meta property="og:description" content=""> <meta property="og:image" content="/assets/images/julia-open-graph.png"> <div class="container py-3 py-lg-0"> <nav class="navbar navbar-expand-lg navbar-light bg-light" id=main-menu > <a class=navbar-brand  href="/"> <img src="/assets/infra/logo.svg" alt="JuliaLang Logo"> </a> <button class="navbar-toggler ml-auto hidden-sm-up float-xs-left" type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mx-auto"> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/downloads/">Download</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="https://docs.julialang.org">Documentation</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/blog/">Blog</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/community/">Community</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/learning/">Learn</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/research/">Research</a> <li class="nav-item active flex-md-fill text-md-center"> <a class=nav-link  href="/jsoc/">JSoC</a> </ul> <span class=navbar-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a> </span> </div> </nav> </div> <br><br> <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/jsoc/allprojects.md" title="Edit this page on GitHub" class=edit-float > </a> <div class="container main"><h2 id=view_all_gsocjsoc_projects ><a href="#view_all_gsocjsoc_projects">View all GSoC/JSoC Projects</a></h2> <p>This page is designed to improve discoverability of projects. You can, for example, search this page for specific keywords and find all of the relevant projects.</p> <h2 id=projects ><a href="#projects">Projects</a></h2> <h1 id=geostatsjl_-_summer_of_code ><a href="#geostatsjl_-_summer_of_code">GeoStats.jl - Summer of Code</a></h1> <p><a href="https://github.com/JuliaEarth/GeoStats.jl">GeoStats.jl</a> is an extensible framework for high-performance geostatistics in Julia. It is a project that aims to redefine the way statistics is done with geospatial data &#40;e.g. data on geographics maps, 3D meshes&#41;.</p> <p>Project mentors: <a href="https://github.com/juliohm">Júlio Hoffimann</a>, <a href="https://github.com/rmcaixeta">Rafael Caixeta</a></p> <h2 id=new_geostatistical_clustering_methods ><a href="#new_geostatistical_clustering_methods">New geostatistical clustering methods</a></h2> <p>Statistical clustering cannot be applied straightforwardly to geospatial data. Geospatial constraints require clusters to be contiguous volumes in the map, something that is not taken into account by traditional methods &#40;e.g. K-Means, Spectral Clustering&#41;.</p> <p>The goal of this project is to implement a geospatial clustering method from the geostatistics literature using the GeoStats.jl API.</p> <p><strong>Desired skills:</strong> Statistics, Clustering, Graph Theory</p> <p><strong>Difficulty level:</strong> Medium</p> <p><strong>References:</strong></p> <div class=tight-list ><ul> <li><p><a href="https://www.sciencedirect.com/science/article/abs/pii/S2211675316300367">A hierarchical clustering method for multivariate geostatistical data</a></p> <li><p><a href="https://www.sciencedirect.com/science/article/pii/S0098300415001314">Unsupervised classification of multivariate geostatistical data: Two algorithms</a></p> <li><p><a href="https://www.sciencedirect.com/science/article/pii/S0098300411004419">A density-based spatial clustering algorithm considering both spatial proximity and attribute similarity</a></p> </ul></div> <h2 id=new_geostatistical_simulation_methods ><a href="#new_geostatistical_simulation_methods">New geostatistical simulation methods</a></h2> <p>Geostatistical simulation consists of generating multiple alternative realizations of geospatial data according to a given geospatial distribution. The litetaure on simulation methods is vast, but a few of them are particularly useful.</p> <p>The goal of this project is to implement a geostatistical simulation method from the geostatistics literature using the GeoStats.jl API.</p> <p><strong>Desired skills:</strong> Geostatistics, Stochastics, HPC</p> <p><strong>Difficulty level:</strong> Hard</p> <p><strong>References:</strong></p> <div class=tight-list ><ul> <li><p><a href="https://link.springer.com/article/10.1023/A:1014009426274">Conditional Simulation of Complex Geological Structures Using Multiple-Point Statistics</a></p> <li><p><a href="https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2008WR007621">The Direct Sampling method to perform multiple‐point geostatistical simulations</a></p> </ul></div> <h2 id=migrate_from_plotsjl_to_makiejl_recipes ><a href="#migrate_from_plotsjl_to_makiejl_recipes">Migrate from Plots.jl to Makie.jl recipes</a></h2> <p>The project currently relies on Plots.jl recipes to visualize geospatial data sets as well as many other objects defined in the framework. However, very large data sets &#40;e.g. 3D volumes&#41; cannot be visualized easily. The Makie.jl project is a promissing alternative.</p> <p>The goal of this project is to migrate all plot recipes from Plots.jl to Makie.jl.</p> <p><strong>Desired skills:</strong> Visualization, Plotting, Geometry, HPC, GPU</p> <p><strong>Difficulty level:</strong> Medium</p> <h2 id=how_to_get_started ><a href="#how_to_get_started">How to get started?</a></h2> <p>Get familiar with the framework by reading the <a href="https://juliaearth.github.io/GeoStats.jl/stable">documentation</a> and <a href="https://github.com/JuliaEarth/GeoStatsTutorials">tutorials</a>.</p> <p>Please contact the project maintainers in <a href="https://gitter.im/JuliaEarth/GeoStats.jl">Gitter</a> or <a href="https://julialang.zulipchat.com/#narrow/stream/276201-geostats.2Ejl">Zulip</a>.</p> <h1 id=gsoc_projects ><a href="#gsoc_projects">GSOC projects</a></h1> <h1 id=2021_ideas ><a href="#2021_ideas">2021 Ideas</a></h1> <h1 id=titles_possible_mentors ><a href="#titles_possible_mentors">Titles &amp; possible mentors </a></h1> <ul> <li><p><a href="#Particle-swarm-optimization-of-machine-learning-models">Particle swarm optimization of machine learning models</a></p> <li><p><a href="#In-processing-methods-for-fairness-in-machine-learning">In-processing methods for fairness in machine learning</a></p> <li><p><a href="#Causal-and-counterfactual-methods-for-fairness-in-machine-learning">Causal and counterfactual methods for fairness in machine learning</a></p> <li><p><a href="#Time-series-forecasting-at-scale---speed-up-via-Julia">Time series forecasting at scale - speed up via Julia</a></p> <li><p><a href="#Interpretable-Machine-Learning-in-Julia">Interpretable Machine Learning in Julia</a></p> <li><p><a href="#Model-visualization-in-MLJ">Model visualization in MLJ</a></p> <li><p><a href="#Deeper-Bayes">Deeper integration with Bayseian methods and Bayesian Stacking</a></p> <li><p><a href="#MLJ-and-MLFlow-integration">MLJ and MLFlow integration</a></p> <li><p><a href="#Speed-demons-only-need-apply">Speed demons only need apply</a></p> </ul> <h1 id=mlj_projects_summer_of_code ><a href="#mlj_projects_summer_of_code">MLJ Projects – Summer of Code</a></h1> <p><a href="https://github.com/alan-turing-institute/MLJ.jl">MLJ</a> is a machine learning framework for Julia aiming to provide a convenient way to use and combine a multitude of tools and models available in the Julia ML/Stats ecosystem.</p> <p>MLJ is released under the MIT license and sponsored by the Alan Turing Institute.</p> <h2 id=particle_swarm_optimization_of_machine_learning_models ><a href="#particle_swarm_optimization_of_machine_learning_models">Particle swarm optimization of machine learning models</a></h2> <p>Bring particle swarm optimization to the MLJ machine learning platform to help users tune machine learning models. </p> <p><strong>Difficulty.</strong> Easy - moderate. </p> <h3 id=description ><a href="#description">Description</a></h3> <p>Imagine your search for the optimal machine learning model as the meandering flight of a bee through hyper-parameter space, looking for a new home for the queen. Parallelize your search, and you&#39;ve created a swarm of bees. Introduce communication between the bees about their success so far, and you introduce the possibility of the bees ultimately converging on good candidate for the best model.</p> <p>PSO &#40;particle swarm optimization&#41; is a large, promising, and active area of research, but also one that is used in real data science practice. The method is based on a very simple idea inspired by nature and makes essentially no assumptions about the nature of the cost function &#40;unlike other methods, such as gradient descent, which might require a handle on derivatives&#41;. The method is simple to implement, and applicable to a wide range of hyper-parameter optimization problems.</p> <p><strong>Mentors.</strong> <a href="https://ablaom.github.io">Anthony Blaom</a>, <a href="https://www.turing.ac.uk/people/programme-directors/sebastian-vollmer">Sebastian Vollmer</a></p> <h3 id=prerequisites ><a href="#prerequisites">Prerequisites</a></h3> <div class=tight-list ><ul> <li><p>Julia language fluency essential. </p> <li><p>Git-workflow familiarity strongly preferred. </p> <li><p>Some prior contact with optimization algorithms of some kind</p> <li><p>A passing familiarity with machine learning goals and workflow preferred</p> </ul></div> <h3 id=your_contribution ><a href="#your_contribution">Your contribution</a></h3> <p>The aim of this project is to implement one or more variants of PSO algorithm, for use in the MLJ machine learning platform, for the purpose of optimizing hyper-parameters. <em>Integration</em> with MLJ is crucial, so there will be opportunity to spend time familiarizing yourself with this popular tool. </p> <p>Specifically, you will:</p> <ul> <li><p>familiarize yourself with the training, evaluation and tuning of machine learning models in MLJ</p> <li><p>learn about the PSO algorithm and its variants, conducting a short survey of some of the literature and existing implementations in Julia and other languages, and preparing a short summary</p> <li><p>familiarize yourself intimately with the &#91;MLJ tuning</p> </ul> <p>API&#93;&#40;https://github.com/alan-turing-institute/MLJTuning.jl#how-do-i-implement-a-new-tuning-strategy&#41;</p> <ul> <li><p>implement a simple PSO variant, complete with testing and documentation</p> <li><p>experiment with the variant to learn more about its shortcomings and advantages, help recommend default parameter settings</p> <li><p>add variants, as time permits</p> </ul> <h3 id=references ><a href="#references">References</a></h3> <ul> <li><p><a href="https://en.wikipedia.org/wiki/Particle_swarm_optimization">Wiki entry on PSO</a></p> <li><p><a href="https://www.hindawi.com/journals/mpe/2015/931256/">Zhang et al. &#40;2015&#41;: A Comprehensive Survey on Particle Swarm Optimization Algorithm and Its Applications</a></p> <li><p><a href="https://link.springer.com/article/10.1007/s12065-019-00210-z">Elbes et al. &#40;2015&#41;: A survey on particle swarm optimization with emphasis on engineering and network applications</a></p> <li><p><a href="https://github.com/alan-turing-institute/MLJTuning.jl#how-do-i-implement-a-new-tuning-strategy">The MLJ tuning API</a></p> </ul> <h2 id=in-processing_methods_for_fairness_in_machine_learning ><a href="#in-processing_methods_for_fairness_in_machine_learning">In-processing methods for fairness in machine learning</a></h2> <p>Mentors: <a href="https://jiahao.github.io/">Jiahao Chen</a>, <a href="https://github.com/mschauer">Moritz Schauer</a>, and <a href="https://www.turing.ac.uk/people/programme-directors/sebastian-vollmer">Sebastian Vollmer</a></p> <p><a href="https://github.com/ashryaagr/Fairness.jl">Fairness.jl</a> is a package to audit and mitigate bias, using the MLJ machine learning framework and other tools. It has implementations of some preprocessing and postprocessing methods for improving fairness in classification models, but could use more implementations of other methods, especially inprocessing algorithms like adversarial debiasing.</p> <p><em>Difficulty</em> Hard.</p> <h3 id=prerequisites__2 ><a href="#prerequisites__2">Prerequisites</a></h3> <div class=tight-list ><ul> <li><p>Essential: working knowledge of the Julia language</p> <li><p>Strongly preferred: git workflow familiarity</p> <li><p>Desirable: Experience with flux and autodiff</p> </ul></div> <h3 id=description__2 ><a href="#description__2">Description</a></h3> <p>Machine learning models are developed to support and make high-impact decisions like who to hire or who to give a loan to. However, available training data can exhibit bias against race, age, gender, or other prohibited bases, reflecting a complex social and economic history of systemic injustic. For example, women in the United Kingdom, United States and other countries were only allowed to have their own bank accounts and lines of credit in the 1970s&#33; That means that training a credit decisioning model on historical data would encode implicit biases, that women are less credit-worthy because few of them had lines of credit in the past. Surely we would want to be fair and not hinder an applicant&#39;s ability to get a loan on the basis of their race, gender and age?</p> <p>So how can we fix data and models that are unfair? A common first reaction is to remove the race, gender and age attributes from the training data, and then say we are done. But as described in detail in the references, we cam have to consider if other features like one&#39;s name or address could encode such prohibited bases too. To mitigate bias and improve fairness in models, we can change the training data &#40;pre-processing&#41;, the way we define and train the model &#40;in-processing&#41;, and/or alter the predictions made &#40;post-processing&#41;. Some algorithms for the first and third approaches have already been implemented in Fairness.jl, which have the advantage of treating the ML model as a black box. However, our latest resarch <a href="https://arxiv.org/abs/2011.02407">&#40;arXiv:2011.02407&#41;</a> shows that pur black box methods have fundamental limitations in their ability to mitigate bias.</p> <h3 id=your_contribution__2 ><a href="#your_contribution__2">Your contribution</a></h3> <p>This project is to implement more bias mitigation algorithms and invent new ones too. We will focus on in-processing algorithms that alter the training process or alter ML model. Some specific stages are to:</p> <ol> <li><p>Use <a href="https://github.com/FluxML/Flux.jl">Flux.jl</a> or <a href="https://github.com/alan-turing-institute/MLJFlux.jl">MLJFlux.jl</a> to develop in-processing algorithms,</p> <li><p>Study research papers proposing in-processing algorithms and implement them, and</p> <li><p>Implement fairness algorithms and metrics for individual fairness as described in papers like <a href="https://arxiv.org/abs/2006.11439">arXiv:2006.11439</a>.</p> </ol> <h3 id=references__2 ><a href="#references__2">References</a></h3> <ol> <li><p>High-level overview: <a href="https://julialang.org/jsoc/gsoc/MLJ/">https://towardsdatascience.com/a-tutorial-on-fairness-in-machine-learning-3ff8ba1040cb</a></p> <li><p><a href="https://nextjournal.com/ashryaagr/fairness">https://nextjournal.com/ashryaagr/fairness</a> </p> <li><p>IBM’s AIF360 resources: <a href="https://aif360.mybluemix.net/">https://aif360.mybluemix.net/</a> </p> <p>AIF360 Inprocessing algorithms: Available <a href="https://aif360.readthedocs.io/en/latest/modules/algorithms.html#module-aif360.algorithms.inprocessing">here</a>.</p> <li><p><a href="https://dssg.github.io/fairness_tutorial/">https://dssg.github.io/fairness_tutorial/</a> </p> </ol> <h2 id=causal_and_counterfactual_methods_for_fairness_in_machine_learning ><a href="#causal_and_counterfactual_methods_for_fairness_in_machine_learning">Causal and counterfactual methods for fairness in machine learning</a></h2> <p>Mentors: <a href="https://jiahao.github.io/">Jiahao Chen</a>, <a href="https://github.com/mschauer">Moritz Schauer</a>, <a href="https://github.com/zenna">Zenna Tavares</a>, and <a href="https://www.turing.ac.uk/people/programme-directors/sebastian-vollmer">Sebastian Vollmer</a></p> <p><a href="https://github.com/ashryaagr/Fairness.jl">Fairness.jl</a> is a package to audit and mitigate bias, using the MLJ machine learning framework and other tools. This project is to implement algorithms for counterfactual &#40;&quot;what if&quot;&#41; reasoning and causal analysis to Fairness.jl and MLJ.jl, integrating and extending Julia packages for causal analysis.</p> <p><em>Difficulty</em> Hard.</p> <h3 id=prerequisites__3 ><a href="#prerequisites__3">Prerequisites</a></h3> <div class=tight-list ><ul> <li><p>Essential: working knowledge of the Julia language</p> <li><p>Strongly preferred: git workflow familiarity</p> <li><p>Desirable: Experience in causal inference</p> <li><p>Desirable: Experience with graphical models</p> </ul></div> <h3 id=description__3 ><a href="#description__3">Description</a></h3> <p>Machine learning models are developed to support and make high-impact decisions like who to hire or who to give a loan to. However, available training data can exhibit bias against race, age, gender, or other prohibited bases, reflecting a complex social and economic history of systemic injustic. For example, women in the United Kingdom, United States and other countries were only allowed to have their own bank accounts and lines of credit in the 1970s&#33; That means that training a credit decisioning model on historical data would encode implicit biases, that women are less credit-worthy because few of them had lines of credit in the past. Surely we would want to be fair and not hinder an applicant&#39;s ability to get a loan on the basis of their race, gender and age?</p> <p>So how can we fix unfairness in models? Arguably, we should first identify the underlying <em>causes</em> of bias, and only then can we actually remediate bias successfully. However, one major challenge is that a proper evaluation often requires data that we don&#39;t have. For this reason, we also need counterfactual analysis, to identify actions we can take that can mitigate fairness not just in our training data, but also in situations we haven&#39;t seen yet but could encounter in the future. Ideas for identifying and mitigating bias using such causal interventions have been proposed in papers such as <a href="https://causalai.net/r37.pdf">Equality of Opportunity in Classification: A Causal Approach</a> and the references below.</p> <h3 id=your_contribution__3 ><a href="#your_contribution__3">Your contribution</a></h3> <p>This project is to implement algorithms for counterfactual &#40;&quot;what if&quot;&#41; reasoning and causal analysis to Fairness.jl and MLJ.jl, integrating and extending Julia packages for causal analysis. Some specific stages are:</p> <div class=tight-list ><ol> <li><p>Implement interfaces in MLJ.jl for Julia packages for causal inference and probabilistic programming such as <a href="https://github.com/zenna/Omega.jl">Omega.jl</a> and CausalInference.jl&#93;&#40;https://github.com/mschauer/CausalInference.jl&#41;</p> <li><p>Implement and benchmark causal and counterfactual definitons for measuring unfairness</p> <li><p>Implement and benchmark causal and counterfactual approaches to mitigate bias</p> </ol></div> <h3 id=references__3 ><a href="#references__3">References</a></h3> <div class=tight-list ><ul> <li><p><a href="https://github.com/yongkaiwu/Causal-Fairness">Repository of Causal-Fairness links</a> </p> <li><p><a href="https://causalai.net/r37.pdf">Causal fairness for predictive models</a></p> <li><p><a href="https://papers.nips.cc/paper/2020/file/d0921d442ee91b896ad95059d13df618-Paper.pdf">High-level overview: Fair Multiple Decision Making Through Soft Interventions</a></p> <li><p><a href="https://www.aaai.org/ocs/index.php/AAAI/AAAI18/paper/view/16949/15911">Fairness in Decision-Making — The Causal Explanation Formula</a></p> <li><p><a href="https://causalml.readthedocs.io/en/latest/methodology.html#t-learner">CausalML tool from Uber</a></p> <li><p><a href="https://www2.slideshare.net/AmitSharma315/dowhy-an-endtoend-library-for-causal-inference">end-to-end causal</a></p> <li><p><a href="https://causalai.net/r37.pdf">Equality of Opportunity in Classification: A Causal Approach</a>.</p> </ul></div> <h2 id=time_series_forecasting_at_scale_-_speed_up_via_julia ><a href="#time_series_forecasting_at_scale_-_speed_up_via_julia">Time series forecasting at scale - speed up via Julia</a></h2> <p>Time series are ubiquitous - stocks, sensor reading, vital signs. This projects aims at adding time series forecasting to MLJ and perform benchmark comparisons to <a href="https://github.com/alan-turing-institute/sktime">sktime</a>, <a href="https://github.com/rtavenar/tslearn">tslearn</a>, <a href="https://github.com/uea-machine-learning/tsml/">tsml</a>&#41;.</p> <p><strong>Difficulty.</strong> Easy - moderate. </p> <h3 id=prerequisites__4 ><a href="#prerequisites__4">Prerequisites</a></h3> <ul> <li><p>Julia language fluency essential. </p> <li><p>Git-workflow essebtial </p> <li><p>Some prior contact with time series forecasting </p> <li><p>HPC in julia is a desirable</p> </ul> <h3 id=your_contribution__4 ><a href="#your_contribution__4">Your contribution</a></h3> <p>MLJ is so far focused on tabular data and time series classification. This project is to add support for time series data in a modular, composable way.</p> <p>Time series are everywhere in real-world applications and there has been an increase in interest in time series frameworks recently &#40;see e.g. <a href="https://github.com/alan-turing-institute/sktime">sktime</a>, <a href="https://github.com/rtavenar/tslearn">tslearn</a>, <a href="https://github.com/uea-machine-learning/tsml/">tsml</a>&#41;.</p> <p>But there are still very few principled time-series libraries out there, so you would be working on something that could be very useful for a large number of people. To find out more, check out this <a href="http://learningsys.org/neurips19/assets/papers/sktime_ml_systems_neurips2019.pdf">paper</a> on sktime.</p> <p><strong>Mentors</strong>: <a href="https://www.turing.ac.uk/people/programme-directors/sebastian-vollmer">Sebastian Vollmer</a>, <a href="https://github.com/mloning">Markus Löning</a> &#40;sktime developer&#41;.</p> <h3 id=references__4 ><a href="#references__4">References</a></h3> <ul> <li><p><a href="https://github.com/alan-turing-institute/sktime">sktime</a></p> <li><p><a href="https://github.com/rtavenar/tslearn">tslearn</a></p> <li><p><a href="https://github.com/uea-machine-learning/tsml/">tsml</a></p> <li><p><a href="http://learningsys.org/neurips19/assets/papers/sktime_ml_systems_neurips2019.pdf">sktime paper</a></p> </ul> <h2 id=interpretable_machine_learning_in_julia ><a href="#interpretable_machine_learning_in_julia">Interpretable Machine Learning in Julia</a></h2> <p>Interpreting and explaining black box interpretation crucial to estabilish trust and improve performance</p> <p><strong>Difficulty.</strong> Easy - moderate. </p> <h3 id=description__4 ><a href="#description__4">Description</a></h3> <p>It is important to have mechanisms in place to interpret the results of machine learning models. Identify the relevant factors of a decision or scoring of a model. </p> <p>This project will implement methods for model and feature interpretability.</p> <p><strong>Mentors.</strong> <a href="https://github.com/darenasc">Diego Arenas</a>, <a href="https://www.turing.ac.uk/people/programme-directors/sebastian-vollmer">Sebastian Vollmer</a>.</p> <h3 id=prerequisites__5 ><a href="#prerequisites__5">Prerequisites</a></h3> <ul> <li><p>Julia language fluency essential. </p> <li><p>Git-workflow familiarity strongly preferred. </p> <li><p>Some prior contact with explainable AI/ML methods is desirable.</p> <li><p>A passing familiarity with machine learning goals and workflow preferred</p> </ul> <h3 id=your_contribution__5 ><a href="#your_contribution__5">Your contribution</a></h3> <p>The aim of this project is to implement multiple variants implementation algorithms such as:</p> <ul> <li><p>Implement methods to show feature importance</p> <li><p>Partial dependence plots</p> <li><p>Tree surrogate</p> <li><p>LocalModel: Local Interpretable Model-agnostic Explanations</p> <li><p>Add Dataset loaders for standard interpretability datasetss. </p> <li><p>Add performance metrics for interpretability</p> <li><p>Add interpretability algorithms</p> <li><p>Glue code to SHAP package </p> </ul> <p>Specifically you will</p> <ul> <li><p>Familiarize yourself with MLJ</p> <li><p>Survey of some of the literature and existing implementations in Julia and other languages, and preparing a short summary</p> <li><p>Implement visualisations of explanations</p> <li><p>Implement use cases</p> <li><p>You will learn about the benefits and short comings of model interpretation and how to use them. </p> </ul> <h3 id=references__5 ><a href="#references__5">References</a></h3> <ul> <li><p><a href="https://christophm.github.io/interpretable-ml-book/">Interpretable Machine Learning - A Guide for Making Black Box Models Explainable by Christoph Molnalr</a></p> <li><p><a href="https://github.com/christophM/iml/">iml R package</a></p> <li><p></p> </ul> <p>Tutorials</p> <ul> <li><p><a href="https://dl.acm.org/doi/abs/10.1145/3351095.3375667">AI explainability 360: hands-on tutorial</a></p> <li><p><a href="https://mlr3book.mlr-org.com/iml.html">IML tutorial</a></p> </ul> <h2 id=model_visualization_in_mlj ><a href="#model_visualization_in_mlj">Model visualization in MLJ</a></h2> <p>Design and implement a data visualization module for MLJ.</p> <p><strong>Difficulty</strong>. Easy.</p> <h3 id=description__5 ><a href="#description__5">Description</a></h3> <p>Design and implement a data visualization module for MLJ to visualize numeric and categorical features &#40;histograms, boxplots, correlations, frequencies&#41;, intermediate results, and metrics generated by MLJ machines. </p> <p>Using a suitable Julia package for data visualization.</p> <p>The idea is to implement a similar resource to what <a href="https://github.com/mlr-org/mlr3viz">mlr3viz</a> does for <a href="https://mlr3.mlr-org.com">mlr3</a>.</p> <h3 id=prerequisites__6 ><a href="#prerequisites__6">Prerequisites</a></h3> <ul> <li><p>Julia language fluency essential.</p> <li><p>Git-workflow essential.</p> <li><p>Some prior work on data visualization is desirable</p> </ul> <h3 id=your_contribution__6 ><a href="#your_contribution__6">Your contribution</a></h3> <p>So far visualizing data or features in MLJ is an ad-hoc task. Defined by the user case by case. You will be implementing a standard way to visualize model performance, residuals, benchmarks and predictions for MLJ users.</p> <p>The structures and metrics will be given from the results of models or data sets used; your task will be to implement the right visualizations depending on the data type of the features.</p> <p>A relevant part of this project is to visualize the target variable against the rest of the features.</p> <p>You will enhance your visualisation skills as well as your ability to &quot;debug&quot; and understand models and their prediction visually.</p> <h3 id=references__6 ><a href="#references__6">References</a></h3> <ul> <li><p><a href="https://github.com/mlr-org/mlr3viz">mlr3viz</a></p> <li><p><a href="https://github.com/JuliaPlots/StatsPlots.jl">StatsPlots</a></p> </ul> <p><strong>Mentors</strong>: <a href="https://www.turing.ac.uk/people/programme-directors/sebastian-vollmer">Sebastian Vollmer</a>, <a href="https://github.com/darenasc">Diego Arenas</a>.</p> <h2 id=deeper_bayesian_intergration ><a href="#deeper_bayesian_intergration">Deeper Bayesian Intergration</a></h2> <p>Bayesian methods and probabilistic supervised learning provide uncertainty quantification. This project aims increasing integration to combine Bayeisan and non-Bayesian methods using Turing.</p> <h3 id=description__6 ><a href="#description__6">Description</a></h3> <p>As an initial step reproduce &#40;SOSSMLJ&#41;&#91;https://github.com/cscherrer/SossMLJ.jl&#93; in Turing. The bulk of the project is to implement methods that combine multiple predictive distributinons.</p> <h3 id=your_contributions ><a href="#your_contributions">Your contributions</a></h3> <ul> <li><p>Interface between Turing and MLJ</p> <li><p>Comparisons of ensambling, stacking of predictive distribution</p> <li><p>reproducible benchmarks across various settings.</p> </ul> <h3 id=references__7 ><a href="#references__7">References</a></h3> <p><a href="http://www.stat.columbia.edu/~gelman/research/published/stacking_paper_discussion_rejoinder.pdf">Bayesian Stacking</a> <a href="https://github.com/alan-turing-institute/skpro/blob/master/README.md">SKpro</a></p> <h3 id=difficulty_medium_to_hard ><a href="#difficulty_medium_to_hard">Difficulty: Medium to Hard</a></h3> <p><strong>Mentors</strong>: <a href="https://github.com/yebai">Hong Ge</a> <a href="https://www.turing.ac.uk/people/programme-directors/sebastian-vollmer">Sebastian Vollmer</a> </p> <h2 id=mlj_and_mlflow_integration ><a href="#mlj_and_mlflow_integration">MLJ and MLFlow integration</a></h2> <p>Integrate MLJ with <a href="https://mlflow.org">MLFlow</a>. </p> <p><strong>Difficulty.</strong> Easy. </p> <h3 id=description__7 ><a href="#description__7">Description</a></h3> <p>MLFlow is a flexible model management tool. The project consists of writing the necessary functions to integrate MLJ with <a href="https://mlflow.org/docs/latest/rest-api.html">MLFlow REST API</a> so models built using MLJ can keep track of its runs, evaluation metrics, parameters, and can be registered and monitored using MLFlow.</p> <h3 id=prerequisites__7 ><a href="#prerequisites__7">Prerequisites</a></h3> <ul> <li><p>Julia language fluency essential.</p> <li><p>Git-workflow familiarity strongly preferred.</p> </ul> <h3 id=your_contribution__7 ><a href="#your_contribution__7">Your contribution</a></h3> <ul> <li><p>Provide to MLJ users a way to keep track of their machine learning models using MLflow, as a local or remote server.</p> <li><p>Implement a reproducible way to store and load machine learning models.</p> <li><p>Implement functions wraping the REST API calls that makes possible the use of MLflow.</p> </ul> <h3 id=references__8 ><a href="#references__8">References</a></h3> <ul> <li><p><a href="https://mlflow.org">MLFlow</a> website.</p> <li><p><a href="https://mlflow.org/docs/latest/rest-api.html">MLFlow REST API</a>.</p> </ul> <h2 id=speed_demons_only_need_apply ><a href="#speed_demons_only_need_apply">Speed demons only need apply</a></h2> <p>Diagnose and exploit opportunities for speeding up common MLJ workflows.</p> <p><strong>Difficulty.</strong> Moderate. </p> <h3 id=description__8 ><a href="#description__8">Description</a></h3> <p>In addition to investigating a number of known performance bottlenecks, you will have some free reign in this to identify opportunities to speed up common MLJ workflows, as well as making better use of memory resources.</p> <h3 id=prerequisites__8 ><a href="#prerequisites__8">Prerequisites</a></h3> <ul> <li><p>Julia language fluency essential. </p> <li><p>Experience with multi-threading and multi-processor computing essential, preferably in Julia.</p> <li><p>Git-workflow familiarity strongly preferred. </p> <li><p>Familiarity with machine learning goals and workflow preferred</p> </ul> <h3 id=your_contribution__8 ><a href="#your_contribution__8">Your contribution</a></h3> <p>In this project you will:</p> <ul> <li><p>familiarize yourself with the training, evaluation and tuning of machine learning models in MLJ</p> <li><p>work towards addressing a number of known performance issues, including:</p> <li><p>limitations of the generic Tables.jl interface for interacting with tabular data which, in common cases &#40;DataFrames&#41;, has extra functionality that can be exploited</p> <li><p>rolling out new data front-end for models to avoid unnecessary copying of data</p> <li><p>in conjuction with your mentor, identify best design for introducing better sparse data support to MLJ models &#40;e.g., naive Bayes&#41; </p> <li><p>implement a multi-threading and/or multi-processor parallelism to the current learning networks scheduler</p> <li><p>benchmark and profile common workflows to identify opportunities for further code optimizations</p> <li><p>implement some of these optimizations</p> </ul> <h3 id=references__9 ><a href="#references__9">References</a></h3> <ul> <li><p><a href="https://github.com/alan-turing-institute/MLJ.jl/blob/dev/ROADMAP.md#scalability">MLJ Roadmap</a>. See, in particular &quot;Scalability&quot; section.</p> <li><p><a href="https://github.com/alan-turing-institute/MLJBase.jl/issues/309">Taking performance more seriously GitHub issue</a></p> <li><p><a href="https://alan-turing-institute.github.io/MLJ.jl/dev/adding_models_for_general_use/#Implementing-a-data-front-end-1">Data front end</a> for MLJ models.</p> </ul> <p><strong>Mentors.</strong> <a href="https://ablaom.github.io">Anthony Blaom</a></p> <h1 id=compiler_projects_summer_of_code ><a href="#compiler_projects_summer_of_code">Compiler Projects – Summer of Code</a></h1> <p>I have a number of other compiler projects I&#39;m currently working on. Please contact me for additional details and let me know what specifically interests you about this area of contribution and we can tailor your project to suit you together.</p> <ul> <li><p><strong>Escape analysis:</strong></p> <p>A classic problem in compiler analysis&#33; We have an existing AbstractInterpreter framework for managing inter-procedural analysis of type through data-flow analysis. However, for escape information, currently we only do very limited, local inference, which greatly limits optimization potential to places with inlining. The schedule for the project would be to start by writing some example programs that would most benefit from this. Next, you would identify what information is required to optimize those, and together we&#39;ll design a framework to compute that information. Finally, you&#39;ll get to the easy part: actually coding and putting those plans into practice. Along the way, you&#39;ll be mentored in submitting many smaller PRs to fix any issues you notice along the journey.</p> <li><p><strong>Optimization passes:</strong></p> <p>Another classic compiler challenge&#33; We have some basic optimization passes &#40;inlining, basic DCE, SROA&#41;, but currently many other interesting passes simply don&#39;t yet exist, or have a partial PR, but need significant effort to finish. For this proposal, we can work together to define which optimizations we could tackle next.</p> <li><p><strong>Investigating OrcJIT v2 improvements:</strong></p> <p>The LLVM JIT has gained many new features. This project would involve finding out what they are and making use of them. Some examples include better resource tracking, parallel compilation, a new linker &#40;which may need upstream work too&#41;, and fine-grained tracking of relocations.</p> <li><p><strong>Parser error messages &#40;and other parts&#41;:</strong></p> <p>Error messages and infrastructure could use some work to track source locations more precisely. This may be a large project. Contact me and @c42f for more details if this interests you.</p> <li><p><strong>Macro hygiene re-implementation, to eliminate incorrect predictions inherent in current approach:</strong></p> <p>This may be a good project for someone that wants to learn lisp/scheme&#33; Our current algorithm runs in multiple passes, which means sometimes we compute the wrong scope for a variable in the earlier pass than when we assign the actual scope to each value. See <a href="https://github.com/JuliaLang/julia/labels/macros">https://github.com/JuliaLang/julia/labels/macros</a>, and particularly issues such as <a href="https://github.com/JuliaLang/julia/issues/20241">https://github.com/JuliaLang/julia/issues/20241</a> and <a href="https://github.com/JuliaLang/julia/issues/34164">https://github.com/JuliaLang/julia/issues/34164</a>.</p> <li><p><strong>Better debug information output for variables:</strong></p> <p>We have part of the infrastructure in place for representing DWARF information for our variables, but only from limited places. We could do much better since there are numerous opportunities for improvement&#33;</p> </ul> <p><strong>Recommended Skills</strong>: Most of these projects involve algorithms work, requiring a willingness and interest in seeing how to integrate with a large system.</p> <p><strong>Mentors</strong>: <a href="https://github.com/vtjnash">Jameson Nash</a></p> <h2 id=improving_test_coverage ><a href="#improving_test_coverage">Improving test coverage</a></h2> <p>Code coverage reports very good coverage of all of the Julia Stdlib packages, but it&#39;s not complete. Additionally, the coverage tools themselves &#40;–track-coverage and <a href="https://github.com/JuliaCI/Coverage.jl">https://github.com/JuliaCI/Coverage.jl</a>&#41; could be further enhanced, such as to give better accuracy of statement coverage, or more precision. A successful project may combine a bit of both building code and finding faults in others&#39; code.</p> <p>Another related side-project might be to explore adding Type information to the coverage reports?</p> <p><strong>Recommended Skills</strong>: An eye for detail, a thrill for filing code issues, and the skill of breaking things.</p> <p><strong>Contact:</strong> <a href="https://github.com/vtjnash">Jameson Nash</a></p> <h2 id=multi-threading_improvement_projects ><a href="#multi-threading_improvement_projects">Multi-threading Improvement Projects</a></h2> <p>A few ideas to get you started, in brief:</p> <ul> <li><p>Make better use of threads for GC &#40;and particularly, make the page-allocator multi-threaded&#41;</p> <li><p>Improve granularity of codegen JIT for multi-threading</p> <li><p>Improve granularity of IO operations for multi-threading &#40;and set up a worker thread for running the main libuv event loop&#41;</p> <li><p>Measure and optimize the performance of the <code>partr</code> algorithm, and add the ability to dynamically scale it by workload size</p> <li><p>Automatic insertion of GC safe-points/regions, particularly around loops</p> <li><p>Work towards supporting a dynamic number of threads</p> </ul> <p>Join the regularly scheduled multithreading call for discussion of any of these at <a href="https://calendar.google.com/event?action&#61;TEMPLATE&amp;tmeid&#61;MzQ1MnZxMGNucGt2NGQwYW1zZjA4MzM5dGtfMjAyMTAyMTdUMTYzMDAwWiBqdWxpYWxhbmcub3JnX2tvbWF1YXFldDE0ZW9nOW9pdjNwNm83cG1nQGc&amp;tmsrc&#61;julialang.org_komauaqet14eog9oiv3p6o7pmg&#37;40group.calendar.google.com&amp;scp&#61;ALL">#multithreading BoF calendar invite</a> on the Julia Language Public Events calendar.</p> <p> <strong>Recommended Skills</strong>: Varies by project</p> <p><strong>Contact:</strong> <a href="https://github.com/vtjnash">Jameson Nash</a></p> <h2 id=automated_performance_measurements ><a href="#automated_performance_measurements">Automated performance measurements</a></h2> <p>The Nanosoldier.jl project &#40;and related <a href="https://github.com/JuliaCI/BaseBenchmarks.jl">https://github.com/JuliaCI/BaseBenchmarks.jl</a>&#41; tests for performance impacts of some changes. However, there remains many areas that are not covered &#40;such as compile time&#41; while other areas are over-covered &#40;greatly increasing the duration of the test for no benefit&#41; and some tests may not be configured appropriately for statistical power. Furthermore, the current reports are very primitive and can only do a basic pair-wise comparison, while graphs and other interactive tooling would be more valuable. Thus, there would be many great projects for a summer student to tackle here&#33;</p> <p><strong>Contact:</strong> <a href="https://github.com/vtjnash">Jameson Nash</a>, <a href="https://github.com/maleadt">Tim Besard</a></p> <h1 id=deepchemjl_development_projects_summer_of_code ><a href="#deepchemjl_development_projects_summer_of_code">DeepChem.jl development projects – Summer of Code</a></h1> <h2 id=towards_deepchemjl_combining_machine_learning_with_chemical_knowledge ><a href="#towards_deepchemjl_combining_machine_learning_with_chemical_knowledge">Towards DeepChem.jl: Combining Machine Learning with Chemical Knowledge</a></h2> <p>We have been developing the AtomicGraphNets.jl package, which began modestly as a Julia port of <a href="https://github.com/txie-93/cgcnn">CGCNN</a>, but now has plans to expand to a variety of more advanced graph-based methods for state-of-the-art ML performance making predictions on atomic systems. In support of this package, we are also developing ChemistryFeaturization.jl, which contains functions for building and featurizing atomic graphs from a variety of standard input files. ChemistryFeaturization will eventually form the bedrock of a DeepChem.jl umbrella organization to host a Julia-based port of the popular <a href="http://deepchem.io">Deepchem</a> Python package.</p> <p>Some of the features we&#39;re excited about working on include:</p> <div class=tight-list ><ul> <li><p>smarter hyperparameter optimization for built-in model types, potentially making use of Hyperopt.jl or other existing optimization packages</p> <li><p>building tools to enable sensitivity analysis along values of various input features as well as testing the importance of including those features at all</p> <li><p>implementing <a href="https://arxiv.org/abs/1905.12712">Path-Augmented Graph Transformer</a> layers</p> <li><p>allowing new types of graph features &#40;e.g. edge features, user-defined features rather than only pulling from databases, etc.&#41; and building network layers that can make use of these features</p> <li><p>building more physically-informed pooling operations</p> <li><p>Improving documentation, example sets, and building tutorials for both of these packages &#40;<a href="/jsoc/gsod/projects">see cross-posting at Julia GSoD site</a>&#41;</p> </ul></div> <p><strong>Recommended Skills</strong>: Basic graph theory and linear algebra, some knowledge of chemistry</p> <p><strong>Expected Results</strong>: Contributions of new features in the eventual DeepChem.jl ecosystem</p> <p><strong>Mentors</strong>: <a href="https://github.com/rkurchin">Rachel Kurchin</a></p> <h1 id=dftkjl_development_projects_summer_of_code ><a href="#dftkjl_development_projects_summer_of_code">DFTK.jl development projects – Summer of Code</a></h1> <h2 id=automatic_differentiation_in_density-functional_theory ><a href="#automatic_differentiation_in_density-functional_theory">Automatic differentiation in density-functional theory</a></h2> <p>Density-functional theory &#40;DFT&#41; is probably the most widespread method for simulating the quantum-chemical behaviour of electrons in matter and applications cover a wide range of fields such as materials research, chemistry or pharmacy. For aspects like designing the batteries, catalysts or drugs of tomorrow DFT is nowadays a key building block of the ongoing research. The aim to tackle even larger and more involved systems with DFT, however, keeps posing novel challenges with respect to physical models, reliability and performance. For tackling these aspects in the multidisciplinary context of DFT we recently started the <a href="https://dftk.org">density functional toolkit &#40;DFTK&#41;</a>, a DFT package written in pure Julia.</p> <p>Aside from computing the DFT energy itself, most applications of DFT require also derivatives of the energy with respect to various computational parameters. Examples are the forces &#40;derivative energy with respect to atomic positions&#41; and stresses &#40;derivative energy with respect to lattice parameters&#41;. While the expressions of these derivatives are well-known for the standard DFT approaches implementing these is still a laborious &#40;and sometimes boring&#41; task. Additionally deriving these forces and stresses expressions for novel models currently boils down to manually doing so on pen and paper, which for the more involved models can be non-trivial.</p> <p>As an alternative we want to take a look at combining the automatic-differentiation &#40;AD&#41; capabilities of the Julia ecosystem with DFTK in order to compute stresses without implementing the derivatives by hand. Instead we want to make DFTK suitable for AD, such that stresses for our current &#40;and future&#41; DFT models can be computed automatically. Being able to combine DFTK and AD would not only give us stresses, but it would also pave the road for computing even more involved properties using AD. In this final stage of the project it would be required to AD through the whole of DFTK &#40;including several layers of solvers&#41;.</p> <p><strong>Project type:</strong> Risky and exploratory &#40;essentially a small research project&#41;</p> <p><strong>Level of difficulty:</strong> Hard</p> <p><strong>Recommended skills:</strong> Interest to work on an multidisciplinary project bordering physics, mathematics and computer science with a good working knowledge of differential calculus and Julia. Detailed knowledge in the physical background &#40;electrostatics, material science&#41; or about automatic differentiation is not required, but be prepared to take a closer look at these domains during the project.</p> <p><strong>Expected results:</strong> Use automatic differentiation to implement stresses &#40;derivatives of the total energy with respect to lattice parameters&#41; into DFTK.</p> <p><strong>Mentors:</strong> Keno Fischer, Michael F. Herbst, Antoine Levitt</p> <p><strong>References:</strong> For a nice intro to DFT and DFTK.jl see <a href="https://www.youtube.com/watch?v&#61;-RomkxjlIcQ">Michael&#39;s talk at JuliaCon 2020</a> and the literature given in the <a href="https://docs.dftk.org/stable/guide/density_functional_theory/">DFTK documentation</a>. A concise introduction into AD are <a href="http://antoine.levitt.fr/adjoint.pdf">Antoine&#39;s notes on the adjoint trick</a>.</p> <p><strong>Contact:</strong> For any questions, feel free to email <a href="https://github.com/mfherbst">@mfherbst</a>, <a href="https://github.com/antoine-levitt">@antoine-levitt</a> or write us on <a href="https://gitter.im/DFTK-jl/community">our gitter chat</a>.</p> <h1 id=numerical_differential_equations_projects_summer_of_code ><a href="#numerical_differential_equations_projects_summer_of_code">Numerical Differential Equations Projects – Summer of Code</a></h1> <h2 id=native_julia_ode_sde_dae_dde_and_spde_solvers ><a href="#native_julia_ode_sde_dae_dde_and_spde_solvers">Native Julia ODE, SDE, DAE, DDE, and &#40;S&#41;PDE Solvers</a></h2> <p>The DifferentialEquations.jl ecosystem has an extensive set of state-of-the-art methods for solving differential equations hosted by the <a href="https://sciml.ai/">SciML Scientific Machine Learning Software Organization</a>. By mixing native methods and wrapped methods under the same dispatch system, <a href="https://arxiv.org/abs/1807.06430">DifferentialEquations.jl serves both as a system to deploy and research the most modern efficient methodologies</a>. While most of the basic methods have been developed and optimized, many newer methods need high performance implementations and real-world tests of their efficiency claims. In this project students will be paired with current researchers in the discipline to get a handle on some of the latest techniques and build efficient implementations into the &#42;DiffEq libraries &#40;OrdinaryDiffEq.jl, StochasticDiffEq.jl, DelayDiffEq.jl&#41;. Possible families of methods to implement are:</p> <div class=tight-list ><ul> <li><p>Global error estimating ODE solvers</p> <li><p>Implicit-Explicit &#40;IMEX&#41; Methods</p> <li><p>Geometric &#40;exponential&#41; integrators</p> <li><p>Low memory Runge-Kutta methods</p> <li><p>Multistep methods specialized for second order ODEs &#40;satellite simulation&#41;</p> <li><p>Parallel &#40;multithreaded&#41; extrapolation &#40;both explicit and implicit&#41;</p> <li><p>Parallel Implicit Integrating Factor Methods &#40;PDEs and SPDEs&#41;</p> <li><p>Parallel-in-time ODE Methods</p> <li><p>Rosenbrock-W methods</p> <li><p>Approximate matrix factorization</p> <li><p>Runge-Kutta-Chebyshev Methods &#40;high stability RK methods&#41;</p> <li><p>Fully Implicit Runge-Kutta &#40;FIRK&#41; methods</p> <li><p>Anderson Acceleration</p> <li><p>Boundary value problem &#40;BVP&#41; solvers like MIRK and collocation methods</p> <li><p>BDF methods for differential-algebraic equations &#40;DAEs&#41;</p> <li><p>Methods for stiff stochastic differential equations</p> </ul></div> <p>Many of these methods are the basis of high-efficiency partial differential equation &#40;PDE&#41; solvers and are thus important to many communities like computational fluid dynamics, mathematical biology, and quantum mechanics.</p> <p>This project is good for both software engineers interested in the field of numerical analysis and those students who are interested in pursuing graduate research in the field.</p> <p><strong>Recommended Skills</strong>: Background knowledge in numerical analysis, numerical linear algebra, and the ability &#40;or eagerness to learn&#41; to write fast code.</p> <p><strong>Expected Results</strong>: Contributions of production-quality solver methods.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a></p> <h2 id=improvements_to_physics-informend_neural_networks_pinn_for_solving_differential_equations ><a href="#improvements_to_physics-informend_neural_networks_pinn_for_solving_differential_equations">Improvements to Physics-Informend Neural networks &#40;PINN&#41; for solving differential equations</a></h2> <p>Neural networks can be used as a method for efficiently solving difficult partial differential equations. Efficient implementations of physics-informed machine learning from recent papers are being explored as part of the <a href="https://github.com/SciML/NeuralPDE.jl">NeuralPDE.jl</a> package. The <a href="https://github.com/SciML/NeuralPDE.jl/issues">issue tracker</a> contains links to papers which would be interesting new neural network based methods to implement and benchmark against classical techniques.</p> <p><strong>Recommended Skills</strong>: Background knowledge in numerical analysis and machine learning.</p> <p><strong>Expected Results</strong>: New neural network based solver methods.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a></p> <h2 id=performance_enhancements_for_differential_equation_solvers ><a href="#performance_enhancements_for_differential_equation_solvers">Performance enhancements for differential equation solvers</a></h2> <p>Wouldn&#39;t it be cool to have had a part in the development of widely used efficient differential equation solvers? DifferentialEquations.jl has a wide range of existing methods and <a href="https://github.com/SciML/DiffEqBenchmarks.jl">an extensive benchmark suite</a> which is used for tuning the methods for performance. Many of its methods are already the fastest in their class, but there is still a lot of performance enhancement work that can be done. In this project you can learn the details about a wide range of methods and dig into the optimization of the algorithm&#39;s strategy and the implementation in order to improve benchmarks. Projects that could potentially improve the performance of the full differential equations ecosystem include:</p> <div class=tight-list ><ul> <li><p>Alternative adaptive stepsize techniques and step optimization</p> <li><p>Pointer swapping tricks</p> <li><p>Quasi-Newton globalization and optimization</p> <li><p>Cache size reductions</p> <li><p>Enhanced within-method multithreading, distributed parallelism, and GPU usage</p> <li><p>Improved automated method choosing</p> <li><p>Adaptive preconditioning on large-scale &#40;PDE&#41; discretizations</p> </ul></div> <p><strong>Recommended Skills</strong>: Background knowledge in numerical analysis, numerical linear algebra, and the ability &#40;or eagerness to learn&#41; to write fast code.</p> <p><strong>Expected Results</strong>: Improved benchmarks to share with the community.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a></p> <h2 id=discretizations_of_partial_differential_equations ><a href="#discretizations_of_partial_differential_equations">Discretizations of partial differential equations</a></h2> <p>There are two ways to approach libraries for partial differential equations &#40;PDEs&#41;: one can build &quot;toolkits&quot; which enable users to discretize any PDE but require knowledge of numerical PDE methods, or one can build &quot;full-stop&quot; PDE solvers for specific PDEs. There are many different ways solving PDEs could be approached, and here are some ideas for potential projects:</p> <div class=tight-list ><ol> <li><p>Automated PDE discretization tooling. We want users to describe a PDE in its mathematical form and automate the rest of the solution process. See <a href="https://github.com/SciML/DifferentialEquations.jl/issues/469">this issue for details</a>.</p> <li><p>Enhancement of existing tools for discretizing PDEs. The finite differencing &#40;FDM&#41; library <a href="https://github.com/SciML/DiffEqOperators.jl">DiffEqOperators.jl</a> could be enhanced to allow non-uniform grids or composition of operators. The finite element method &#40;FEM&#41; library <a href="https://github.com/SciML/FEniCS.jl">FEniCS.jl</a> could wrap more of the FEniCS library.</p> <li><p>Full stop solvers of common fluid dynamical equations, such as diffusion-advection-convection equations, or of hyperbolic PDEs such as the Hamilton-Jacobi-Bellman equations would be useful to many users.</p> <li><p>Using stochastic differential equation &#40;SDE&#41; solvers to efficiently &#40;and highly parallel&#41; approximate certain PDEs.</p> <li><p>Development of ODE solvers for more efficiently solving specific types of PDE discretizations. See the &quot;Native Julia solvers for ordinary differential equations&quot; project.</p> </ol></div> <p><strong>Recommended Skills</strong>: Background knowledge in numerical methods for solving differential equations. Some basic knowledge of PDEs, but mostly a willingness to learn and a strong understanding of calculus and linear algebra.</p> <p><strong>Expected Results</strong>: A production-quality PDE solver package for some common PDEs.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a></p> <h2 id=tools_for_global_sensitivity_analysis ><a href="#tools_for_global_sensitivity_analysis">Tools for global sensitivity analysis</a></h2> <p>Global Sensitivity Analysis is a popular tool to assess the effect that parameters have on a differential equation model. A good introduction <a href="https://discovery.ucl.ac.uk/id/eprint/19896/">can be found in this thesis</a>. Global Sensitivity Analysis tools can be much more efficient than Local Sensitivity Analysis tools, and give a better view of how parameters affect the model in a more general sense. The goal of this project would be to implement more global sensitivity analysis methods like the eFAST method into <a href="https://github.com/SciML/DiffEqSensitivity.jl">DiffEqSensitivity.jl</a> which can be used with any differential equation solver on the common interface.</p> <p><strong>Recommended Skills</strong>: An understanding of how to use DifferentialEquations.jl to solve equations.</p> <p><strong>Expected Results</strong>: Efficient functions for performing global sensitivity analysis.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a>, <a href="https://github.com/Vaibhavdixit02">Vaibhav Dixit</a></p> <h2 id=parameter_identifiability_analysis ><a href="#parameter_identifiability_analysis">Parameter identifiability analysis</a></h2> <p>Parameter identifiability analysis is an analysis that describes whether the parameters of a dynamical system can be identified from data or whether they are redundant. There are two forms of identifiability analysis: structural and practical. Structural identifiability analysis relates changes in the solution of the ODE directly to other parameters, showcasing that it is impossible to distinguish between parameter A being higher and parameter B being lower, or the vice versa situation, given only data about the solution because of how the two interact. This could be done directly on the symbolic form of the equation as part of <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a>. Meanwhile, practical identifiability analysis looks as to whether the parameters are non-identifiable in a practical sense, for example if two parameters are numerically indistinguishable &#40;given possibly noisy data&#41;. In this case, numerical techniques being built in DiffEqSensitivity.jl, such as a <a href="https://github.com/SciML/DiffEqSensitivity.jl/issues/109">nonlinear likelihood profiler</a> or an <a href="https://github.com/SciML/DiffEqSensitivity.jl/issues/108">information sensitivity measure</a> can be used to showcase whether a parameter has a unique enough effect to be determined.</p> <p><strong>Recommended Skills</strong>: A basic background in differential equations and the ability to use numerical ODE solver libraries. Background in the numerical analysis of differential equation solvers is not required.</p> <p><strong>Expected Results</strong>: Efficient and high-quality implementations of parameter identifiability methods.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a></p> <h2 id=model_order_reduction ><a href="#model_order_reduction">Model Order Reduction</a></h2> <p>Model order reduction is a technique for automatically finding a small model which approximates the large model but is computationally much cheaper. We plan to use the infrastructure built by ModelingToolkit.jl to <a href="https://github.com/SciML/ModelingToolkit.jl/issues/58">implement a litany of methods</a> and find out the best way to accelerate differential equation solves.</p> <p><strong>Recommended Skills</strong>: A basic background in differential equations and the ability to use numerical ODE solver libraries. Background in the numerical analysis of differential equation solvers is not required.</p> <p><strong>Expected Results</strong>: Efficient and high-quality implementations of model order reduction methods.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a></p> <h2 id=automated_symbolic_manipulations_of_differential_equation_systems ><a href="#automated_symbolic_manipulations_of_differential_equation_systems">Automated symbolic manipulations of differential equation systems</a></h2> <p>Numerically solving a differential equation can be difficult, and thus it can be helpful for users to simplify their model before handing it to the solver. Alas this takes time... so let&#39;s automate it&#33; <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a> is a project for automating the model transformation process. Various parts of the library are still open, such as:</p> <div class=tight-list ><ul> <li><p>Support for DAEs, DDEs, and SDEs</p> <li><p>Pantelides algorithm for DAE index reduction</p> <li><p>Lamperti transforms</p> <li><p>Automatic construction of adjoint solutions</p> <li><p>Tearing in nonlinear solvers</p> <li><p>Solving distributed delay equations</p> </ul></div> <p><strong>Recommended Skills</strong>: A basic background in differential equations and the ability to use numerical ODE solver libraries. Background in the numerical analysis of differential equation solvers is not required.</p> <p><strong>Expected Results</strong>: Efficient and high-quality implementations of model transformation methods.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a></p> <h1 id=documentation_tooling ><a href="#documentation_tooling">Documentation tooling</a></h1> <h2 id=documenterjl ><a href="#documenterjl">Documenter.jl</a></h2> <p>The Julia manual and the documentation for a large chunk of the ecosystem is generated using <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> – essentially a static site generator that integrates with Julia and its docsystem. There are tons of opportunities for improvements for anyone interested in working on the interface of Julia, documentation and various front-end technologies &#40;web, LaTeX&#41;.</p> <ul> <li><p><strong>ElasticSearch-based search backend for Documenter.</strong> Loading the search page of Julia manual is slow because the index is huge and needs to be downloaded and constructed on the client side on every page load. Instead, we should look at hosting the search server-side. Goal is to continue the work done during a MLH fellowship for implementing an <a href="https://www.elastic.co/">ElasticSearch</a>-based search backend.</p> <li><p><strong>Improve the generated PDF in the PDF/LaTeX backend.</strong> The goals is to improve the look of the generated PDF and make sure backend works reliably &#40;improved testing&#41;. See <a href="https://github.com/JuliaDocs/Documenter.jl/issues/949">#949</a>, <a href="https://github.com/JuliaDocs/Documenter.jl/issues/1342">#1342</a> and <a href="https://github.com/JuliaDocs/Documenter.jl/labels/Format&#37;3A&#37;20LaTeX">other related issues</a>.</p> </ul> <p><strong>Recommended skills:</strong> Basic knowledge of web-development &#40;JS, CSS, HTML&#41; or LaTeX, depending on the project.</p> <p><strong>Mentors:</strong> <a href="https://github.com/mortenpi">Morten Piibeleht</a></p> <h2 id=docsystem_api ><a href="#docsystem_api">Docsystem API</a></h2> <p>Julia supports docstrings – inline documentation which gets parsed together with the code and can be accessed dynamically in a Julia session &#40;e.g. via the REPL <code>?&gt;</code> help mode; implemented mostly in the <a href="https://github.com/JuliaLang/julia/tree/master/base/docs">Docs module</a>&#41;.</p> <p>Not all docstrings are created equal however. There are bugs in Julia&#39;s docsystem code, which means that some docstrings do not get stored or are stored with the wrong key &#40;parametric methods&#41;. In addition, the API to fetch and work with docstrings programmatically is not documented, not considered public and could use some polishing.</p> <div class=tight-list ><ul> <li><p>Create a package which would provide a clean up the API for working with docstrings, and abstract away the implementation details &#40;and potential differences between Julia versions&#41; of the docsystem in Base.</p> <li><p>Fix as many docsystem-related bugs in the Julia core as possible &#91;<a href="http://mortenpi.eu/gsoc2019/latest/notes/docsystem-internals/#Docsystem-bugs-1">further reading</a>, <a href="https://github.com/JuliaLang/julia/issues/16730">#16730</a>, <a href="https://github.com/JuliaLang/julia/issues/29437">#29437</a>, <a href="https://github.com/JuliaDocs/Documenter.jl/issues/558">JuliaDocs/Documenter.jl#558</a>&#93;</p> </ul></div> <p><strong>Recommended skills:</strong> Basic familiarity with Julia is sufficient.</p> <p><strong>Mentors:</strong> <a href="https://github.com/mortenpi">Morten Piibeleht</a></p> <h1 id=machine_learning_projects_-_summer_of_code ><a href="#machine_learning_projects_-_summer_of_code">Machine Learning Projects - Summer of Code</a></h1> <h3 id=cuda_hacking ><a href="#cuda_hacking">CUDA Hacking</a></h3> <p>Are you a performance nut? Help us implement cutting-edge CUDA kernels in Julia for operations important across deep learning, scientific computing and more. We also need help developing our wrappers for machine learning, sparse matrices and more, as well as CI and infrastructure. Contact us to develop a project plan.</p> <p>Mentors: <a href="https://github.com/maleadt">Tim Besard</a>, <a href="https://github.com/DhairyaLGandhi">Dhairya Gandhi</a>.</p> <h3 id=reinforcement_learning_environments ><a href="#reinforcement_learning_environments">Reinforcement Learning Environments</a></h3> <p>Develop a series of reinforcement learning environments, in the spirit of the <a href="https://gym.openai.com">OpenAI Gym</a>. Although we have wrappers for the gym available, it is hard to install &#40;due to the Python dependency&#41; and, since it&#39;s written in Python and C code, we can&#39;t do more interesting things with it &#40;such as differentiate through the environments&#41;. A pure-Julia version that supports a similar API and visualisation options would be valuable to anyone doing RL with Flux.</p> <p>Mentors: <a href="https://github.com/DhairyaLGandhi/">Dhairya Gandhi</a>.</p> <h3 id=reinforcement_learning_algorithms ><a href="#reinforcement_learning_algorithms">Reinforcement Learning Algorithms</a></h3> <p>Recent advances in reinforcement learning led to many breakthroughs in artificial intelligence. Some of the latest deep reinforcement learning algorithms have been implemented in <a href="https://github.com/JuliaReinforcementLearning/ReinforcementLearning.jl">ReinforcementLearning.jl</a> with Flux. We&#39;d like to have more interesting and practical algorithms added to enrich the whole community, including but not limited to the following directions:</p> <ul> <li><p><strong>&#91;Easy&#93; Recurrent version of existing algorithms</strong>. Students with a basic understanding of Q-learning and recurrent neural networks are preferred. We&#39;d like to have a general implementation to easily extend existing algorithms to the sequential version.</p> <li><p><strong>&#91;Medium&#93; Offline reinforcement learning algorithms</strong>. A bunch of offline reinforcement learning algorithms are proposed in recent years, including <a href="https://arxiv.org/pdf/1910.01708.pdf">BCQ</a>, <a href="https://arxiv.org/abs/2006.15134">CRR</a>, <a href="https://arxiv.org/abs/2006.04779">CQL</a> and so on. The expected output is to have some typical offline reinforcement learning algorithms and experiments added into <a href="https://github.com/JuliaReinforcementLearning/ReinforcementLearningZoo.jl">ReinforcementLearningZoo.jl</a>.</p> <li><p><strong>&#91;Medium&#93; Model-based reinforcement learning algorithms</strong>. Students interested in this topic may refer <a href="https://arxiv.org/abs/2006.16712">Model-based Reinforcement Learning: A Survey</a> and design some general interfaces to implement typical model based algorithms.</p> <li><p><strong>&#91;Medium&#93; Multi-agent reinforcement learning algorithms</strong>. Currently, we only have some CFR related algorithms implemented. We&#39;d like to have more implemented, including <a href="https://arxiv.org/abs/1706.02275v4">MADDPG</a>, <a href="https://arxiv.org/abs/1705.08926">COMA</a>, <a href="https://arxiv.org/abs/1603.01121">NFSP</a>, <a href="https://arxiv.org/abs/1711.00832">PSRO</a>.</p> <li><p><strong>&#91;Hard&#93; Distributed reinforcement learning framework</strong>. Inspired by <a href="https://arxiv.org/abs/2006.00979">Acme</a>, a similar design is proposed in <a href="https://github.com/JuliaReinforcementLearning/DistributedReinforcementLearning.jl">DistributedReinforcementLearning.jl</a>. However, it is still in a very early stage. Students interested in this direction are required to have a basic understanding of distributed computing in Julia. Ideally we&#39;d like to see some distributed reinforcement learning algorithms implemented under this framework, like <a href="https://openreview.net/forum?id&#61;r1lyTjAqYX&amp;utm_campaign&#61;RL&#37;20Weekly&amp;utm_medium&#61;email&amp;utm_source&#61;Revue&#37;20newsletter">R2D2</a>, <a href="https://arxiv.org/abs/1804.08617v1">D4PG</a>.</p> </ul> <h4 id=expected_outcomes ><a href="#expected_outcomes">Expected Outcomes</a></h4> <p>For each new algorithm, at least two experiments are expected to be added into <a href="https://github.com/JuliaReinforcementLearning/ReinforcementLearningZoo.jl">ReinforcementLearningZoo.jl</a>. A simple one to make sure it works on some toy games with CPU only and another more practical one to produce comparable results on the original paper with GPU enabled. Besides, a technical report on the implementation details and speed/performance comparison with other baselines is preferred.</p> <p>Mentors: <a href="https://github.com/findmyway">Jun Tian</a></p> <h3 id=alphazerojl ><a href="#alphazerojl">AlphaZero.jl</a></h3> <p>The philosophy of the <a href="https://github.com/jonathan-laurent/AlphaZero.jl">AlphaZero.jl</a> project is to provide an implementation of AlphaZero that is simple enough to be widely accessible for students and researchers, while also being sufficiently powerful and fast to enable meaningful experiments on limited computing resources &#40;our latest release is consistently between one and two orders of magnitude faster than competing Python implementations&#41;.</p> <p>Here are a few project ideas that build on AlphaZero.jl. Please contact us for additional details and let us know about your experience and interests so that we can build a project that best suits your profile.</p> <ul> <li><p>&#91;Easy&#93; Integrate AlphaZero.jl with the <a href="https://github.com/JuliaReinforcementLearning/OpenSpiel.jl">OpenSpiel</a> game library and benchmark it on a series of simple board games.</p> <li><p>&#91;Medium&#93; Use AlphaZero.jl to train a chess agent. In order to save computing resources and allow faster bootstrapping, you may train an initial policy using supervised learning.</p> <li><p>&#91;Hard&#93; Build on AlphaZero.jl to implement the <a href="https://deepmind.com/blog/article/muzero-mastering-go-chess-shogi-and-atari-without-rules">MuZero</a> algorithm.</p> <li><p>&#91;Hard&#93; Explore applications of AlphaZero beyond board games &#40;e.g. theorem proving, chip design, chemical synthesis...&#41;.</p> </ul> <h4 id=expected_outcomes__2 ><a href="#expected_outcomes__2">Expected Outcomes</a></h4> <p>In all these projects, the goal is not only to showcase the current Julia ecosystem and test its limits, but also to push it forward through concrete contributions that other people can build on. Such contributions include:</p> <ul> <li><p>Improvements to existing Julia packages &#40;e.g. AlphaZero, ReinforcementLearning, CommonRLInterface, Dagger, Distributed, CUDA...&#41; through code, documentation or benchmarks.</p> <li><p>A well-documented and replicable artifact to be added to <a href="https://github.com/jonathan-laurent/AlphaZero.jl/tree/master/games">AlphaZero.Examples</a>, <a href="https://github.com/JuliaReinforcementLearning/ReinforcementLearningZoo.jl">ReinforcementLearningZoo</a> or released in its own package.</p> <li><p>A blog post that details your experience, discusses the challenges you went through and identifies promising areas for future work.</p> </ul> <p><strong>Mentors</strong>: <a href="https://github.com/jonathan-laurent">Jonathan Laurent</a></p> <h3 id=nlp_tools_and_models ><a href="#nlp_tools_and_models">NLP Tools and Models </a></h3> <p><strong>Difficulty</strong>: Medium to Hard</p> <p>Build deep learning models for Natural Language Processing in Julia. <a href="https://github.com/juliatext/TextAnalysis.jl">TextAnalysis</a> and <a href="https://github.com/JuliaText/WordTokenizers.jl">WordTokenizers</a> contains the basic algorithms and data structures to work with textual data in Julia. On top of that base, we want to build modern deep learning models based on recent research. The following tasks can span multiple students and projects.</p> <p>It is important to note that we want practical, usable solutions to be created, not just research models. This implies that a large part of the effort will need to be in finding and using training data, and testing the models over a wide variety of domains. Pre-trained models must be available to users, who should be able to start using these without supplying their own training data.</p> <div class=tight-list ><ul> <li><p>Implement GPT/GPT-2 in Julia</p> <li><p>Implement <a href="https://arxiv.org/abs/1909.03186">extractive summarisation based on Transformers</a></p> <li><p>Implement practical models for</p> <ul> <li><p>Dependency Tree Parsing </p> <li><p>Morphological extractions </p> <li><p>Translations &#40;using Transformers&#41; </p> </ul> <li><p>Indic language support – validate and test all models for Indic languages</p> <ul> <li><p>ULMFiT models for Indic languages</p> </ul> <li><p>Chinese tokenisation and parsing</p> </ul></div> <p><strong>Mentors</strong>: <a href="https://github.com/aviks/">Avik Sengupta</a></p> <h3 id=automated_music_generation ><a href="#automated_music_generation">Automated music generation </a></h3> <p><strong>Difficulty</strong>: Hard</p> <p>Neural network based models can be used for music analysis and music generation &#40;composition&#41;. A suite of tools in Julia to enable research in this area would be useful. This is a large, complex project that is suited for someone with an interest in music and machine learning. This project will need a mechanism to read music files &#40;primarily MIDI&#41;, a way to synthesise sounds, and finally a model to learn composition. All of this is admittedly a lot of work, so the exact boundaries of the project can be flexible, but this can be an exciting project if you are interested in both music and machine learning.</p> <p><strong>Recommended Skills</strong>: Music notation, some basic music theory, MIDI format, Transformer and LSTM architectures</p> <p><strong>Resources</strong>: <a href="https://magenta.tensorflow.org/music-transformer">Music Transformer</a>, <a href="https://magenta.tensorflow.org/maestro-wave2midi2wave">Wave2MIDI2Wave</a>, <a href="https://github.com/JuliaMusic/MIDI.jl">MIDI.jl</a>, <a href="https://github.com/JuliaMusic/Mplay.jl">Mplay.jl</a></p> <p><strong>Mentors</strong>: <a href="https://github.com/aviks/">Avik Sengupta</a></p> <h2 id=fluxjl ><a href="#fluxjl">Flux.jl</a></h2> <p>Flux usually takes part in <a href="https://summerofcode.withgoogle.com">Google Summer of Code</a>, as part of the wider Julia organisation. We follow the same <a href="/jsoc/projects/">rules and application guidelines</a> as Julia, so please check there for more information on applying. Below are a set of ideas for potential projects &#40;though you are welcome to explore anything you are interested in&#41;.</p> <p>Flux projects are typically very competitive; we encourage you to get started early, as successful students typically have early PRs or working prototypes as part of the application. It is a good idea to simply start contributing via issue discussion and PRs and let a project grow from there; you can take a look at <a href="https://github.com/FluxML/Flux.jl/issues?q&#61;is&#37;3Aopen&#43;is&#37;3Aissue&#43;label&#37;3A&#37;22help&#43;wanted&#37;22">this list of issues</a> for some starter contributions.</p> <h3 id=port_ml_tutorials ><a href="#port_ml_tutorials">Port ML Tutorials</a></h3> <p>There are many high-quality open-source tutorials and learning materials available, for example from PyTorch and fast.ai. We&#39;d like to have Flux ports of these that we can add to the model zoo, and eventually publish to the Flux website.</p> <p>Mentors: <a href="https://github.com/DhairyaLGandhi/">Dhairya Gandhi</a>.</p> <h3 id=ferminets_generative_synthesis_for_automating_the_choice_of_neural_architectures ><a href="#ferminets_generative_synthesis_for_automating_the_choice_of_neural_architectures">FermiNets: Generative Synthesis for Automating the Choice of Neural Architectures</a></h3> <p>The application of machine learning requires an understanding a practictioner to optimize a neural architecture for a given problem, or does it? Recently techniques in automated machine learning, also known as AutoML, have dropped this requirement by allowing for good architectures to be found automatically. One such method is the <a href="https://arxiv.org/abs/1809.05989">FermiNet</a> which employs generative synthesis to give a neural architecture which respects certain operational requirements. The goal of this project is to implement the FermiNet in Flux to allow for automated sythesis of neural networks.</p> <p>Mentors: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a> and <a href="https://github.com/DhairyaLGandhi/">Dhairya Gandhi</a>.</p> <h3 id=differentiable_rendering_hard ><a href="#differentiable_rendering_hard">Differentiable Rendering &#91;HARD&#93;</a></h3> <p>Expected Outcome: This is motivated to create SoftRasterizer/DiB-R based projects. We already have RayTracer.jl which is motivated by OpenDR. &#40;Of course, if someone wants to implement NERF - like models they are most welcome to submit a proposal&#41;. We would ideally target at least 2 of these models.</p> <p>Skills: GPU Programming, Deep Learning, &#40;deep&#41; familiarity with the literature, familiarity with defining &#40;a lot of&#41; Custom Adjoints</p> <p>Mentors: <a href="https://github.com/DhairyaLGandhi/">Dhairya Gandhi</a>, <a href="https://github.com/jpsamaroo">Julian Samaroo</a>, <a href="https://github.com/avik-pal">Avik Pal</a></p> <h3 id=core_development_medium ><a href="#core_development_medium">Core Development &#91;MEDIUM&#93;</a></h3> <p>Expected Outcomes:</p> <ul> <li><p>Some of the functions require custom adjoints for speedup</p> <li><p>Functions require GPU kernels. Some of these are of common interest to the community like – knn, etc.</p> <li><p>Benchmarking with Tensorflow Graphics and Pytorch3D. We already have the scripts for kaolin, need to extend that.</p> <li><p>Most of these problems are listed as issues in the main repo.</p> </ul> <p>Skills: GPU Programming, Deep Learning, familiarity with defining &#40;a lot of&#41; Custom Adjoints</p> <p>Mentors: <a href="https://github.com/DhairyaLGandhi/">Dhairya Gandhi</a></p> <h3 id=fastaijl_development ><a href="#fastaijl_development">FastAI.jl Development</a></h3> <p><strong>Difficulty:</strong> Medium</p> <p>In this project, you will assist the <a href="https://julialang.zulipchat.com/#narrow/stream/237432-ml-ecosystem-coordination">ML community team</a> with building FastAI.jl on top of the existing JuliaML &#43; FluxML ecosystem packages. The primary goal is to create an equivalent to <a href="https://docs.fast.ai">docs.fast.ai</a>. This will require building the APIs, documenting them, and creating the appropriate tutorials. Some familiarity with the following Julia packages is preferred, but it is not required:</p> <div class=tight-list ><ul> <li><p><a href="https://github.com/JuliaML/MLDataPattern.jl.git">MLDataPattern.jl</a></p> <li><p><a href="https://github.com/lorenzoh/FluxTraining.jl.git">FluxTraining.jl</a></p> <li><p><a href="https://github.com/lorenzoh/DataAugmentation.jl">DataAugmentation.jl</a></p> </ul></div> <p>A stretch goal can include extending FastAI.jl beyond its Python-equivalent by leveraging the flexibility in the underlying Julia packages. For example, creating and designing abstractions for distributed data parallel training.</p> <p><strong>Skills:</strong> Familiarity with deep learning pipelines, common practices, Flux.jl, and MLDataPattern.jl</p> <p><strong>Mentors:</strong> <a href="https://github.com/darsnack">Kyle Daruwalla</a></p> <h3 id=differentiable_computer_vision_hard ><a href="#differentiable_computer_vision_hard">Differentiable Computer Vision &#91;HARD&#93;</a></h3> <p>Expected Outcome:</p> <p>Create a library of utliity functions that can consume Julia&#39;s Imaging libraries to make them differentiable. With Zygote.jl, we have the platform to take a general purpose package and apply automatic differentiation to it. This project is motivated to use existing libraries that offer perform computer vision tasks, and augment them with AD to perform tasks such as homography regression.</p> <p>Skills: Familiarity with automatic differentiation, deep learning, and defining &#40;a lot of&#41; Custom Adjoints</p> <p>Mentors: <a href="https://github.com/DhairyaLGandhi/">Dhairya Gandhi</a></p> <h2 id=deep_learning_for_source_code_analysis ><a href="#deep_learning_for_source_code_analysis">Deep Learning for source code analysis </a></h2> <p><strong>Difficulty</strong>: Easy to Medium</p> <p>The use of deep learning tools to source code is an active area of research. With the runtime being able to easily introspect into Julia code &#40;for example, with a clean, accesible AST format&#41;, using theses techniques on Julia code would be a fruitful exercise. </p> <div class=tight-list ><ul> <li><p>Use of RNNs for syntax error correction: https://arxiv.org/abs/1603.06129</p> <li><p>Implement Code2Vec for Julia: https://arxiv.org/abs/1803.09473</p> </ul></div> <p><strong>Recommended Skills:</strong> Familiarity with compiler techniques as well as deep learning tools will be required. The &quot;domain expertise&quot; in this task is Julia programming, so it will need someone who has a reasonable experience of the Julia programming language. </p> <p><strong>Expected Outcome:</strong> Packages for each technique that is usable by general programmers. </p> <p><strong>Mentors</strong>: <a href="https://github.com/aviks/">Avik Sengupta</a></p> <h1 id=high_performance_and_parallel_computing_projects_summer_of_code ><a href="#high_performance_and_parallel_computing_projects_summer_of_code">High Performance and Parallel Computing Projects – Summer of Code</a></h1> <p>Julia is emerging as a serious tool for technical computing and is ideally suited for the ever-growing needs of big data analytics. This set of proposed projects addresses specific areas for improvement in analytics algorithms and distributed data management.</p> <p><strong>Difficulty:</strong> Medium</p> <h2 id=scheduling_algorithms_for_distributed_algorithms ><a href="#scheduling_algorithms_for_distributed_algorithms">Scheduling algorithms for Distributed algorithms</a></h2> <p>Dagger.jl is a native Julia framework and scheduler for distributed execution of Julia code and general purpose data parallelism, using dynamic, runtime-generated task graphs which are flexible enough to describe multiple classes of parallel algorithms. This project proposes to implement different scheduling algorithms for Dagger to optimize scheduling of certain classes of distributed algorithms, such as MapReduce and MergeSort, and properly utilizing heterogeneous compute resources. Students will be expected to find published distributed scheduling algorithms and implement them on top of the Dagger framework, benchmarking scheduling performance on a variety of micro-benchmarks and real problems.</p> <p>Mentors: <a href="https://github.com/jpsamaroo">Julian Samaroo</a>, <a href="https://github.com/vchuravy">Valentin Churavy</a></p> <h2 id=distributed_training ><a href="#distributed_training">Distributed Training</a></h2> <p><strong>Difficulty:</strong> Hard</p> <p>Add a distributed training API for Flux models built on top of <a href="https://github.com/JuliaParallel/Dagger.jl">Dagger.jl</a>. More detailed milestones include building Dagger.jl abstractions for <a href="https://github.com/JuliaParallel/UCX.jl">UCX.jl</a>, then building tools to map Flux models into data parallel Dagger DAGs. The final result should demonstrate a Flux model training with multiple devices in parallel via the Dagger.jl APIs. A stretch goal will include mapping operations with a model to a DAG to facilitate model parallelism as well.</p> <p><strong>Skills:</strong> Familiarity with UCX, representing execution models as DAGs, Flux.jl, and data/model parallelism in machine learning</p> <p><strong>Mentors:</strong> <a href="https://github.com/darsnack">Kyle Daruwalla</a>, <a href="https://github.com/jpsamaroo">Julian Samaroo</a>, and <a href="https://github.com/ToucheSir">Brian Chen</a></p> <h1 id=juliaimages_projects_summer_of_code ><a href="#juliaimages_projects_summer_of_code">JuliaImages Projects – Summer of Code</a></h1> <p><a href="https://github.com/JuliaImages">JuliaImages</a> &#40;see the <a href="https://juliaimages.github.io/latest/">documentation</a>&#41; is a framework in Julia for multidimensional arrays, image processing, and computer vision &#40;CV&#41;. It has an active development community and offers many features that unify CV and biomedical 3D/4D image processing, support big data, and promote interactive exploration.</p> <p>Often the best ideas are the ones that candidate SoC students come up with on their own. We are happy to <a href="https://github.com/JuliaImages/Images.jl/issues/new">discuss such ideas</a> and help you refine your proposal. Below are some potential project ideas that might help spur some thoughts. See the bottom of this page for information about mentors.</p> <h2 id=wide-ranging_demos_easy ><a href="#wide-ranging_demos_easy">Wide-ranging demos &#40;easy&#41;</a></h2> <p>For new or occasional users, JuliaImages would benefit from a large collection of complete worked examples organized by topic. While the current documentation contains many &quot;mini-demos,&quot; they are scattered; an organized page would help users quickly find what they need. We have <a href="https://juliaimages.org/latest/democards/examples/">set up a landing page</a>, but many more demos are needed. <a href="https://scikit-image.org/docs/stable/auto_examples/">Scikit-image</a> is one potential model.</p> <p>This &quot;project&quot; might also be split among multiple students who contribute demos as part of their work in a focused area of JuliaImages.</p> <p>Expected outcomes: a significant expansion of the number of democards.</p> <h2 id=benchmarking_against_other_frameworks_medium ><a href="#benchmarking_against_other_frameworks_medium">Benchmarking against other frameworks &#40;medium&#41;</a></h2> <p>JuliaImages provides high-quality implementations of many algorithms; however, as yet there is no set of benchmarks that compare our code against that of other image-processing frameworks. Developing such benchmarks would allow us to advertise our strengths and/or identify opportunities for further improvement. See also the OpenCV project below.</p> <p>Expected outcomes: benchmarks for several performance-sensitive packages &#40;e.g., ImageFiltering, ImageTransformations, ImageMorphology, ImageContrastAdjustment, ImageEdgeDetection, ImageFeatures, and/or ImageSegmentation&#41; against frameworks like Scikit-image and OpenCV, and optionally others like ITK, ImageMagick, and Matlab/Octave. This task splits into at least two pieces: &#40;1&#41; developing frameworks for collecting the data, and &#40;2&#41; visualizing the results. One should also be aware of the fact that differences in implementation &#40;which may include <a href="https://github.com/JuliaImages/Images.jl/pull/855">differences in quality</a>&#41; may complicate the interpretation of some benchmarks.</p> <h2 id=gpu_support_for_many_algorithms_medium ><a href="#gpu_support_for_many_algorithms_medium">GPU support for many algorithms &#40;medium&#41;</a></h2> <p>JuliaImages supports many common algorithms, but targets only the CPU. With Julia now possessing <a href="https://github.com/JuliaGPU">first-in-class support for GPUs</a>, now is the time to provide GPU implementations of many of the same algorithms.</p> <p><a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions</a> may make it easier to support both CPU and GPU with a common implementation.</p> <p>Expected outcomes: fairly widespread GPU support for a single nontrivial package. <a href="https://github.com/JuliaImages/ImageFiltering.jl">ImageFiltering</a> would be a good choice.</p> <h2 id=interactivity_and_visualization_tools_open-ended ><a href="#interactivity_and_visualization_tools_open-ended">Interactivity and visualization tools &#40;open-ended&#41;</a></h2> <p>Image processing often involves tight interaction between algorithms and visualization. While there are a number of older tools available, leveraging GLVisualize seems to hold the greatest promise. This project might implement a number of interactive tools for region-of-interest selection, annotation, measurement, and modification. Software suites like OpenCV, ImageJ/Fiji, scikit-image, and Matlab might serve as inspiration.</p> <h2 id=integration_of_opencv_and_juliaimages_hard ><a href="#integration_of_opencv_and_juliaimages_hard">Integration of OpenCV and JuliaImages &#40;hard&#41;</a></h2> <p>OpenCV is one of the pre-eminent image-processing frameworks. During the summer of 2020, significant progress was made on a <a href="https://docs.opencv.org/master/d8/da4/tutorial_julia.html">Julia wrapper</a>. An important remaining task is to integrate the wrapper with <a href="https://docs.binarybuilder.org/stable/">Julia&#39;s binary packaging system</a>.</p> <p>Expected outcomes: an OpenCV package that can be installed across all major platforms with <code>Pkg.add&#40;&quot;OpenCV&quot;&#41;</code>.</p> <h2 id=contributions_to_a_stereo_matching_package_medium ><a href="#contributions_to_a_stereo_matching_package_medium">Contributions to a Stereo Matching Package &#40;medium&#41;</a></h2> <p>When two images are taken of a scene with a calibrated stereo rig it is possible to construct a three-dimensional model of the scene provided that one can determine the coordinates of corresponding points in the two images. The task of determining the coordinates of corresponding points is frequently called <em>stereo matching</em> or <em>disparity estimation</em>. Numerous algorithms for this task have been proposed over the years and new ones continue to be developed.</p> <p>This project will implement several stereo matching algorithms. Emphasis will be placed on <em>efficient</em> implementations which leverage all of Julia&#39;s features for writing fast code.</p> <p>Example algorithms:</p> <div class=tight-list ><ol> <li><p>Bleyer, Michael, Christoph Rhemann, and Carsten Rother. &quot;PatchMatch Stereo-Stereo Matching with Slanted Support Windows.&quot; Bmvc. Vol. 11. 2011.</p> <li><p>Hirschmuller, Heiko. &quot;Accurate and efficient stereo processing by semi-global matching and mutual information.&quot; Computer Vision and Pattern Recognition, 2005. CVPR 2005. IEEE Computer Society Conference on. Vol. 2. IEEE, 2005.</p> <li><p>Gehrig, Stefan K., and Clemens Rabe. &quot;Real-time semi-global matching on the CPU.&quot; Computer Vision and Pattern Recognition Workshops &#40;CVPRW&#41;, 2010 IEEE Computer Society Conference on. IEEE, 2010.</p> </ol></div> <p>Expected outcomes: a library of stereo matching algorithms with usage tutorials and documentation.</p> <h2 id=contributions_to_a_calibration_target_package_medium ><a href="#contributions_to_a_calibration_target_package_medium">Contributions to a Calibration Target package &#40;medium&#41;</a></h2> <p>Camera calibration involves determining a camera&#39;s intrinsic parameters from a series of images of a so-called &quot;calibration target&quot;. Knowledge of the intrinsic parameters facilitates three-dimensional reconstruction from images or video. The most frequently used calibration target is a checkerboard pattern. A key step in camera calibration involves automatically detecting the checkerboard and identifying landmarks such as the corners of each checkeboard square. </p> <p>This project will implement a recent automatic checkerboard detection and feature extraction algorithm. </p> <p>Example algorithm:</p> <div class=tight-list ><ol> <li><p>Y. Yan, P. Yang, L. Yan, J. Wan, Y. Sun, and K. Tansey, “Automatic checkerboard detection for camera calibration using self-correlation,” Journal of Electronic Imaging, vol. 27, no. 03, p. 1, May 2018.</p> </ol></div> <p>Expected outcomes: a checkeboard detection algorithm which can provide the necessary inputs to a camera calibration routine. </p> <h3 id=where_to_go_for_discussion_and_to_find_mentors ><a href="#where_to_go_for_discussion_and_to_find_mentors">Where to go for discussion and to find mentors</a></h3> <p>Depending on the project, potential mentors include <a href="https://github.com/timholy">Tim Holy</a> and <a href="https://github.com/zygmuntszpak">Zygmunt Szpak</a> but may also involve other JuliaImages developers. Interested students are encouraged to <a href="https://github.com/JuliaImages/Images.jl/issues/new">open an issue in Images.jl</a> to introduce themselves and discuss project ideas.</p> <h1 id=javis_projects_summer_of_code ><a href="#javis_projects_summer_of_code">Javis Projects – Summer of Code</a></h1> <blockquote> <p>Javis: <strong>J</strong>ulia <strong>A</strong>nimations and <strong>VIS</strong>ualizations</p> </blockquote> <p><a href="https://github.com/Wikunia/Javis.jl/"><code>Javis.jl</code></a> is a general purpose Julia library to easily construct informative, performant, and winsome animated graphics. <code>Javis</code> provides a powerful grammar for users to make animated visuals. Users of <code>Javis</code> have made animations to explain concepts in a variety of fields such as mathematical concepts like <a href="https://opensourc.es/blog/javis-v0.3/">Fourier transformation</a> to <a href="https://github.com/TheCedarPrince/NeuriViz">brain imaging of EEGs</a>. It builds on top of the Julia drawing framework <a href="https://github.com/JuliaGraphics/Luxor.jl">Luxor</a> by adding functions to simplify the creation of objects and their actions.</p> <p>The Summer of Code Javis projects aims at simplifying the creation of animations to explain difficult concepts and communicate to broad audiences how Julia is a strong tool for graphics creation.</p> <p>Below you can find a list of potential projects that can be tackled during Google Summer of Code. If interested in exploring any of these projects, please reach out to:</p> <ul> <li><p><strong><a href="http://jacobzelko.com/">Jacob Zelko</a></strong> - <a href="mailto:jacobszelko@gmail.com">email</a>, <a href="https://julialang.org/slack/">Slack</a> &#40;username: TheCedarPrince&#41;, or <a href="https://julialang.zulipchat.com/">Zulip</a> &#40;username: TheCedarPrince&#41;</p> <li><p><strong><a href="https://opensourc.es/about/">Ole Kröger</a></strong> - <a href="https://julialang.org/slack/">Slack</a> &#40;username: Wikunia&#41;, or <a href="https://julialang.zulipchat.com/">Zulip</a> &#40;username: Wikunia&#41;</p> </ul> <p>Thanks for your interest&#33; 🎉</p> <h2 id=general_improvement_to_user_experience ><a href="#general_improvement_to_user_experience">General Improvement to User Experience</a></h2> <p><strong>Mentors</strong>: Ole Kröger, Jacob Zelko</p> <p><strong>Recommended skills</strong>: General understanding of Luxor and the underlying structure of Javis.</p> <p><strong>Difficulty:</strong> Medium</p> <p><strong>Description</strong>: This project is split across several tasks that are manageable enough to be worked on by a single student in the Google Summer of Code period. These small tasks come together to create an easier and understandable syntax for Javis-based animated graphic creation. The following list are the smaller tasks one could work on:</p> <ul> <li><p>One of the bigger missing features is the lack of combining several objects into a layer. <a href="https://github.com/Wikunia/Javis.jl/issues/75">Issue #75</a></p> <li><p>To improve the user experience it will be helpful to ease object positioning based on other objects. <a href="https://github.com/Wikunia/Javis.jl/issues/130">Issue #130</a></p> <li><p>For visual appeal, morphing shapes into one another shall be improved as it&#39;s currently an undocumented and unfinished feature. <a href="https://github.com/Wikunia/Javis.jl/issues/286">Issue #286</a></p> <li><p>To bring Javis and Julia closer to the broader audience we are interested in the ability of live streaming animations to platforms like Twitch. <a href="https://github.com/Wikunia/Javis.jl/issues/91">Issue #91</a></p> </ul> <h2 id=graph_and_networks ><a href="#graph_and_networks">Graph and networks</a></h2> <p><strong>Mentors</strong>: Ole Kröger, Jacob Zelko</p> <p><strong>Recommended skills</strong>: Knowledge about graph theory and LightGraphs.jl</p> <p><strong>Difficulty:</strong> Hard</p> <p><strong>Description</strong>: Javis could be a powerful platform to easily animate problems and their solutions in a variety of different fields. Currently, Javis lacks the ability to visualize graphs. The goal for this project would be to add graph support to Javis by supporting interoperability with <a href="https://github.com/JuliaGraphs/LightGraphs.jl">LightGraphs.jl</a>. The animation of flows and shortest path is something that&#39;s extremely valuable for teaching as well as in practical analysis of graph networks. To learn more about the current thoughts surrounding this problem, check this <a href="https://github.com/Wikunia/Javis.jl/issues/41">issue</a> for more information. </p> <h2 id=linear_algebra ><a href="#linear_algebra">Linear algebra</a></h2> <p><strong>Mentors</strong>: Ole Kröger, Jacob Zelko</p> <p><strong>Recommended skills</strong>: Basic to intermediate knowledge about linear algebra.</p> <p><strong>Difficulty:</strong> Easy </p> <p><strong>Description</strong>: Linear algebra is of invaluable importance all across different fields of mathematics and engineering. Enabling the easy creation of visualizations regarding rotations, matrices and other concepts is helpful in educating students about this amazing branch mathematics. Here are a few issues related to tasks that could be worked on to bring about this capability:</p> <ul> <li><p>Vectors are foundational to linear algebra, help Javis visualize them&#33; <a href="https://github.com/Wikunia/Javis.jl/issues/31">Issue #31</a></p> <li><p>Drawing backgrounds such as grids can assist in easy viewing of complicated mathematical operations such as rotations. <a href="https://github.com/Wikunia/Javis.jl/issues/38">Issue #38</a></p> </ul> <h1 id=dynamical_systems_complex_systems_nonlinear_dynamics_summer_of_code ><a href="#dynamical_systems_complex_systems_nonlinear_dynamics_summer_of_code">Dynamical systems, complex systems &amp; nonlinear dynamics – Summer of Code</a></h1> <h2 id=agentsjl ><a href="#agentsjl">Agents.jl</a></h2> <p><strong>Difficulty</strong>: Easy to Medium.</p> <p><a href="https://juliadynamics.github.io/Agents.jl/stable/">Agents.jl</a> is a pure Julia framework for agent-based modeling &#40;ABM&#41;. It has an extensive list of features, excellent performance and is easy to learn, use, and extend. Comparisons with other popular frameworks written in Python or Java &#40;NetLOGO, MASON, Mesa&#41;, show that Agents.jl outperforms all of them in computational speed, list of features and usability.</p> <p>In this project students will be paired with lead developers of Agents.jl to improve Agents.jl with more features, better performance, and overall higher polish. Possible features to implement are:</p> <div class=tight-list ><ul> <li><p>File IO of current state of ABM to disk</p> <li><p>Reading lists of human data &#40;e.g. csv files&#41; into <code>Agent</code> instances.</p> <li><p>New type of space representing a planet, which can be used in climate policy or human evolution modelling</p> <li><p>Automatic performance increase of mixed-agent models by eliminating dynamic dispatch on the stepping function</p> <li><p>Port of Open Street Map plotting to Makie.jl.</p> <li><p>GPU support in Agents.jl</p> </ul></div> <p><strong>Recommended Skills</strong>: Familiarity with agent based modelling, Agents.jl and Julia&#39;s Type System. Background in complex systems, sociology, or nonlinear dynamics is not required.</p> <p><strong>Expected Results</strong>: Well-documented, well-tested useful new features for Agents.jl.</p> <p><strong>Mentors</strong>: <a href="https://github.com/Datseris">George Datseris</a>, <a href="https://github.com/Libbum">Tim DuBois</a></p> <h2 id=dynamicalsystemsjl ><a href="#dynamicalsystemsjl">DynamicalSystems.jl</a></h2> <p><strong>Difficulty:</strong> Easy to Hard, depending on the algorithm chosen</p> <p><a href="https://juliadynamics.github.io/DynamicalSystems.jl/latest/">DynamicalSystems.jl</a> is an <a href="https://dsweb.siam.org/The-Magazine/Article/winners-of-the-dsweb-2018-software-contest">award-winning</a> Julia software library for dynamical systems, nonlinear dynamics, deterministic chaos and nonlinear timeseries analysis. It has an impressive list of features, but one can never have enough. In this project students will be able to enrich DynamicalSystems.jl with new algorithms and enrich their knowledge of nonlinear dynamics and computer-assisted exploration of complex systems.</p> <p>Possible projects are summarized in the <a href="https://github.com/issues?q&#61;is&#37;3Aopen&#43;is&#37;3Aissue&#43;repo&#37;3AJuliaDynamics&#37;2FChaosTools.jl&#43;repo&#37;3AJuliaDynamics&#37;2FDynamicalSystemsBase.jl&#43;repo&#37;3AJuliaDynamics&#37;2FDelayEmbeddings.jl&#43;repo&#37;3AJuliaDynamics&#37;2FRecurrenceAnalysis.jl&#43;repo&#37;3AJuliaDynamics&#37;2FDynamicalSystems.jl&#43;label&#37;3A&#37;22wanted&#43;feature&#37;22&#43;">wanted-features of the library</a></p> <p>Examples include but are are not limited to:</p> <div class=tight-list ><ul> <li><p>Nonlinear local Lyapunov exponents</p> <li><p>Final state sensitivity and fractal basin boundaries</p> <li><p>Kolmogorov-Sinai entropy</p> <li><p>Importance sampling for chaotic systems</p> </ul></div> <p>and many more.</p> <p><strong>Recommended Skills</strong>: Familiarity with nonlinear dynamics and/or differential equations and the Julia language.</p> <p><strong>Expected Results</strong>: Well-documented, well-tested new algorithms for DynamicalSystems.jl.</p> <p><strong>Mentors</strong>: <a href="https://github.com/Datseris">George Datseris</a></p> <h1 id=stochastic_differential_equations_and_continuous_time_signal_processing_summer_of_code ><a href="#stochastic_differential_equations_and_continuous_time_signal_processing_summer_of_code">Stochastic differential equations and continuous time signal processing – Summer of Code</a></h1> <h2 id=smoothing_non-linear_continuous_time_systems ><a href="#smoothing_non-linear_continuous_time_systems">Smoothing non-linear continuous time systems</a></h2> <p>The student implements a state of the art smoother for continuous-time systems with additive Gaussian noise. The system&#39;s dynamics can be described as an ordinary differential equation with locally additive Gaussian random fluctuations, in other words a stochastic ordinary differential equation.</p> <p>Given a series of measurements observed over time, containing statistical noise and other inaccuracies, the task is to produce an estimate of the unknown trajectory of the system that led to the observations.</p> <p><em>Linear</em> continuous-time systems are smoothed with the fixed-lag Kalman-Bucy smoother &#40;related to the <a href="https://en.wikipedia.org/wiki/Kalman_filter#Kalman–Bucy_filter">Kalman–Bucy_filter</a>&#41;. It relies on coupled ODEs describing how mean and covariance of the conditional distribution of the latent system state evolve over time. A versatile implementation in Julia is missing.</p> <p><strong>Expected Results</strong>: Build efficient implementation of non-linear smoothing of continuous stochastic dynamical systems.</p> <p><strong>Recommended Skills</strong>: Gaussian random variables, Bayes&#39; formula, Stochastic Differential Equations</p> <p><strong>Mentors</strong>: <a href="https://github.com/mschauer">Moritz Schauer</a></p> <p><strong>Rating</strong>: Hard</p> <h1 id=numerical_projects_summer_of_code ><a href="#numerical_projects_summer_of_code">Numerical Projects – Summer of Code</a></h1> <div class=franklin-toc ><ol><li><a href="#view_all_gsocjsoc_projects">View all GSoC/JSoC Projects</a><li><a href="#projects">Projects</a><li><a href="#new_geostatistical_clustering_methods">New geostatistical clustering methods</a><li><a href="#new_geostatistical_simulation_methods">New geostatistical simulation methods</a><li><a href="#migrate_from_plotsjl_to_makiejl_recipes">Migrate from Plots.jl to Makie.jl recipes</a><li><a href="#how_to_get_started">How to get started?</a><li><a href="#particle_swarm_optimization_of_machine_learning_models">Particle swarm optimization of machine learning models</a><ol><li><a href="#description">Description</a><li><a href="#prerequisites">Prerequisites</a><li><a href="#your_contribution">Your contribution</a><li><a href="#references">References</a></ol><li><a href="#in-processing_methods_for_fairness_in_machine_learning">In-processing methods for fairness in machine learning</a><ol><li><a href="#prerequisites__2">Prerequisites</a><li><a href="#description__2">Description</a><li><a href="#your_contribution__2">Your contribution</a><li><a href="#references__2">References</a></ol><li><a href="#causal_and_counterfactual_methods_for_fairness_in_machine_learning">Causal and counterfactual methods for fairness in machine learning</a><ol><li><a href="#prerequisites__3">Prerequisites</a><li><a href="#description__3">Description</a><li><a href="#your_contribution__3">Your contribution</a><li><a href="#references__3">References</a></ol><li><a href="#time_series_forecasting_at_scale_-_speed_up_via_julia">Time series forecasting at scale - speed up via Julia</a><ol><li><a href="#prerequisites__4">Prerequisites</a><li><a href="#your_contribution__4">Your contribution</a><li><a href="#references__4">References</a></ol><li><a href="#interpretable_machine_learning_in_julia">Interpretable Machine Learning in Julia</a><ol><li><a href="#description__4">Description</a><li><a href="#prerequisites__5">Prerequisites</a><li><a href="#your_contribution__5">Your contribution</a><li><a href="#references__5">References</a></ol><li><a href="#model_visualization_in_mlj">Model visualization in MLJ</a><ol><li><a href="#description__5">Description</a><li><a href="#prerequisites__6">Prerequisites</a><li><a href="#your_contribution__6">Your contribution</a><li><a href="#references__6">References</a></ol><li><a href="#deeper_bayesian_intergration">Deeper Bayesian Intergration</a><ol><li><a href="#description__6">Description</a><li><a href="#your_contributions">Your contributions</a><li><a href="#references__7">References</a><li><a href="#difficulty_medium_to_hard">Difficulty: Medium to Hard</a></ol><li><a href="#mlj_and_mlflow_integration">MLJ and MLFlow integration</a><ol><li><a href="#description__7">Description</a><li><a href="#prerequisites__7">Prerequisites</a><li><a href="#your_contribution__7">Your contribution</a><li><a href="#references__8">References</a></ol><li><a href="#speed_demons_only_need_apply">Speed demons only need apply</a><ol><li><a href="#description__8">Description</a><li><a href="#prerequisites__8">Prerequisites</a><li><a href="#your_contribution__8">Your contribution</a><li><a href="#references__9">References</a></ol><li><a href="#improving_test_coverage">Improving test coverage</a><li><a href="#multi-threading_improvement_projects">Multi-threading Improvement Projects</a><li><a href="#automated_performance_measurements">Automated performance measurements</a><li><a href="#towards_deepchemjl_combining_machine_learning_with_chemical_knowledge">Towards DeepChem.jl: Combining Machine Learning with Chemical Knowledge</a><li><a href="#automatic_differentiation_in_density-functional_theory">Automatic differentiation in density-functional theory</a><li><a href="#native_julia_ode_sde_dae_dde_and_spde_solvers">Native Julia ODE, SDE, DAE, DDE, and &#40;S&#41;PDE Solvers</a><li><a href="#improvements_to_physics-informend_neural_networks_pinn_for_solving_differential_equations">Improvements to Physics-Informend Neural networks &#40;PINN&#41; for solving differential equations</a><li><a href="#performance_enhancements_for_differential_equation_solvers">Performance enhancements for differential equation solvers</a><li><a href="#discretizations_of_partial_differential_equations">Discretizations of partial differential equations</a><li><a href="#tools_for_global_sensitivity_analysis">Tools for global sensitivity analysis</a><li><a href="#parameter_identifiability_analysis">Parameter identifiability analysis</a><li><a href="#model_order_reduction">Model Order Reduction</a><li><a href="#automated_symbolic_manipulations_of_differential_equation_systems">Automated symbolic manipulations of differential equation systems</a><li><a href="#documenterjl">Documenter.jl</a><li><a href="#docsystem_api">Docsystem API</a><ol><li><a href="#cuda_hacking">CUDA Hacking</a><li><a href="#reinforcement_learning_environments">Reinforcement Learning Environments</a><li><a href="#reinforcement_learning_algorithms">Reinforcement Learning Algorithms</a><ol><li><a href="#expected_outcomes">Expected Outcomes</a></ol><li><a href="#alphazerojl">AlphaZero.jl</a><ol><li><a href="#expected_outcomes__2">Expected Outcomes</a></ol><li><a href="#nlp_tools_and_models">NLP Tools and Models </a><li><a href="#automated_music_generation">Automated music generation </a></ol><li><a href="#fluxjl">Flux.jl</a><ol><li><a href="#port_ml_tutorials">Port ML Tutorials</a><li><a href="#ferminets_generative_synthesis_for_automating_the_choice_of_neural_architectures">FermiNets: Generative Synthesis for Automating the Choice of Neural Architectures</a><li><a href="#differentiable_rendering_hard">Differentiable Rendering &#91;HARD&#93;</a><li><a href="#core_development_medium">Core Development &#91;MEDIUM&#93;</a><li><a href="#fastaijl_development">FastAI.jl Development</a><li><a href="#differentiable_computer_vision_hard">Differentiable Computer Vision &#91;HARD&#93;</a></ol><li><a href="#deep_learning_for_source_code_analysis">Deep Learning for source code analysis </a><li><a href="#scheduling_algorithms_for_distributed_algorithms">Scheduling algorithms for Distributed algorithms</a><li><a href="#distributed_training">Distributed Training</a><li><a href="#wide-ranging_demos_easy">Wide-ranging demos &#40;easy&#41;</a><li><a href="#benchmarking_against_other_frameworks_medium">Benchmarking against other frameworks &#40;medium&#41;</a><li><a href="#gpu_support_for_many_algorithms_medium">GPU support for many algorithms &#40;medium&#41;</a><li><a href="#interactivity_and_visualization_tools_open-ended">Interactivity and visualization tools &#40;open-ended&#41;</a><li><a href="#integration_of_opencv_and_juliaimages_hard">Integration of OpenCV and JuliaImages &#40;hard&#41;</a><li><a href="#contributions_to_a_stereo_matching_package_medium">Contributions to a Stereo Matching Package &#40;medium&#41;</a><li><a href="#contributions_to_a_calibration_target_package_medium">Contributions to a Calibration Target package &#40;medium&#41;</a><ol><li><a href="#where_to_go_for_discussion_and_to_find_mentors">Where to go for discussion and to find mentors</a></ol><li><a href="#general_improvement_to_user_experience">General Improvement to User Experience</a><li><a href="#graph_and_networks">Graph and networks</a><li><a href="#linear_algebra">Linear algebra</a><li><a href="#agentsjl">Agents.jl</a><li><a href="#dynamicalsystemsjl">DynamicalSystems.jl</a><li><a href="#smoothing_non-linear_continuous_time_systems">Smoothing non-linear continuous time systems</a><li><a href="#numerical_linear_algebra">Numerical Linear Algebra</a><ol><li><a href="#matrix_functions">Matrix functions</a></ol><li><a href="#better_bignums_integration">Better Bignums Integration</a><ol><li><a href="#special_functions">Special functions</a><li><a href="#a_julia-native_ccsa_optimization_algorithm">A Julia-native CCSA optimization algorithm</a></ol><li><a href="#pluto_as_a_vs_code_notebook">Pluto as a VS Code notebook</a><li><a href="#macro_support">Macro support</a><li><a href="#tools_for_education">Tools for education</a><li><a href="#machine_learning_time_series_regression">Machine Learning Time Series Regression</a><li><a href="#machine_learning_for_nowcasting_and_forecasting">Machine learning for nowcasting and forecasting</a><li><a href="#time_series_forecasting_at_scales">Time series forecasting at scales</a><ol><li><a href="#physics-informed_neural_networks_pinns_and_solving_differential_equations_with_deep_learning">Physics-Informed Neural Networks &#40;PINNs&#41; and Solving Differential Equations with Deep Learning</a><li><a href="#improvements_to_neural_and_universal_differential_equations">Improvements to Neural and Universal Differential Equations</a><li><a href="#accelerating_optimization_via_machine_learning_with_surrogate_models">Accelerating optimization via machine learning with surrogate models</a><li><a href="#parameter_estimation_for_nonlinear_dynamical_models">Parameter estimation for nonlinear dynamical models</a></ol><li><a href="#integration_of_fenicsjl_with_dolfin-adjoint_zygotejl_for_finite_element_scientific_machine_learning">Integration of FEniCS.jl with dolfin-adjoint &#43; Zygote.jl for Finite Element Scientific Machine Learning</a><li><a href="#multi-start_optimization_methods">Multi-Start Optimization Methods</a><li><a href="#groebner_basis_and_symbolic_root_finding">Groebner basis and Symbolic root finding</a><li><a href="#symbolic_integration">Symbolic Integration</a><li><a href="#implement_flashfill_in_julia">Implement Flashfill in Julia </a><li><a href="#parquetjl_enhancements">Parquet.jl enhancements</a><li><a href="#mcmcchains_improvements">MCMCChains improvements</a><li><a href="#particle_filtering_methods">Particle filtering methods</a><li><a href="#nested_sampling">Nested Sampling</a><li><a href="#gpu_acceleration">GPU acceleration</a><li><a href="#documentation_and_tutorial_improvements">Documentation and tutorial improvements</a><li><a href="#iterative_methods_for_inference_in_gaussian_processes">Iterative Methods for Inference in Gaussian Processes</a><li><a href="#implement_advanced_variational_gaussian_process_models">Implement advanced variational Gaussian process models</a><li><a href="#vs_code_extension">VS Code extension</a><li><a href="#package_installation_ui">Package installation UI</a><li><a href="#code_generation_improvements_and_async_abi">Code generation improvements and async ABI</a><li><a href="#wasm_threading">Wasm threading</a><li><a href="#high_performance_low-level_integration_of_js_objects">High performance, Low-level integration of js objects</a><li><a href="#dom_integration">DOM Integration</a><li><a href="#porting_existing_web-integration_packages_to_the_wasm_platform">Porting existing web-integration packages to the wasm platform</a><li><a href="#iodide_notebook_integration">Iodide notebook integration</a><li><a href="#native_dependencies_for_the_web">Native dependencies for the web</a><li><a href="#distributed_computing_with_untrusted_parties">Distributed computing with untrusted parties</a><li><a href="#deployment">Deployment</a></ol></div> <h2 id=numerical_linear_algebra ><a href="#numerical_linear_algebra">Numerical Linear Algebra</a></h2> <h3 id=matrix_functions ><a href="#matrix_functions">Matrix functions</a></h3> <p>Matrix functions map matrices onto other matrices, and can often be interpreted as generalizations of ordinary functions like sine and exponential, which map numbers to numbers. Once considered a niche province of numerical algorithms, matrix functions now appear routinely in applications to cryptography, aircraft design, nonlinear dynamics, and finance.</p> <p>This project proposes to implement state of the art algorithms that extend the currently available matrix functions in Julia, as outlined in issue <a href="https://github.com/JuliaLang/julia/issues/5840">#5840</a>. In addition to matrix generalizations of standard functions such as real matrix powers, surds and logarithms, students will be challenged to design generic interfaces for lifting general scalar-valued functions to their matrix analogues for the efficient computation of arbitrary &#40;well-behaved&#41; matrix functions and their derivatives.</p> <p><strong>Recommended Skills</strong>: A strong understanding of calculus and numerical analysis.</p> <p><strong>Expected Results</strong>: New and faster methods for evaluating matrix functions.</p> <p><strong>Mentors:</strong> <a href="https://github.com/jiahao">Jiahao Chen</a>, <a href="https://github.com/stevengj">Steven Johnson</a>.</p> <p><strong>Difficulty:</strong> Hard</p> <h2 id=better_bignums_integration ><a href="#better_bignums_integration">Better Bignums Integration</a></h2> <p>Julia currently supports big integers and rationals, making use of the GMP. However, GMP currently doesn&#39;t permit good integration with a garbage collector.</p> <p>This project therefore involves exploring ways to improve BigInt, possibly including:</p> <div class=tight-list ><ul> <li><p>Modifying GMP to support high-performance garbage-collection</p> <li><p>Reimplementation of aspects of BigInt in Julia</p> <li><p>Lazy graph style APIs which can rewrite terms or apply optimisations</p> </ul></div> <p>This experimentation could be carried out as a package with a new implementation, or as patches over the existing implementation in Base.</p> <p><strong>Expected Results</strong>: An implementation of BigInt in Julia with increased performance over the current one.</p> <p><strong>Require Skills</strong>: Familiarity with extended precision numerics OR performance considerations. Familiarity either with Julia or GMP.</p> <p><strong>Mentors</strong>: <a href="https://github.com/vtjnash">Jameson Nash</a></p> <p><strong>Difficulty:</strong> Hard</p> <h3 id=special_functions ><a href="#special_functions">Special functions</a></h3> <p>As a technical computing language, Julia provides a huge number of <a href="https://en.wikipedia.org/wiki/Special_functions">special functions</a>, both in Base as well as packages such as <a href="https://github.com/JuliaStats/StatsFuns.jl">StatsFuns.jl</a>. At the moment, many of these are implemented in external libraries such as <a href="https://github.com/JuliaLang/Rmath-julia">Rmath</a> and <a href="https://github.com/JuliaLang/openspecfun">openspecfun</a>. This project would involve implementing these functions in native Julia &#40;possibly utilising the work in <a href="https://github.com/nolta/SpecialFunctions.jl">SpecialFunctions.jl</a>&#41;, seeking out opportunities for possible improvements along the way, such as supporting <code>Float32</code> and <code>BigFloat</code>, exploiting fused multiply-add operations, and improving errors and boundary cases.</p> <p><strong>Recommended Skills</strong>: A strong understanding of calculus.</p> <p><strong>Expected Results</strong>: New and faster methods for evaluating properties of special functions.</p> <p><strong>Mentors:</strong> <a href="https://github.com/stevengj">Steven Johnson</a>. Ask on Discourse or on slack</p> <h3 id=a_julia-native_ccsa_optimization_algorithm ><a href="#a_julia-native_ccsa_optimization_algorithm">A Julia-native CCSA optimization algorithm</a></h3> <p>The CCSA algorithm by <a href="https://epubs.siam.org/doi/10.1137/S1052623499362822">Svanberg &#40;2001&#41;</a> is a <a href="https://en.wikipedia.org/wiki/Nonlinear_programming">nonlinear programming algorithm</a> widely used in <a href="https://en.wikipedia.org/wiki/Topology_optimization">topology optimization</a> and for other large-scale optimization problems: it is a robust algorithm that can handle arbitrary nonlinear inequality constraints and huge numbers of degrees of freedom. Moreover, the relative simplicity of the algorithm makes it possible to easily incorporate sparsity in the Jacobian matrix &#40;for handling huge numbers of constraints&#41;, approximate-Hessian preconditioners, and as special-case optimizations for affine terms in the objective or constraints. However, currently it is only available in Julia via the <a href="https://github.com/JuliaOpt/NLopt.jl">NLopt.jl</a> interface to an external C implementation, which greatly limits its flexibility.</p> <p><strong>Recommended Skills</strong>: Experience with nonlinear optimization algorithms and understanding of <a href="https://en.wikipedia.org/wiki/Duality_&#40;optimization&#41;">Lagrange duality</a>, familiarity with sparse matrices and other Julia data structures.</p> <p><strong>Expected Results</strong>: A package implementing a native-Julia CCSA algorithm.</p> <p><strong>Mentors:</strong> <a href="https://github.com/stevengj">Steven Johnson</a>.</p> <h1 id=plutojl_projects ><a href="#plutojl_projects">Pluto.jl projects</a></h1> <h2 id=pluto_as_a_vs_code_notebook ><a href="#pluto_as_a_vs_code_notebook">Pluto as a VS Code notebook</a></h2> <p>VS Code is an extensible editor, and one of its most recent features is a notebook GUI, with a corresponding <a href="https://code.visualstudio.com/api/extension-guides/notebook">Notebook API</a>, allowing extension developers to write their own <em>notebook backend</em>. We want to combine two popular Julia IDEs: VS Code and Pluto.jl, and use it to provide a mature editing and debugging experience combined with Pluto&#39;s reactivity.</p> <p><strong>Expected Results:</strong> Reactive notebook built on top of VSCode&#39;s notebook API.</p> <p><strong>Recommended skills:</strong> JavaScript/TypeScript, some Julia experience</p> <p><strong>Mentors:</strong> <a href="https://github.com/pfitzseb">Sebastian Pfitzner</a> &#40;core maintainer of julia-vscode&#41;, <a href="https://github.com/fonsp">Fons van der Plas</a> &#40;core maintainer of Pluto.jl&#41; and friends</p> <p><em>Also see the other <a href="https://julialang.org/jsoc/gsoc/vscode/">VS Code projects</a>&#33;</em></p> <h2 id=macro_support ><a href="#macro_support">Macro support</a></h2> <p><a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#man-macros">Macros</a> are a core feature of Julia, and many important packages &#40;Flux, JuMP, DiffEq, …&#41; use them in creative ways. Pluto&#39;s reactivity is based on <em>syntax analysis</em> to find the assigned and referenced variables of each cell. This powers not just reactive evaluation, but also Pluto&#39;s global scope management, and <code>@bind</code> interactivity. &#40;See the <a href="https://www.youtube.com/watch?v&#61;IAF8DjrQSSk">JuliaCon presentation</a> for more info.&#41;</p> <p>Macros can assign to a variable without Pluto detecting it as such. For example, <code>@variables x y</code> from <a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a> <em>assigns</em> to variables <code>x</code> and <code>y</code>, while Pluto thinks that <code>x</code> and <code>y</code> were referenced. Your project is to <strong>add macro support to Pluto</strong>. Julia has the built-in ability to &#39;expand&#39; macros on demand, but integrating this into Pluto&#39;s reactive runtime remains a significant algorithm design problem. More info in <a href="https://github.com/fonsp/Pluto.jl/issues/196">Pluto.jl#196</a>.</p> <p><strong>Expected Results:</strong> First objective: process macros from packages, second &#40;more difficult&#41; objective: support macros defined inside the notebook itself.</p> <p><strong>Recommended skills:</strong> Julia, you will learn about metaprogramming, algorithm design and distributed computing</p> <p><strong>Mentors:</strong> <a href="https://github.com/fonsp">Fons van der Plas</a> and fellow Pluto.jl maintainers</p> <h2 id=tools_for_education ><a href="#tools_for_education">Tools for education</a></h2> <p>Pluto&#39;s primary use case is education, and we recently started using Pluto notebooks as an &#39;interactive textbook&#39;: https://computationalthinking.mit.edu/ . If you are interested in design and interactive visualization, there are lots of cool JS projects in this area. Examples include:</p> <ul> <li><p>Linking video content to dynamic content, better integration between exercise and lecture material.</p> <li><p>Experiment with playing back the edits to a notebook session, like a video, but on a scrollable page. &#40;<a href="https://www.notion.so/malyvsen/Replay-notebook-computations-8bcd4787842e40a199806ebe1c368acb">link</a>&#41;.</p> <li><p>Syntax analysis to automatically review &#39;code style&#39;</p> <li><p>Improved live check and autograding tools</p> <li><p>And so on&#33; Take a look at our <a href="https://www.notion.so/malyvsen/Pluto-jl-a9982e79b7bb4c658e6216c15a9d4cab">project board</a> and get in touch if you have further ideas: fons@plutojl.org</p> </ul> <p><strong>Expected Results:</strong> <em>One</em> of the items above&#33; When finished, your work will be used in future editions of the Computational Thinking course and more&#33;</p> <p><strong>Recommended skills:</strong> JavaScript, CSS, you can learn Julia as part of the project.</p> <p><strong>Mentors:</strong> <a href="https://github.com/fonsp">Fons van der Plas</a>, <a href="https://github.com/ctrekker">Connor Burns</a> and fellow Pluto.jl maintainers, with feedback from <a href="https://math.mit.edu/directory/profile.php?pid&#61;63">Alan Edelman</a></p> <h1 id=pythia_summer_of_code ><a href="#pythia_summer_of_code">Pythia – Summer of Code</a></h1> <h2 id=machine_learning_time_series_regression ><a href="#machine_learning_time_series_regression">Machine Learning Time Series Regression</a></h2> <p><a href="https://github.com/ababii/Pythia.jl">Pythia</a> is a package for scalable machine learning time series forecasting and nowcasting in Julia.</p> <p>The project mentors are <a href="https://ababii.github.io/">Andrii Babii</a> and <a href="https://www.turing.ac.uk/people/researchers/sebastian-vollmer/">Sebastian Vollmer</a>.</p> <h2 id=machine_learning_for_nowcasting_and_forecasting ><a href="#machine_learning_for_nowcasting_and_forecasting">Machine learning for nowcasting and forecasting</a></h2> <p>This project involves developing scalable machine learning time series regressions for nowcasting and forecasting. Nowcasting in economics is the prediction of the present, the very near future, and the very recent past state of an economic indicator. The term is a contraction of &quot;now&quot; and &quot;forecasting&quot; and originates in meteorology. </p> <p>The objective of this project is to introduce scalable regression-based nowcasting and forecasting methodologies that demonstrated the empirical success in data-rich environment recently. Examples of existing popular packages for regression-based nowcasting on other platforms include the &quot;MIDAS Matlab Toolbox&quot;, as well as the &#39;midasr&#39; and &#39;midasml&#39; packages in R. The starting point for this project is porting the &#39;midasml&#39; package from R to Julia. Currently Pythia has the sparse-group LASSO regression functionality for forecasting. </p> <p>The following functions are of interest: in-sample and out-of sample forecasts/nowcasts, regularized MIDAS with Legendre polynomials, visualization of nowcasts, AIC/BIC and time series cross-validation tuning, forecast evaluation, pooled and fixed effects panel data regressions for forecasting and nowcasting, HAC-based inference for sparse-group LASSO, high-dimensional Granger causality tests. Other widely used existing functions from R/Python/Matlab are also of interest.</p> <p><strong>Recommended skills:</strong> Graduate-level knowledge of time series analysis, machine learning, and optimization is helpful.</p> <p><strong>Expected output:</strong> The student is expected to produce code, documentation, visualization, and real-data examples.</p> <p><strong>References:</strong> Contact project mentors for references.</p> <h2 id=time_series_forecasting_at_scales ><a href="#time_series_forecasting_at_scales">Time series forecasting at scales</a></h2> <p>Modern business applications often involve forecasting hundreds of thousands of time series. Producing such a gigantic number of reliable and high-quality forecasts is computationally challenging, which limits the scope of potential methods that can be used in practice, see, e.g., the &#39;forecast&#39;, &#39;fable&#39;, or &#39;prophet&#39; packages in R. Currently, Julia lacks the scalable time series forecasting functionality and this project aims to develop the automated data-driven and scalable time series forecasting methods. </p> <p>The following functionality is of interest: forecasting intermittent demand &#40;Croston, adjusted Croston, INARMA&#41;, scalable seasonal ARIMA with covariates, loss-based forecasting &#40;gradient boosting&#41;, unsupervised time series clustering, forecast combinations, unit root tests &#40;ADF, KPSS&#41;. Other widely used existing functions from R/Python/Matlab are also of interest.</p> <p><strong>Recommended skills:</strong> Graduate-level knowledge of time series analysis is helpful.</p> <p><strong>Expected output:</strong> The student is expected to produce code, documentation, visualization, and real-data examples.</p> <p><strong>References:</strong> Contact project mentors for references.</p> <h1 id=scientific_machine_learning_sciml_projects ><a href="#scientific_machine_learning_sciml_projects">Scientific Machine Learning &#40;SciML&#41; Projects</a></h1> <p>These projects are hosted by the <a href="https://sciml.ai/">SciML Open Source Scientific Machine Learning Software Organzation</a>.</p> <h3 id=physics-informed_neural_networks_pinns_and_solving_differential_equations_with_deep_learning ><a href="#physics-informed_neural_networks_pinns_and_solving_differential_equations_with_deep_learning">Physics-Informed Neural Networks &#40;PINNs&#41; and Solving Differential Equations with Deep Learning</a></h3> <p>Neural networks can be used as a method for efficiently solving difficult partial differential equations. Recently this strategy has been dubbed <a href="https://www.sciencedirect.com/science/article/pii/S0021999118307125">physics-informed neural networks</a> and has seen a resurgence because of its efficiency advantages over classical deep learning. Efficient implementations from recent papers are being explored as part of the <a href="https://github.com/SciML/NeuralNetDiffEq.jl">NeuralNetDiffEq.jl</a> package. The <a href="https://github.com/SciML/NeuralNetDiffEq.jl/issues">issue tracker</a> contains links to papers which would be interesting new neural network based methods to implement and benchmark against classical techniques. Project work in this area includes:</p> <ul> <li><p><a href="https://github.com/SciML/NeuralNetDiffEq.jl/issues/71">Improved training strategies</a> for PINNs.</p> <li><p>Implementing new neural architectures that impose physical constraints like <a href="https://arxiv.org/pdf/2002.00021.pdf">divergence-free criteria</a>.</p> <li><p>Demonstrating large-scale problems solved by PINN training.</p> <li><p>Improving the speed and parallelization of PINN training routines.</p> </ul> <p>This project is good for both software engineers interested in the field of scientific machine learning and those students who are interested in perusing graduate research in the field.</p> <p><strong>Recommended Skills</strong>: Background knowledge in numerical analysis and machine learning.</p> <p><strong>Expected Results</strong>: New neural network based solver methods.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a></p> <h3 id=improvements_to_neural_and_universal_differential_equations ><a href="#improvements_to_neural_and_universal_differential_equations">Improvements to Neural and Universal Differential Equations</a></h3> <p><a href="https://arxiv.org/abs/1806.07366">Neural ordinary differential equations</a> have been shown to be a way to use machine learning to learn differential equation models. Further improvements to the methodology, like <a href="https://arxiv.org/abs/2001.04385">universal differential equations</a> have incorporated physical and biological knowledge into the system in order to make it a data and compute efficient learning method. However, there are many computational aspects left to explore. The purpose of this project is to enhance the universal differential equation approximation abilities of <a href="https://github.com/SciML/DiffEqFlux.jl">DiffEqFlux.jl</a>, adding features like:</p> <ul> <li><p>Improved adjoints for DAEs and SDEs</p> <li><p><a href="https://github.com/SciML/DiffEqFlux.jl/issues/173">Non-neural network universal approximators</a></p> <li><p>Various <a href="https://github.com/SciML/DiffEqFlux.jl/issues/133">improvements to</a> <a href="https://github.com/SciML/DiffEqFlux.jl/issues/118">minibatching</a></p> <li><p>Support for <a href="https://github.com/SciML/DiffEqFlux.jl/issues/48">second order ODEs &#40;i.e. symplectic integrators&#41;</a></p> <li><p><a href="https://github.com/SciML/DiffEqFlux.jl/issues/46">Continuous normalizing flows</a> and <a href="https://github.com/SciML/DiffEqFlux.jl/issues/47">FFJORD</a></p> </ul> <p>See the <a href="https://github.com/SciML/DiffEqFlux.jl/issues">DiffEqFlux.jl issue tracker</a> for full details.</p> <p>This project is good for both software engineers interested in the field of scientific machine learning and those students who are interested in perusing graduate research in the field.</p> <p><strong>Recommended Skills</strong>: Background knowledge in numerical analysis and machine learning.</p> <p><strong>Expected Results</strong>: New and improved methods for neural and universal differential equations.</p> <h3 id=accelerating_optimization_via_machine_learning_with_surrogate_models ><a href="#accelerating_optimization_via_machine_learning_with_surrogate_models">Accelerating optimization via machine learning with surrogate models</a></h3> <p>In many cases, when attempting to optimize a function <code>f&#40;p&#41;</code> each calculation of <code>f</code> is very expensive. For example, evaluating <code>f</code> may require solving a PDE or other applications of complex linear algebra. Thus, instead of always directly evaluating <code>f</code>, one can develop a surrogate model <code>g</code> which is approximately <code>f</code> by training on previous data collected from <code>f</code> evaluations. This technique of using a trained surrogate in place of the real function is called surrogate optimization and mixes techniques from machine learning to accelerate optimization.</p> <p>Advanced techniques <a href="https://www.cambridge.org/core/journals/acta-numerica/article/kernel-techniques-from-machine-learning-to-meshless-methods/00686923110F799A1537C4F02BBAAE8E">utilize radial basis functions</a> and Gaussian processes in order to interpolate to new parameters to estimate <code>f</code> in areas which have not been sampled. <a href="http&#37;3A&#37;2F&#37;2Fwww.ressources-actuarielles.net&#37;2FEXT&#37;2FISFA&#37;2F1226.nsf&#37;2F9c8e3fd4d8874d60c1257052003eced6&#37;2Fe7dc33e4da12c5a9c12576d8002e442b&#37;2F&#37;24FILE&#37;2FJones01.pdf">Adaptive training techniques</a> explore how to pick new areas to evaluate <code>f</code> to better hone in on global optima. The purpose of this project is to explore these techniques and build a package which performs surrogate optimizations.</p> <p><strong>Recommended Skills</strong>: Background knowledge of standard machine learning, statistical, or optimization techniques. Strong knowledge of numerical analysis is helpful but not required.</p> <p><strong>Expected Results</strong>: Library functions for performing surrogate optimization with tests on differential equation models.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a></p> <h3 id=parameter_estimation_for_nonlinear_dynamical_models ><a href="#parameter_estimation_for_nonlinear_dynamical_models">Parameter estimation for nonlinear dynamical models</a></h3> <p>Machine learning has become a popular tool for understanding data, but scientists typically understand the world through the lens of physical laws and their resulting dynamical models. These models are generally differential equations given by physical first principles, where the constants in the equations such as chemical reaction rates and planetary masses determine the overall dynamics. The inverse problem to simulation, known as parameter estimation, is the process of utilizing data to determine these model parameters.</p> <p>The purpose of this project is to utilize the growing array of statistical, optimization, and machine learning tools in the Julia ecosystem to build library functions that make it easy for scientists to perform this parameter estimation with the most high-powered and robust methodologies. Possible projects include improving methods for Bayesian estimation of parameters via Stan.jl and Julia-based libraries like Turing.jl, or global optimization-based approaches. Novel techniques like classifying model outcomes via support vector machines and deep neural networks can also be considered. Research and benchmarking to attempt to find the most robust methods will take place in this project. Additionally, the implementation of methods for estimating structure, such as <a href="https://www.pnas.org/content/111/52/18507">topological sensitivity analysis</a> along with performance enhancements to existing methods will be considered.</p> <p>Some work in this area can be found in <a href="https://github.com/SciML/DiffEqParamEstim.jl">DiffEqParamEstim.jl</a> and <a href="https://github.com/SciML/DiffEqBayes.jl">DiffEqBayes.jl</a>. Examples can be found <a href=" https://docs.sciml.ai/dev/analysis/parameter_estimation">in the DifferentialEquations.jl documentation</a>.</p> <p><strong>Recommended Skills</strong>: Background knowledge of standard machine learning, statistical, or optimization techniques. It&#39;s recommended but not required that one has basic knowledge of differential equations and DifferentialEquations.jl. Using the differential equation solver to get outputs from parameters can be learned on the job, but you should already be familiar &#40;but not necessarily an expert&#41; with the estimation techniques you are looking to employ.</p> <p><strong>Expected Results</strong>: Library functions for performing parameter estimation and inferring properties of differential equation solutions from parameters. Notebooks containing benchmarks determining the effectiveness of various methods and classifying when specific approaches are appropriate will be developed simultaneously.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a>, <a href="https://github.com/Vaibhavdixit02">Vaibhav Dixit</a></p> <h2 id=integration_of_fenicsjl_with_dolfin-adjoint_zygotejl_for_finite_element_scientific_machine_learning ><a href="#integration_of_fenicsjl_with_dolfin-adjoint_zygotejl_for_finite_element_scientific_machine_learning">Integration of FEniCS.jl with dolfin-adjoint &#43; Zygote.jl for Finite Element Scientific Machine Learning</a></h2> <p>Scientific machine learning requires mixing scientific computing libraries with machine learning. <a href="https://www.stochasticlifestyle.com/the-essential-tools-of-scientific-machine-learning-scientific-ml/">This blog post highlights how the tooling of Julia is fairly advanced in this field</a> compared to alternatives such as Python, but one area that has not been completely worked out is integration of automatic differentiation with partial differential equations. <a href="https://github.com/SciML/FEniCS.jl">FEniCS.jl</a> is a wrapper to the <a href="https://fenicsproject.org/">FEniCS</a> project for finite element solutions of partial differential equations. We would like to augment the Julia wrappers to allow for integration with Julia&#39;s automatic differentiation libraries like <a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a> by using <a href="http://www.dolfin-adjoint.org/en/release/">dolfin-adjoint</a>. This would require setting up this library for automatic installation for Julia users and writing adjoint passes which utilize this adjoint builder library. It would result in the first total integration between PDEs and neural networks.</p> <p><strong>Recommended Skills</strong>: A basic background in differential equations and Python. Having previous Julia knowledge is preferred but not strictly required.</p> <p><strong>Expected Results</strong>: Efficient and high-quality implementations of adjoints for Zygote.jl over FEniCS.jl functions.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a></p> <h2 id=multi-start_optimization_methods ><a href="#multi-start_optimization_methods">Multi-Start Optimization Methods</a></h2> <p>While standard machine learning can be shown to be &quot;safe&quot; for local optimization, scientific machine learning can sometimes require the use of globalizing techniques to improve the optimization process. Hybrid methods, known as multistart optimization methods, glue together a local optimization technique together with a parameter search over a large space of possible initial points. The purpose of this project would be to take a <a href="https://github.com/tpapp/MultistartOptimization.jl">MultistartOptimization.jl</a> as a starting point and create a fully featured set of multistart optimization tools for use with <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a></p> <p><strong>Recommended Skills</strong>: A basic background in optimization. Having previous Julia knowledge is preferred but not strictly required.</p> <p><strong>Expected Results</strong>: Efficient and high-quality implementations of multistart optimization methods.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a> and <a href="https://github.com/pkofod">Patrick Kofod Mogensen</a></p> <h1 id=symbolic_computation_project_ideas ><a href="#symbolic_computation_project_ideas">Symbolic computation project ideas</a></h1> <h2 id=groebner_basis_and_symbolic_root_finding ><a href="#groebner_basis_and_symbolic_root_finding">Groebner basis and Symbolic root finding</a></h2> <p>Implement solving polynomial equation systems symbolically. &#40;I.e. finding the variety of a set of polynomials&#41;. This involves first computing the groebner basis for a set of polynomials. Groebner basis computation is NP complete so it is essential that the implementation is practical. It should start by studying the literature on state-of-the art Groebner basis solvers.</p> <p><strong>Recommended Skills</strong>: Calculus and discrete mathematics. Prior knowledge of computational algebra and ring theory is preferred.</p> <p><strong>Expected Results</strong>: Working Groebner basis and rootfinding algorithms to be deployed in the Symbolics.jl package, along with documentation and tutorials.</p> <p><strong>Mentors</strong>: <a href="https://github.com/shashi">Shashi Gowda</a>, <a href="https://github.com/YingboMa">Yingbo Ma</a>, <a href="https://github.com/MasonProtter">Mason Protter</a></p> <h2 id=symbolic_integration ><a href="#symbolic_integration">Symbolic Integration</a></h2> <p>Implement the <a href="https://dspace.mit.edu/handle/1721.1/11997">heuristic approach to symbolic integration</a>. Then hook into a repository of rules such as <a href="https://rulebasedintegration.org/">RUMI</a></p> <p><strong>Recommended Skills</strong>: Calculus</p> <p><strong>Expected Results</strong>: A working implementation of symbolic integration in the Symbolics.jl library, along with documentation and tutorials demonstrating its use in scientific disciplines.</p> <p><strong>Mentors</strong>: <a href="https://github.com/shashi">Shashi Gowda</a>, <a href="https://github.com/YingboMa">Yingbo Ma</a>, <a href="https://github.com/MasonProtter">Mason Protter</a></p> <h1 id=tabular_data_summer_of_code ><a href="#tabular_data_summer_of_code">Tabular Data – Summer of Code</a></h1> <h2 id=implement_flashfill_in_julia ><a href="#implement_flashfill_in_julia">Implement Flashfill in Julia </a></h2> <p><strong>Difficulty</strong>: Medium</p> <p><em>FlashFill</em> is mechanism for creating data manipulation pipelines using programming by example &#40;PBE&#41;. As an example see this <a href="https://support.microsoft.com/en-us/office/using-flash-fill-in-excel-3f9bcf1e-db93-4890-94a0-1578341f73f7">implementation in Microsoft Excel</a>. We want a version of Flashfill that can work against Julia tabular data structures, such as DataFrames and Tables. </p> <p><strong>Resources</strong>:</p> <div class=tight-list ><ul> <li><p>A <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/04/pldi16-tutorial.pptx">presentation</a> by Sumit Gulwani of Microsoft Research</p> <li><p>A <a href="https://youtu.be/X1YXge3C8RI">video</a></p> <li><p><a href="https://www.microsoft.com/en-us/research/group/prose/">MSR Prose research group</a></p> <li><p><a href="https://www.microsoft.com/en-us/research/group/prose/#&#33;publications">Papers</a></p> </ul></div> <p><strong>Recommended Skills</strong>: Compiler techniques, DSL generation, Program synthesis</p> <p><strong>Expected Output</strong>: A practical flashfill implementation that can be used on any tablular data structure in Julia</p> <p><strong>Mentors</strong>: <a href="https://github.com/aviks/">Avik Sengupta</a></p> <h2 id=parquetjl_enhancements ><a href="#parquetjl_enhancements">Parquet.jl enhancements</a></h2> <p><strong>Difficulty</strong>: Medium</p> <p><a href="https://parquet.apache.org/">Apache Parquet</a> is a binary data format for tabular data. It has features for compression and memory-mapping of datasets on disk. A decent implementation of Parquet in Julia is likely to be highly performant. It will be useful as a standard format for distributing tabular data in a binary format. There exists a Parquet.jl package that has a Parquet reader and a writer. It currently conforms to the Julia Tabular file IO interface at a very basic level. It needs more work to add support for critical elements that would make Parquet.jl usable for fast large scale parallel data processing. One or more of the following goals can be targeted:</p> <div class=tight-list ><ul> <li><p>Lazy loading and support for out-of-core processing, with Arrow.jl and Tables.jl integration. Improved usability and performace of Parquet reader and writer for large files.</p> <li><p>Reading from and writing data on to cloud data stores, including support for partitioned data.</p> <li><p>Support for missing data types and encodings making the Julia implementation fully featured.</p> </ul></div> <p><strong>Resources:</strong></p> <div class=tight-list ><ul> <li><p>The <a href="https://parquet.apache.org/documentation/latest/">Parquet</a> file format &#40;also are many articles and talks on the Parquet storage format on the internet&#41;</p> <li><p><a href="https://quinnj.home.blog/2019/07/21/a-tour-of-the-data-ecosystem-in-julia/">A tour of the data ecosystem in Julia</a></p> <li><p><a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a></p> <li><p><a href="https://github.com/JuliaData/Arrow.jl">Arrow.jl</a></p> </ul></div> <p><strong>Recommended skills:</strong> Good knowledge of Julia language, Julia data stack and writing performant Julia code.</p> <p><strong>Expected Results:</strong> Depends on the specific projects we would agree on.</p> <p><strong>Mentors:</strong> <a href="https://github.com/shashi">Shashi Gowda</a>, <a href="https://github.com/tanmaykm">Tanmay Mohapatra</a></p> <h1 id=turing_projects_summer_of_code ><a href="#turing_projects_summer_of_code">Turing Projects – Summer of Code</a></h1> <p><a href="https://turing.ml/">Turing</a> is a universal probabilistic programming language embedded in Julia. Turing allows the user to write models in standard Julia syntax, and provide a wide range of sampling-based inference methods for solving problems across probabilistic machine learning, Bayesian statistics and data science etc. Since Turing is implemented in pure Julia code, its compiler and inference methods are amenable to hacking: new model families and inference methods can be easily added. Below is a list of ideas for potential projects, though you are welcome to propose your own to the Turing team.</p> <p>If you are interested in exploring any of these projects, please reach out to the listed project mentors. You can find their contact information at <a href="https://turing.ml/stable/team">turing.ml/team</a>.</p> <h2 id=mcmcchains_improvements ><a href="#mcmcchains_improvements">MCMCChains improvements</a></h2> <p><strong>Mentors</strong>: Cameron Pfiffer, Hong Ge</p> <p><strong>Project difficulty</strong>: Easy</p> <p><strong>Description</strong>: MCMCChains is a key component of the Turing.jl ecosystem. It is the package that determines how to analyze and store MCMC samples provided by packages like Turing. It&#39;s also used outside of Turing.</p> <p>For this project, a student might improve the performance of the various statistical functions provided by MCMCChains, changing the back end to use a data storage format that maintains the shape of parameter samples, or improve the general plotting functionality of the package.</p> <p>There&#39;s lots of fun little things to do for MCMCChains. Check out this <a href="https://github.com/TuringLang/MCMCChains.jl/issues/246">meta-issue</a> for more details and dicussions.</p> <h2 id=particle_filtering_methods ><a href="#particle_filtering_methods">Particle filtering methods</a></h2> <p><strong>Mentors</strong>: Hong Ge, Cameron Pfiffer</p> <p><strong>Project difficulty</strong>: Medium</p> <p><strong>Description</strong>: Turing&#39;s support for particle sampling methods is slowing being improved with the addition of <a href="https://github.com/TuringLang/AdvancedPS.jl">AdvancedPS.jl</a>. If you&#39;re interested in implementing or improving particle sampling methods, this is a great project for you&#33;</p> <h2 id=nested_sampling ><a href="#nested_sampling">Nested Sampling</a></h2> <p><strong>Mentors</strong>: Miles Lucas, Cameron Pfiffer, Hong Ge</p> <p><strong>Project difficulty</strong>: Hard</p> <p><strong>Description</strong>: <a href="https://github.com/TuringLang/NestedSamplers.jl">NestedSamplers.jl</a> is an excellent package which implements nested sampling methods. As of yet, it is not connected to Turing.jl. For this project, a student would connect the NestedSamplers.jl library to Turing.jl.</p> <h2 id=gpu_acceleration ><a href="#gpu_acceleration">GPU acceleration</a></h2> <p><strong>Mentors</strong>: Mohamed Tarek, Hong Ge, Kai Xu, Tor Fjelde</p> <p><strong>Project difficulty</strong>: Medium</p> <p><strong>Description</strong>: Turing&#39;s native GPU support is limited in that the Metropolis-Hastings and HMC samplers do not implement GPU sampling methods. This can and should be done – GPU methods are awesome&#33; If you are interested with working on parallelism and GPUs, this project is for you.</p> <p>Students will work with the code at <a href="https://github.com/TuringLang/AdvancedMH.jl">AdvancedMH</a> or <a href="https://github.com/TuringLang/AdvancedHMC.jl">AdvancedHMC</a>, depending on their interests.</p> <h2 id=documentation_and_tutorial_improvements ><a href="#documentation_and_tutorial_improvements">Documentation and tutorial improvements</a></h2> <p><strong>Mentors</strong>: Cameron Pfiffer, Martin Trapp</p> <p><strong>Project difficulty</strong>: Easy</p> <p><strong>Description</strong>: Turing&#39;s documentation and tutorials need a bit of an overhaul. Turing has changed significantly since the last time the documentation was written, and it&#39;s beginning to show. Students would use their knowledge of probabilistic programming languages and Turing to shore-up or rewrite documentation and tutorials.</p> <h2 id=iterative_methods_for_inference_in_gaussian_processes ><a href="#iterative_methods_for_inference_in_gaussian_processes">Iterative Methods for Inference in Gaussian Processes</a></h2> <p><strong>Mentors</strong>: Will Tebbutt, S. T. John, Theo Galy-Fajou</p> <p><strong>Project difficulty</strong>: Medium</p> <p><strong>Description</strong>: There has recently been quite a bit of work on inference methods for GPs that use iterative methods rather than the Cholesky factorisation. They look quite promising, but no one has implemented any of these within the Julia GP ecosystem yet, but they should fit nicely within the AbstractGPs framework. If you&#39;re interested in improving the GP ecosystem in Julia, this project might be for you&#33;</p> <h2 id=implement_advanced_variational_gaussian_process_models ><a href="#implement_advanced_variational_gaussian_process_models">Implement advanced variational Gaussian process models</a></h2> <p><strong>Mentors</strong>: ST John, Will Tebbutt, Theo Galy-Fajou</p> <p><strong>Project difficulty</strong>: Easy to Medium</p> <p><strong>Description</strong>: Sparse variational Gaussian process models provide the flexibility to scale to large datasets, handle arbitrary &#40;non-conjugate&#41; likelihoods, and to be used as building blocks for composite models such as deep GPs. This project is about making such models more readily available within the Julia GP ecosystem - depending on your interests you can focus on making it easier for end users and providing good tutorials, or on the implementations of these models to give us the same or better performance as with established Python packages such as GPflow, integrating with Flux.jl, etc.</p> <h1 id=vs_code_projects ><a href="#vs_code_projects">VS Code projects</a></h1> <h2 id=vs_code_extension ><a href="#vs_code_extension">VS Code extension</a></h2> <p>We are generally looking for folks that want to help with the <a href="https://www.julia-vscode.org/">Julia VS Code extension</a>. We have a long list of open issues, and some of them amount to significant projects.</p> <p><strong>Required Skills</strong>: TypeScript, julia, web development.</p> <p><strong>Expected Results</strong>: Depends on the specific projects we would agree on.</p> <p><strong>Mentors</strong>: <a href="https://github.com/davidanthoff">David Anthoff</a></p> <h2 id=package_installation_ui ><a href="#package_installation_ui">Package installation UI</a></h2> <p>The VSCode extension for Julia could provide a simple way to browse available packages and view what&#39;s installed on a users system. To start with, this project could simply provide a GUI that reads in package data from a <code>Project.toml</code>/<code>Manifest.toml</code> and show some UI elements to add/remove/manage those packages.</p> <p>This could also be extended by having metadata about the package, such as a readme, github stars, activity and so on &#40;somewhat similar to the VSCode-native extension explorer&#41;.</p> <p><strong>Expected Results</strong>: A UI in VSCode for package operations.</p> <p><strong>Recommended Skills</strong>: Familiarity with TypeScript and Julia development.</p> <p><strong>Mentors</strong>: <a href="https://github.com/pfitzseb">Sebastian Pfitzner</a></p> <p><em>Also take a look at <a href="https://julialang.org/jsoc/gsoc/pluto/">Pluto - VS Code integration</a>&#33;</em></p> <h1 id=web_platform_projects_summer_of_code ><a href="#web_platform_projects_summer_of_code">Web Platform Projects – Summer of Code</a></h1> <p>Julia has early support for targeting WebAssembly and running in the web browser. Please note that this is a rapidly moving area &#40;see the <a href="https://github.com/Keno/julia-wasm">project repository</a> for a more detailed overview&#41;, so if you are interested in this work, please make sure to inform yourself of the current state and talk to us to scope out an appropriate project. The below is intended as a set of possible starting points.</p> <p>Mentor for these projects is <a href="https://github.com/Keno">Keno Fischer</a> unless otherwise stated.</p> <h2 id=code_generation_improvements_and_async_abi ><a href="#code_generation_improvements_and_async_abi">Code generation improvements and async ABI</a></h2> <p>Because Julia relies on an asynchronous task runtime and WebAssembly currently lacks native support for stack management, Julia needs to explicitly manage task stacks in the wasm heap and perform a compiler transformation to use this stack instead of the native WebAssembly stack. The overhead of this transformation directly impacts the performance of Julia on the wasm platform. Additionally, since all code Julia uses &#40;including arbitrary C/C&#43;&#43; libraries&#41; must be compiled using this transformation, it needs to cover a wide variety of inputs and be coordinated with other users having similar needs &#40;e.g. the Pyodide project to run python on the web&#41;. The project would aim to improve the quality, robustness and flexibility of this transformation.</p> <p><strong>Recommended Skills</strong>: Experience with LLVM.</p> <h2 id=wasm_threading ><a href="#wasm_threading">Wasm threading</a></h2> <p>WebAssembly is in the process of standardizing <a href="https://github.com/WebAssembly/threads">threads</a>. Simultaneously, work is ongoing to introduce a new threading runtime in julia &#40;see <a href="https://github.com/JuliaLang/julia/pull/22631">#22631</a> and replated PRs&#41;. This project would investigate enabling threading support for Julia on the WebAssembly platform, implementing runtime parallel primitives on the web assembly platform and ensuring that high level threading constructs are correctly mapped to the underlying platform. Please note that both the WebAssembly and julia threading infrastructure is still in active development and may continue to change over the duration of the project. An informed understanding of the state of these projects is a definite prerequisite for this project.</p> <p><strong>Recommended Skills</strong>: Experience with C and multi-threaded programming.</p> <h2 id=high_performance_low-level_integration_of_js_objects ><a href="#high_performance_low-level_integration_of_js_objects">High performance, Low-level integration of js objects</a></h2> <p>WebAssembly is in the process of adding <a href="https://github.com/WebAssembly/reference-types">first class references to native objects</a> to their specification. This capability should allow very high performance integration between julia and javascript objects. Since it is not possible to store references to javascript objects in regular memory, adding this capability will require several changes to the runtime system and code generation &#40;possibly including at the LLVM level&#41; in order to properly track these references and emit them either as direct references to as indirect references to the reference table.</p> <p><strong>Recommended Skills</strong>: Experience with C.</p> <h2 id=dom_integration ><a href="#dom_integration">DOM Integration</a></h2> <p>While julia now runs on the web platform, it is not yet a language that&#39;s suitable for first-class development of web applications. One of the biggest missing features is integration with and abstraction over more complicated javascript objects and APIs, in particular the DOM. Inspiration may be drawn from similar projects in <a href="https://github.com/koute/stdweb">Rust</a> or other languages.</p> <p><strong>Recommended Skills</strong>: Experience with writing libraries in Julia, experience with JavaScript Web APIs.</p> <h2 id=porting_existing_web-integration_packages_to_the_wasm_platform ><a href="#porting_existing_web-integration_packages_to_the_wasm_platform">Porting existing web-integration packages to the wasm platform</a></h2> <p>Several Julia libraries &#40;e.g. WebIO.jl, Escher.jl&#41; provide input and output capabilities for the web platform. Porting these libraries to run directly on the wasm platform would enable a number of existing UIs to automatically work on the web.</p> <p><strong>Recommended Skills</strong>: Experience with writing libraries in Julia.</p> <h2 id=iodide_notebook_integration ><a href="#iodide_notebook_integration">Iodide notebook integration</a></h2> <p>Experimental support exists for running Julia/wasm inside <a href="https://github.com/iodide-project/iodide">Iodide</a> notebooks. There are a number of possible improvements to this integration, such as improving the quality of output and allowing interactive exploration of Julia objects from the iodide frontend. In addition, iodide notebooks should have support for specifying Julia manifest files in order to allow reproducibility in the face of changing package versions.</p> <p><strong>Recommended Skills</strong>: Experience with JavaScript.</p> <h2 id=native_dependencies_for_the_web ><a href="#native_dependencies_for_the_web">Native dependencies for the web</a></h2> <p>The Julia project uses <a href="https://github.com/JuliaPackaging/BinaryBuilder.jl">BinaryBuilder</a> to provide binaries of native dependencies of julia packages. Experimental support exists to extend this support to the wasm platform, but few packages have been ported. This project would consist of attempting to port a significant fraction of the binary dependencies of the julia ecosystem to the web platform by improving the toolchain support in BinaryBuilder or &#40;if necessary&#41;, porting upstream packages to fix assumptions not applicable on the wasm platform.</p> <p><strong>Recommended Skills</strong>: Experience with building native libraries in Unix environments.</p> <h2 id=distributed_computing_with_untrusted_parties ><a href="#distributed_computing_with_untrusted_parties">Distributed computing with untrusted parties</a></h2> <p>The Distributed computing abstractions in julia provide convenient abstraction for implementing programs that span many communicating julia processes on different machines. However, the existing abstractions generally assume that all communicating processes are part of the same trust domain &#40;e.g. they allow messages to execute arbitrary code on the remote&#41;. With some of the nodes potentially running in the web browser &#40;or multiple browser nodes being part of the same distributed computing cluster via WebRPC&#41;, this assumption no longer holds true and new interfaces need to be designed to support multiple trust domains without overly restricting usability.</p> <p><strong>Recommended Skills</strong>: Experience with distributed computing and writing libraries in Julia.</p> <h2 id=deployment ><a href="#deployment">Deployment</a></h2> <p>Currently supported use cases for julia on the web platform are primarily geared towards providing interactive environments to support exploration of the full language. Of course, this leads to significantly larger binaries than would be required for using Julia as part of a production deployment. By disabling dynamic language features &#40;e.g. eval&#41; one could generate small binaries suitable for deployment. Some progress towards this exists in packages like <a href="https://github.com/JuliaLang/PackageCompiler.jl">PackageCompiler.jl</a>, though significant work remains to be done.</p> <p><strong>Recommended Skills</strong>: Interest in or experience with Julia internals.</p> </div><br><br> <script src="/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script> <footer class="container-fluid footer-copy"> <div class=container > <div class="row footrow"> <ul> <li><a href="/project">About</a> <li><a href="/about/help">Get Help</a> <li><a href="/blog/2019/02/julia-entities/">Governance</a> <li><a href="/research/#publications">Publications</a> <li><a href="/research/#sponsors">Sponsors</a> </ul> <ul> <li><a href="/downloads/">Downloads</a> <li><a href="/downloads/">All Releases</a> <li><a href="https://github.com/JuliaLang/julia">Source Code</a> <li><a href="/downloads/#current_stable_release">Current Stable Release</a> <li><a href="/downloads/#long_term_support_release">Longterm Support Release</a> <li><a href="https://status.julialang.org/">PkgServer Status</a> </ul> <ul> <li><a href="https://docs.julialang.org/en/v1/">Documentation</a> <li><a href="https://juliaacademy.com">JuliaAcademy</a> <li><a href="https://www.youtube.com/user/JuliaLanguage">YouTube</a> <li><a href="/learning/getting-started/">Getting Started</a> <li><a href="https://docs.julialang.org/en/v1/manual/faq/">FAQ</a> <li><a href="/learning/books">Books</a> </ul> <ul> <li><a href="/community/">Community</a> <li><a href="/community/standards/">Code of Conduct</a> <li><a href="/diversity/">Diversity</a> <li><a href="https://juliacon.org">JuliaCon</a> <li><a href="/community/#julia_user_and_developer_survey">User/Developer Survey</a> <li><a href="/shop/">Shop Merchandise</a> </ul> <ul> <li><a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">Contributing</a> <li><a href="https://github.com/JuliaLang/julia/issues">Issue Tracker</a> <li><a href="https://github.com/JuliaLang/julia/security/policy">Report a Security Issue</a> <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22help+wanted%22">Help Wanted Issues</a> <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22good+first+issue%22+">Good First Issue</a> <li><a href="https://docs.julialang.org/en/v1/devdocs/reflection/">Dev Docs</a> </ul> </div> <div id=footer-bottom  class=row > <div class="col-md-10 py-2"> <p>Built with <a href="https://franklinjl.org">Franklin.jl</a> and the <a href="https://julialang.org">Julia Programming Language</a>. We thank <a href="https://www.fastly.com">Fastly</a> for their generous infrastructure support.</p> <p>©2021 JuliaLang.org <a href="https://github.com/JuliaLang/www.julialang.org/graphs/contributors">contributors</a>. The content on this website is made available under the <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT license</a>. </div> <div class="col-md-2 py-2"> <span class=float-sm-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a> </span> </div> </div> </div> </footer> <script src="/libs/jquery/jquery.min.js"></script> <script src="/libs/bootstrap/bootstrap.min.js"></script>