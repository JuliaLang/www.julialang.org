<!doctype html> <html lang=en > <meta charset=utf-8 > <meta name=viewport  content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv=x-ua-compatible  content="ie=edge"> <meta name=author  content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al."> <meta name=description  content="The official website for the Julia Language. Julia is a language that is fast, dynamic, easy to use, and open source. Click here to learn more."> <meta name=robots  content="max-image-preview:large"> <meta name="twitter:site:id" content=1237720952 > <meta name=google-site-verification  content=9VDSjBtchQj6PQYIVwugTPY7pVCfLYgvkXiRHjc_Bzw  /> <link rel=icon  href="/assets/infra/julia.ico"> <link rel=stylesheet  href="/libs/bootstrap/bootstrap.min.css"> <link rel=stylesheet  href="/css/app.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/fonts.css"> <link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel=stylesheet > <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel=stylesheet > <script async defer src="/libs/buttons.js"></script> <script type="application/javascript"> var doNotTrack = false; if (!doNotTrack) { window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-28835595-1', 'auto', { 'anonymize_ip': true }); ga('send', 'pageview', { 'anonymize_ip': true }); } </script> <script async src='https://www.google-analytics.com/analytics.js'></script> <title>View all GSoC/JSoC Projects</title> <meta property="og:title" content="View all GSoC/JSoC Projects"> <meta property="og:description" content=""> <meta property="og:image" content="/assets/images/julia-open-graph.png"> <div class="container py-3 py-lg-0"> <nav class="navbar navbar-expand-lg navbar-light bg-light" id=main-menu > <a class=navbar-brand  href="/"> <img src="/assets/infra/logo.svg" alt="JuliaLang Logo"> </a> <button class="navbar-toggler ml-auto hidden-sm-up float-xs-left" type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mx-auto"> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/downloads/">Download</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="https://docs.julialang.org">Documentation</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/blog/">Blog</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/community/">Community</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/learning/">Learn</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/research/">Research</a> <li class="nav-item active flex-md-fill text-md-center"> <a class=nav-link  href="/jsoc/">JSoC</a> </ul> <span class=navbar-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a> </span> </div> </nav> </div> <br><br> <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/jsoc/allprojects.md" title="Edit this page on GitHub" class=edit-float > </a> <div class="container main"><h2 id=view_all_gsocjsoc_projects ><a href="#view_all_gsocjsoc_projects">View all GSoC/JSoC Projects</a></h2> <p>This page is designed to improve discoverability of projects. You can, for example, search this page for specific keywords and find all of the relevant projects.</p> <h2 id=projects ><a href="#projects">Projects</a></h2> <h1 id=mljjl_projects_summer_of_code ><a href="#mljjl_projects_summer_of_code">MLJ.jl Projects – Summer of Code</a></h1> <p><a href="https://github.com/alan-turing-institute/MLJ.jl">MLJ</a> is a machine learning framework for Julia aiming to provide a convenient way to use and combine a multitude of tools and models available in the Julia ML/Stats ecosystem.</p> <h3 id=list_of_projects ><a href="#list_of_projects">List of projects</a></h3> <p>MLJ is released under the MIT license and sponsored by the Alan Turing Institute.</p> <div class=franklin-toc ><ol><li><a href="#view_all_gsocjsoc_projects">View all GSoC/JSoC Projects</a><li><a href="#projects">Projects</a><ol><li><a href="#list_of_projects">List of projects</a></ol><li><a href="#machine_learning_in_predictive_survival_analysis">Machine Learning in Predictive Survival Analysis</a><ol><li><a href="#description">Description</a><li><a href="#prerequisites">Prerequisites</a><li><a href="#your_contribution">Your contribution</a><li><a href="#references">References</a></ol><li><a href="#feature_transformations">Feature transformations</a><ol><li><a href="#description__2">Description</a><li><a href="#prerequisites__2">Prerequisites</a><li><a href="#your_contribution__2">Your contribution</a><li><a href="#references__2">References</a></ol><li><a href="#time_series_forecasting_at_scale_-_speed_up_via_julia">Time series forecasting at scale - speed up via Julia</a><ol><li><a href="#prerequisites__3">Prerequisites</a><li><a href="#your_contribution__3">Your contribution</a><li><a href="#references__3">References</a></ol><li><a href="#interpretable_machine_learning_in_julia">Interpretable Machine Learning in Julia</a><ol><li><a href="#description__3">Description</a><li><a href="#prerequisites__4">Prerequisites</a><li><a href="#your_contribution__4">Your contribution</a><li><a href="#references__4">References</a></ol><li><a href="#model_visualization_in_mlj">Model visualization in MLJ</a><ol><li><a href="#description__4">Description</a><li><a href="#prerequisites__5">Prerequisites</a><li><a href="#your_contribution__5">Your contribution</a><li><a href="#references__5">References</a></ol><li><a href="#deeper_bayesian_integration">Deeper Bayesian Integration</a><ol><li><a href="#description__5">Description</a><li><a href="#your_contributions">Your contributions</a><li><a href="#references__6">References</a><li><a href="#difficulty_medium_to_hard">Difficulty: Medium to Hard</a></ol><li><a href="#tracking_and_sharing_mlj_workflows_using_mlflow">Tracking and sharing MLJ workflows using MLFlow</a><ol><li><a href="#description__6">Description</a><li><a href="#prerequisites__6">Prerequisites</a><li><a href="#your_contribution__6">Your contribution</a><li><a href="#references__7">References</a></ol><li><a href="#speed_demons_only_need_apply">Speed demons only need apply</a><ol><li><a href="#description__7">Description</a><li><a href="#prerequisites__7">Prerequisites</a><li><a href="#your_contribution__7">Your contribution</a><li><a href="#references__8">References</a></ol><li><a href="#correcting_for_class_imbalance_in_classification_problems">Correcting for class imbalance in classification problems</a><ol><li><a href="#description__8">Description</a><li><a href="#prerequisites__8">Prerequisites</a><li><a href="#your_contribution__8">Your contribution</a><li><a href="#references__9">References</a></ol><li><a href="#improving_test_coverage_350_hours">Improving test coverage &#40;350 hours&#41;</a><li><a href="#multi-threading_improvement_projects_350_hours">Multi-threading Improvement Projects &#40;350 hours&#41;</a><li><a href="#automation_of_testing_performance_benchmarking_350_hours">Automation of testing / performance benchmarking &#40;350 hours&#41;</a><li><a href="#bringing_dftk_to_graphics-processing_units_gpus">Bringing DFTK to graphics-processing units &#40;GPUs&#41;</a><li><a href="#documenterjl">Documenter.jl</a><li><a href="#docsystem_api">Docsystem API</a><ol><li><a href="#metalheadjl_developement">Metalhead.jl Developement</a><li><a href="#fastaijl_time_series_development">FastAI.jl Time Series Development</a><li><a href="#fastaijl_text_development">FastAI.jl Text Development</a><li><a href="#differentiable_computer_vision">Differentiable Computer Vision</a><li><a href="#ferminets_generative_synthesis_for_automating_the_choice_of_neural_architectures">FermiNets: Generative Synthesis for Automating the Choice of Neural Architectures</a><li><a href="#differentiable_rendering">Differentiable Rendering</a><li><a href="#adding_graph_convolutional_layers">Adding graph convolutional layers </a><li><a href="#adding_models_and_examples">Adding models and examples</a><li><a href="#adding_graph_datasets">Adding graph datasets</a><li><a href="#supporting_heterogeneous_graphs">Supporting heterogeneous graphs</a><li><a href="#training_on_very_large_graphs">Training on very large graphs </a><li><a href="#supporting_temporal_graph_neural_networks">Supporting temporal graph neural networks</a><li><a href="#improving_performance_using_sparse_linear_algebra">Improving performance using sparse linear algebra </a></ol><li><a href="#recommended_skills">Recommended skills</a><li><a href="#mentors">Mentors </a><li><a href="#qml_and_makie_integration">QML and Makie integration</a><ol><li><a href="#expected_results">Expected results</a></ol><li><a href="#web_apps_in_makie_and_jsserve">Web apps in Makie and JSServe</a><ol><li><a href="#expected_results__2">Expected results</a></ol><li><a href="#scheduling_algorithms_for_distributed_algorithms">Scheduling algorithms for Distributed algorithms</a><li><a href="#distributed_training">Distributed Training</a><li><a href="#benchmarking_against_other_frameworks">Benchmarking against other frameworks</a><li><a href="#gpu_support_for_many_algorithms">GPU support for many algorithms</a><li><a href="#better_imageio_supports_open_ended">Better ImageIO supports &#40;open ended&#41;</a><li><a href="#exif_viewer">EXIF viewer</a><li><a href="#better_qr_code_support_open_ended">Better QR Code support &#40;open ended&#41;</a><li><a href="#where_to_go_for_discussion_and_to_find_mentors">Where to go for discussion and to find mentors</a><li><a href="#c">C&#43;&#43;</a><ol><li><a href="#cxxwrap_stl">CxxWrap STL</a><ol><li><a href="#expected_outcome">Expected outcome</a></ol></ol><li><a href="#rust">Rust</a><li><a href="#improve_javis_performance">Improve Javis Performance</a><li><a href="#building_novel_animation_abilities_for_javis">Building Novel Animation Abilities for Javis</a><li><a href="#agentsjl">Agents.jl</a><li><a href="#dynamicalsystemsjl">DynamicalSystems.jl</a><li><a href="#midification_of_music_from_wave_files">MIDIfication of music from wave files</a><li><a href="#efficient_low-dimensional_symbolic-numeric_set_computations">Efficient low-dimensional symbolic-numeric set computations</a><li><a href="#reachability_with_sparse_polynomial_zonotopes">Reachability with sparse polynomial zonotopes</a><li><a href="#improving_the_hybrid_systems_reachability_api">Improving the hybrid systems reachability API</a><li><a href="#panel_data_analysis">Panel data analysis</a><ol><li><a href="#description__9">Description</a><li><a href="#prerequisites__9">Prerequisites</a><li><a href="#your_contribution__9">Your contribution</a><li><a href="#references__10">References</a></ol><li><a href="#crraojl">CRRao.jl</a><ol><li><a href="#description__10">Description</a><li><a href="#prerequisites__10">Prerequisites</a><li><a href="#your_contribution__10">Your contribution</a></ol><li><a href="#juliastats_improvements">JuliaStats Improvements </a><ol><li><a href="#description__11">Description</a><li><a href="#prerequisites__11">Prerequisites</a><li><a href="#your_contribution__11">Your contribution</a></ol><li><a href="#smoothing_non-linear_continuous_time_systems">Smoothing non-linear continuous time systems</a><li><a href="#developing_a_julia_pluginfrontend_allowing_the_application_of_a_custom_compiler_pipeline">Developing a Julia plugin/frontend allowing the application of a custom compiler pipeline</a><li><a href="#developing_loop_models_350_hours">Developing Loop Models &#40;350 hours&#41;:</a><ol><li><a href="#cuda_hacking">CUDA Hacking</a><ol><li><a href="#expected_outcomes">Expected Outcomes</a></ol><li><a href="#reinforcement_learning_environments">Reinforcement Learning Environments</a><ol><li><a href="#expected_outcome__2">Expected outcome</a></ol><li><a href="#reinforcement_learning_algorithms">Reinforcement Learning Algorithms</a><ol><li><a href="#expected_outcomes__2">Expected Outcomes</a></ol><li><a href="#alphazerojl">AlphaZero.jl</a><ol><li><a href="#expected_outcomes__3">Expected Outcomes</a></ol></ol><li><a href="#numerical_linear_algebra">Numerical Linear Algebra</a><ol><li><a href="#matrix_functions">Matrix functions</a></ol><li><a href="#better_bignums_integration">Better Bignums Integration</a><ol><li><a href="#special_functions">Special functions</a><li><a href="#a_julia-native_ccsa_optimization_algorithm">A Julia-native CCSA optimization algorithm</a></ol><li><a href="#massive_parallel_factorized_bouncy_particle_sampler">Massive parallel factorized bouncy particle sampler</a><li><a href="#pluto_as_a_vs_code_notebook">Pluto as a VS Code notebook</a><li><a href="#tools_for_education">Tools for education</a><li><a href="#electron_app">Electron app</a><li><a href="#wrapping_a_rust_http_server_in_julia">Wrapping a Rust HTTP server in Julia</a><ol><li><a href="#introduction">Introduction</a><li><a href="#details">Details</a></ol><li><a href="#machine_learning_time_series_regression">Machine Learning Time Series Regression</a><li><a href="#machine_learning_for_nowcasting_and_forecasting">Machine learning for nowcasting and forecasting</a><li><a href="#time_series_forecasting_at_scales">Time series forecasting at scales</a><li><a href="#gpu_accelerated_simulator_of_clifford_circuits">GPU accelerated simulator of Clifford Circuits.</a><li><a href="#pauli_frames_for_faster_sampling">Pauli Frames for faster sampling.</a><li><a href="#a_zoo_of_quantum_error_correcting_codes">A Zoo of Quantum Error Correcting codes.</a><li><a href="#leftright_multiplications_with_small_gates">Left/Right multiplications with small gates.</a><li><a href="#symbolic_root_finding">Symbolic root finding</a><li><a href="#symbolic_integration_in_symbolicsjl">Symbolic Integration in Symbolics.jl</a><li><a href="#xla-style_optimization_from_symbolic_tracing">XLA-style optimization from symbolic tracing</a><li><a href="#automatically_improving_floating_point_accuracy_herbie">Automatically improving floating point accuracy &#40;Herbie&#41;</a><li><a href="#implement_flashfill_in_julia">Implement Flashfill in Julia </a><li><a href="#parquetjl_enhancements">Parquet.jl enhancements</a><li><a href="#statistical_transforms">Statistical transforms</a><li><a href="#utility_transforms">Utility transforms</a><li><a href="#how_to_get_started">How to get started?</a><li><a href="#machine_learning_in_topology_optimisation">Machine learning in topology optimisation</a><li><a href="#multi-material_design_representation">Multi-material design representation</a><li><a href="#optimisation_on_a_uniform_rectilinear_grid">Optimisation on a uniform rectilinear grid</a><li><a href="#adaptive_mesh_refinement_for_topology_optimisation">Adaptive mesh refinement for topology optimisation</a><li><a href="#heat_transfer_design_optimisation">Heat transfer design optimisation</a><li><a href="#more_real-world_bayesian_models_in_turing_julia">More real-world Bayesian models in Turing / Julia</a><li><a href="#improving_the_integration_between_turing_and_turings_mcmc_inference_packages">Improving the integration between Turing and Turing&#39;s MCMC inference packages</a><li><a href="#directed-graphical_model_support_for_the_abstract_probabilistic_programming_library">Directed-graphical model support for the abstract probabilistic programming library</a><li><a href="#a_modular_tape_caching_mechanism_for_reversediff">A modular tape caching mechanism for ReverseDiff</a><li><a href="#benchmarking_improving_performance_of_the_juliagaussianprocesses_libraries">Benchmarking &amp; improving performance of the JuliaGaussianProcesses libraries</a><li><a href="#iterative_methods_for_inference_in_gaussian_processes">Iterative methods for inference in Gaussian Processes</a><li><a href="#approximate_inference_methods_for_non-gaussian_likelihoods_in_gaussian_processes">Approximate inference methods for non-Gaussian likelihoods in Gaussian Processes</a><li><a href="#gpu_integration_in_the_juliagps_ecosystem">GPU integration in the JuliaGPs ecosystem</a><li><a href="#vs_code_extension">VS Code extension</a><li><a href="#package_installation_ui">Package installation UI</a><li><a href="#code_generation_improvements_and_async_abi">Code generation improvements and async ABI</a><li><a href="#wasm_threading">Wasm threading</a><li><a href="#high_performance_low-level_integration_of_js_objects">High performance, Low-level integration of js objects</a><li><a href="#dom_integration">DOM Integration</a><li><a href="#porting_existing_web-integration_packages_to_the_wasm_platform">Porting existing web-integration packages to the wasm platform</a><li><a href="#native_dependencies_for_the_web">Native dependencies for the web</a><li><a href="#distributed_computing_with_untrusted_parties">Distributed computing with untrusted parties</a><li><a href="#deployment">Deployment</a></ol></div> <h2 id=machine_learning_in_predictive_survival_analysis ><a href="#machine_learning_in_predictive_survival_analysis">Machine Learning in Predictive Survival Analysis</a></h2> <p>Implement survival analysis models for use in the MLJ machine learning platform.</p> <p><strong>Difficulty.</strong> Moderate - hard. <strong>Duration.</strong> 350 hours</p> <h3 id=description ><a href="#description">Description</a></h3> <p>Survival/time-to-event analysis is an important field of Statistics concerned with understanding the distribution of events over time. Survival analysis presents a unique challenge as we are also interested in events that do not take place, which we refer to as &#39;censoring&#39;. Survival analysis methods are important in many real-world settings, such as health care &#40;disease prognosis&#41;, finance and economics &#40;risk of default&#41;, commercial ventures &#40;customer churn&#41;, engineering &#40;component lifetime&#41;, and many more. This project aims to implement models for performing survivor analysis with the MLJ machine learning framework.</p> <p><strong>Mentors.</strong> <a href="https://sebastian.vollmer.ms">Sebastian Vollmer</a>, <a href="https://ablaom.github.io/">Anthony Blaom</a>,</p> <h3 id=prerequisites ><a href="#prerequisites">Prerequisites</a></h3> <ul> <li><p>Julia language fluency is essential.</p> <li><p>Git-workflow familiarity is strongly preferred.</p> <li><p>Some experience with survival analysis.</p> <li><p>Familiarity with MLJ&#39;s API a plus.</p> <li><p>A passing familiarity with machine learning goals and workflow is</p> </ul> <p>preferred.</p> <h3 id=your_contribution ><a href="#your_contribution">Your contribution</a></h3> <p>Specifically, you will:</p> <ul> <li><p>Familiarize yourself with the training and evaluation machine</p> </ul> <p>learning models in MLJ.</p> <ul> <li><p>Survey existing survival models in Julia.</p> <li><p>Integrate some existing classical survival models into MLJ.</p> <li><p>Develop a proof of concept for newer advanced survival analysis</p> </ul> <p>models not currently implemented in Julia.</p> <h3 id=references ><a href="#references">References</a></h3> <ul> <li><p>&#91;Kvamme, H., Borgan, Ø., &amp; Scheel, I. &#40;2019&#41;. Time-to-event</p> </ul> <p>prediction with neural networks and Cox regression. Journal of Machine Learning Research, 20&#40;129&#41;, 1--30.&#93;&#40;https://arxiv.org/abs/1907.00825&#41;</p> <ul> <li><p>&#91;Lee, C., Zame, W. R., Yoon, J., &amp; van der Schaar, M. &#40;2018&#41;.</p> </ul> <p>Deephit: A deep learning approach to survival analysis with competing risks. In Thirty-Second AAAI Conference on Artificial Intelligence.&#93;&#40;https://ojs.aaai.org/index.php/AAAI/article/view/11842/11701&#41;</p> <ul> <li><p>&#91;Katzman, J. L., Shaham, U., Cloninger, A., Bates, J., Jiang, T., &amp;</p> </ul> <p>Kluger, Y. &#40;2018&#41;. DeepSurv: personalized treatment recommender system using a Cox proportional hazards deep neural network. BMC Medical Research Methodology, 18&#40;1&#41;, 24.&#93;&#40;https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-018-0482-1&#41; &lt;https://doi.org/10.1186/s12874-018-0482-1&gt;</p> <ul> <li><p>&#91;Gensheimer, M. F., &amp; Narasimhan, B. &#40;2019&#41;. A scalable</p> </ul> <p>discrete-time survival model for neural networks. PeerJ, 7, e6257.&#93;&#40;https://peerj.com/articles/6257/&#41;</p> <ul> <li><p>&#91;Survival.jl</p> </ul> <p>Documentation&#93;&#40;https://juliastats.org/Survival.jl/latest/&#41;</p> <h2 id=feature_transformations ><a href="#feature_transformations">Feature transformations</a></h2> <p>Enhancing MLJ data-preprocessing capabilities by integrating <a href="https://github.com/JuliaML/TableTransforms.jl">TableTransforms</a> into MLJ.</p> <p><strong>Difficulty.</strong> Easy. <strong>Duration.</strong> 350 hours</p> <h3 id=description__2 ><a href="#description__2">Description</a></h3> <p>TableTransforms.jl is a Julia package heavily inspired by FeatureTranforms.jl which aims to provide feature engineering transforms which are vital in the Statistics and Machine Learning domain. This project would implement the necessary methods to integrate TableTransforms with MLJ, making them available for incorporation into sophisticated ML workflows.</p> <p><strong>Mentors.</strong> <a href="https://ablaom.github.io/">Anthony Blaom</a>.</p> <h3 id=prerequisites__2 ><a href="#prerequisites__2">Prerequisites</a></h3> <ul> <li><p>Julia language fluency is essential.</p> <li><p>Git-workflow familiarity is strongly preferred.</p> <li><p>A passing familiarity with machine learning goals and workflow</p> </ul> <p>preferred</p> <h3 id=your_contribution__2 ><a href="#your_contribution__2">Your contribution</a></h3> <ul> <li><p>Implement the MLJ model interface for transformers in TableTransforms.jl.</p> <li><p>Integrate TableTransforms pipelines with MLJ.</p> </ul> <h3 id=references__2 ><a href="#references__2">References</a></h3> <ul> <li><p><a href="https://github.com/JuliaML/TableTransforms.jl">TableTransforms</a> Github</p> </ul> <p>repository.</p> <ul> <li><p><a href="https://github.com/JuliaAI/MLJModels.jl">MLJModels</a> Github</p> </ul> <p>repository with existing MLJ transformers.</p> <ul> <li><p><a href="https://alan-turing-institute.github.io/MLJ.jl/dev/adding_models_for_general_use/">Specification of the MLJ model API</a>.</p> </ul> <h2 id=time_series_forecasting_at_scale_-_speed_up_via_julia ><a href="#time_series_forecasting_at_scale_-_speed_up_via_julia">Time series forecasting at scale - speed up via Julia</a></h2> <p>Time series are ubiquitous - stocks, sensor reading, vital signs. This projects aims at adding time series forecasting to MLJ and perform benchmark comparisons to <a href="https://github.com/alan-turing-institute/sktime">sktime</a>, <a href="https://github.com/rtavenar/tslearn">tslearn</a>, <a href="https://github.com/uea-machine-learning/tsml/">tsml</a>&#41;.</p> <p><strong>Difficulty.</strong> Moderate - hard. <strong>Duration.</strong> 350 hours.</p> <h3 id=prerequisites__3 ><a href="#prerequisites__3">Prerequisites</a></h3> <ul> <li><p>Julia language fluency essential.</p> <li><p>Git-workflow essential</p> <li><p>Some prior contact with time series forecasting</p> <li><p>HPC in julia is a desirable</p> </ul> <h3 id=your_contribution__3 ><a href="#your_contribution__3">Your contribution</a></h3> <p>MLJ is so far focused on tabular data and time series classification. This project is to add support for time series data in a modular, composable way.</p> <p>Time series are everywhere in real-world applications and there has been an increase in interest in time series frameworks recently &#40;see e.g. <a href="https://github.com/alan-turing-institute/sktime">sktime</a>, <a href="https://github.com/rtavenar/tslearn">tslearn</a>, <a href="https://github.com/uea-machine-learning/tsml/">tsml</a>&#41;.</p> <p>But there are still very few principled time-series libraries out there, so you would be working on something that could be very useful for a large number of people. To find out more, check out this <a href="http://learningsys.org/neurips19/assets/papers/sktime_ml_systems_neurips2019.pdf">paper</a> on sktime.</p> <p><strong>Mentors</strong>: <a href="https://sebastian.vollmer.ms">Sebastian Vollmer</a>, <a href="https://github.com/mloning">Markus Löning</a> &#40;sktime developer&#41;.</p> <h3 id=references__3 ><a href="#references__3">References</a></h3> <ul> <li><p><a href="https://github.com/alan-turing-institute/sktime">sktime</a></p> <li><p><a href="https://github.com/rtavenar/tslearn">tslearn</a></p> <li><p><a href="https://github.com/uea-machine-learning/tsml/">tsml</a></p> <li><p><a href="http://learningsys.org/neurips19/assets/papers/sktime_ml_systems_neurips2019.pdf">sktime paper</a></p> </ul> <h2 id=interpretable_machine_learning_in_julia ><a href="#interpretable_machine_learning_in_julia">Interpretable Machine Learning in Julia</a></h2> <p>Interpreting and explaining black box interpretation crucial to establish trust and improve performance</p> <p><strong>Difficulty.</strong> Easy - moderate. <strong>Duration.</strong> 350 hours.</p> <h3 id=description__3 ><a href="#description__3">Description</a></h3> <p>It is important to have mechanisms in place to interpret the results of machine learning models. Identify the relevant factors of a decision or scoring of a model.</p> <p>This project will implement methods for model and feature interpretability.</p> <p><strong>Mentors.</strong> <a href="https://github.com/darenasc">Diego Arenas</a>, <a href="https://sebastian.vollmer.ms">Sebastian Vollmer</a>.</p> <h3 id=prerequisites__4 ><a href="#prerequisites__4">Prerequisites</a></h3> <ul> <li><p>Julia language fluency essential.</p> <li><p>Git-workflow familiarity strongly preferred.</p> <li><p>Some prior contact with explainable AI/ML methods is desirable.</p> <li><p>A passing familiarity with machine learning goals and workflow preferred</p> </ul> <h3 id=your_contribution__4 ><a href="#your_contribution__4">Your contribution</a></h3> <p>The aim of this project is to implement multiple variants implementation algorithms such as:</p> <ul> <li><p>Implement methods to show feature importance</p> <li><p>Partial dependence plots</p> <li><p>Tree surrogate</p> <li><p>LocalModel: Local Interpretable Model-agnostic Explanations</p> <li><p>Add Dataset loaders for standard interpretability datasets.</p> <li><p>Add performance metrics for interpretability</p> <li><p>Add interpretability algorithms</p> <li><p>Glue code to SHAP package</p> </ul> <p>Specifically you will</p> <ul> <li><p>Familiarize yourself with MLJ</p> <li><p>Survey of some of the literature and existing implementations in Julia and other languages, and preparing a short summary</p> <li><p>Implement visualizations of explanations</p> <li><p>Implement use cases</p> <li><p>You will learn about the benefits and short comings of model interpretation and how to use them.</p> </ul> <h3 id=references__4 ><a href="#references__4">References</a></h3> <ul> <li><p><a href="https://christophm.github.io/interpretable-ml-book/">Interpretable Machine Learning - A Guide for Making Black Box Models Explainable by Christoph Molnalr</a></p> <li><p><a href="https://github.com/christophM/iml/">iml R package</a></p> <li><p></p> </ul> <p>Tutorials</p> <ul> <li><p><a href="https://dl.acm.org/doi/abs/10.1145/3351095.3375667">AI explainability 360: hands-on tutorial</a></p> <li><p><a href="https://mlr3book.mlr-org.com/iml.html">IML tutorial</a></p> </ul> <h2 id=model_visualization_in_mlj ><a href="#model_visualization_in_mlj">Model visualization in MLJ</a></h2> <p>Design and implement a data visualization module for MLJ.</p> <p><strong>Difficulty</strong>. Easy. <strong>Duration.</strong> 350 hours.</p> <h3 id=description__4 ><a href="#description__4">Description</a></h3> <p>Design and implement a data visualization module for MLJ to visualize numeric and categorical features &#40;histograms, boxplots, correlations, frequencies&#41;, intermediate results, and metrics generated by MLJ machines.</p> <p>Using a suitable Julia package for data visualization.</p> <p>The idea is to implement a similar resource to what <a href="https://github.com/mlr-org/mlr3viz">mlr3viz</a> does for <a href="https://mlr3.mlr-org.com">mlr3</a>.</p> <h3 id=prerequisites__5 ><a href="#prerequisites__5">Prerequisites</a></h3> <ul> <li><p>Julia language fluency essential.</p> <li><p>Git-workflow essential.</p> <li><p>Some prior work on data visualization is desirable</p> </ul> <h3 id=your_contribution__5 ><a href="#your_contribution__5">Your contribution</a></h3> <p>So far visualizing data or features in MLJ is an ad-hoc task. Defined by the user case by case. You will be implementing a standard way to visualize model performance, residuals, benchmarks and predictions for MLJ users.</p> <p>The structures and metrics will be given from the results of models or data sets used; your task will be to implement the right visualizations depending on the data type of the features.</p> <p>A relevant part of this project is to visualize the target variable against the rest of the features.</p> <p>You will enhance your visualisation skills as well as your ability to &quot;debug&quot; and understand models and their prediction visually.</p> <h3 id=references__5 ><a href="#references__5">References</a></h3> <ul> <li><p><a href="https://github.com/mlr-org/mlr3viz">mlr3viz</a></p> <li><p><a href="https://github.com/JuliaPlots/StatsPlots.jl">StatsPlots</a></p> </ul> <p><strong>Mentors</strong>: <a href="https://sebastian.vollmer.ms">Sebastian Vollmer</a>, <a href="https://github.com/darenasc">Diego Arenas</a>.</p> <h2 id=deeper_bayesian_integration ><a href="#deeper_bayesian_integration">Deeper Bayesian Integration</a></h2> <p>Bayesian methods and probabilistic supervised learning provide uncertainty quantification. This project aims increasing integration to combine Bayesian and non-Bayesian methods using Turing.</p> <p><strong>Difficulty.</strong> Difficult. <strong>Duration.</strong> 350 hours.</p> <h3 id=description__5 ><a href="#description__5">Description</a></h3> <p>As an initial step reproduce <a href="https://github.com/cscherrer/SossMLJ.jl">SOSSMLJ</a> in Turing. The bulk of the project is to implement methods that combine multiple predictive distributions.</p> <h3 id=your_contributions ><a href="#your_contributions">Your contributions</a></h3> <ul> <li><p>Interface between Turing and MLJ</p> <li><p>Comparisons of ensembling, stacking of predictive distribution</p> <li><p>reproducible benchmarks across various settings.</p> </ul> <h3 id=references__6 ><a href="#references__6">References</a></h3> <p><a href="http://www.stat.columbia.edu/~gelman/research/published/stacking_paper_discussion_rejoinder.pdf">Bayesian Stacking</a> <a href="https://github.com/alan-turing-institute/skpro/blob/master/README.md">SKpro</a></p> <h3 id=difficulty_medium_to_hard ><a href="#difficulty_medium_to_hard">Difficulty: Medium to Hard</a></h3> <p><strong>Mentors</strong>: <a href="https://github.com/yebai">Hong Ge</a> <a href="https://sebastian.vollmer.ms">Sebastian Vollmer</a></p> <h2 id=tracking_and_sharing_mlj_workflows_using_mlflow ><a href="#tracking_and_sharing_mlj_workflows_using_mlflow">Tracking and sharing MLJ workflows using MLFlow</a></h2> <p>Help data scientists using MLJ track and share their machine learning experiments using <a href="https://mlflow.org">MLFlow</a>.</p> <p><strong>Difficulty.</strong> Moderate. <strong>Duration.</strong> 350 hours.</p> <h3 id=description__6 ><a href="#description__6">Description</a></h3> <p>MLFlow is an open source platform for the machine learning life cycle. It allows the data scientist to upload experiment metadata and outputs to the platform for reproducing and sharing purposes. This project aims to integrate the MLJ machine learning platform with MLFlow.</p> <h3 id=prerequisites__6 ><a href="#prerequisites__6">Prerequisites</a></h3> <ul> <li><p>Julia language fluency essential.</p> <li><p>Git-workflow familiarity strongly preferred.</p> <li><p>General familiarity with data science workflows</p> </ul> <h3 id=your_contribution__6 ><a href="#your_contribution__6">Your contribution</a></h3> <ul> <li><p>You will familiarize yourself with MLJ, MLFlow and MLFlowClient.jl client APIs.</p> <li><p>Implement functionality to upload to MLFlow machine learning model hyper-parameters, performance evaluations, and artifacts encapsulating the trained model. </p> <li><p>Implement functionality allowing for the live tracking of learning for iterative models, such as neural networks, by hooking in to <a href="https://github.com/JuliaAI/MLJIteration.jl">MLJIteration.jl</a>.</p> </ul> <h3 id=references__7 ><a href="#references__7">References</a></h3> <ul> <li><p><a href="https://mlflow.org">MLFlow</a> website.</p> <li><p><a href="https://mlflow.org/docs/latest/rest-api.html">MLFlow REST API</a>.</p> <li><p><a href="https://github.com/JuliaAI/MLFlowClient.jl">MLFlowClient.jl</a></p> <li><p><a href="https://github.com/JuliaAI/MLJIteration.jl">MLJIteration.jl</a></p> </ul> <p><strong>Mentors.</strong> <a href="https://github.com/deyandyankov">Deyan Dyankov</a>, <a href="https://ablaom.github.io/">Anthony Blaom</a>, <a href="https://github.com/darenasc">Diego Arenas</a>.</p> <h2 id=speed_demons_only_need_apply ><a href="#speed_demons_only_need_apply">Speed demons only need apply</a></h2> <p>Diagnose and exploit opportunities for speeding up common MLJ workflows.</p> <p><strong>Difficulty.</strong> Moderate. <strong>Duration.</strong> 350 hours.</p> <h3 id=description__7 ><a href="#description__7">Description</a></h3> <p>In addition to investigating a number of known performance bottlenecks, you will have some free reign in this to identify opportunities to speed up common MLJ workflows, as well as making better use of memory resources.</p> <h3 id=prerequisites__7 ><a href="#prerequisites__7">Prerequisites</a></h3> <ul> <li><p>Julia language fluency essential.</p> <li><p>Experience with multi-threading and multi-processor computing essential, preferably in Julia.</p> <li><p>Git-workflow familiarity strongly preferred.</p> <li><p>Familiarity with machine learning goals and workflow preferred</p> </ul> <h3 id=your_contribution__7 ><a href="#your_contribution__7">Your contribution</a></h3> <p>In this project you will:</p> <ul> <li><p>familiarize yourself with the training, evaluation and tuning of machine learning models in MLJ</p> <li><p>work towards addressing a number of known performance issues, including:</p> <li><p>limitations of the generic Tables.jl interface for interacting with tabular data which, in common cases &#40;DataFrames&#41;, has extra functionality that can be exploited</p> <li><p>rolling out new data front-end for models to avoid unnecessary copying of data</p> <li><p>in conjunction with your mentor, identify best design for introducing better sparse data support to MLJ models &#40;e.g., naive Bayes&#41;</p> <li><p>implement a multi-threading and/or multi-processor parallelism to the current learning networks scheduler</p> <li><p>benchmark and profile common workflows to identify opportunities for further code optimizations</p> <li><p>implement some of these optimizations</p> </ul> <h3 id=references__8 ><a href="#references__8">References</a></h3> <ul> <li><p><a href="https://github.com/alan-turing-institute/MLJ.jl/blob/dev/ROADMAP.md#scalability">MLJ Roadmap</a>. See, in particular &quot;Scalability&quot; section.</p> <li><p><a href="https://github.com/alan-turing-institute/MLJBase.jl/issues/309">Taking performance more seriously GitHub issue</a></p> <li><p><a href="https://alan-turing-institute.github.io/MLJ.jl/dev/adding_models_for_general_use/#Implementing-a-data-front-end-1">Data front end</a> for MLJ models.</p> </ul> <p><strong>Mentors.</strong> <a href="https://ablaom.github.io">Anthony Blaom</a></p> <h2 id=correcting_for_class_imbalance_in_classification_problems ><a href="#correcting_for_class_imbalance_in_classification_problems">Correcting for class imbalance in classification problems</a></h2> <p>Improve and extend Julia&#39;s offering of algorithms for correcting class imbalance, with a view to integration into MLJ and elsewhere.</p> <p><strong>Difficulty.</strong> Easy - moderate. <strong>Duration.</strong> 350 hours</p> <h3 id=description__8 ><a href="#description__8">Description</a></h3> <p>Many classification algorithms do not perform well when there is a class imbalance in the target variable &#40;for example, many more positives than negatives&#41;. There are number of well-known data preprocessing algorithms, such as oversampling, for compensating for class imbalance. See for instance the python package <a href="https://imbalanced-learn.org/stable/">imbalance-learn</a>.</p> <p>The Julia package <a href="https://github.com/bcbi/ClassImbalance.jl">ClassImbalance.jl</a> provides some native Julia class imbalance algorithms. For wider adoption it is proposed that:</p> <ul> <li><p>ClassImbalance.jl be made more data-generic, for example made to support arbitrary tables &#40;objects implementing <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a>&#41;. Currently there is only support for an old version of DataFrames.jl. </p> <li><p>ClassImbalance.jl implements a general transformer interface, such the ones provided by <a href="https://github.com/JuliaML/TableTransforms.jl">TableTransforms.jl</a>, <a href="https://alan-turing-institute.github.io/MLJ.jl/dev/adding_models_for_general_use/">MLJ</a> or <a href="https://github.com/invenia/FeatureTransforms.jl">FeatureTransforms.jl</a> &#40;MLJ may ultimately support the TableTransforms.jl API - see the separate &quot;Feature Transforms&quot; project&#41;</p> <li><p>ClassImbalance.jl also support data containers implementing the <code>getobs</code> interface in <a href="https://mldatapatternjl.readthedocs.io/en/latest/documentation/container.html">LearnBase.jl</a> &#40;but note <a href="https://github.com/JuliaML/LearnBase.jl/issues/49">this</a> code re-organization project and <a href="https://github.com/JuliaML/MLUtils.jl/issues/61">this issue</a>&#41;.</p> <li><p>Other Julia-native algorithms be added</p> </ul> <p><strong>Mentor.</strong> <a href="https://ablaom.github.io/">Anthony Blaom</a>.</p> <h3 id=prerequisites__8 ><a href="#prerequisites__8">Prerequisites</a></h3> <ul> <li><p>Julia language fluency is essential.</p> <li><p>An understanding of the class imbalance phenomena essential. A detailed understanding of at least one class imbalance algorithm essential.</p> <li><p>Git-workflow familiarity is strongly preferred.</p> <li><p>A familiarity with machine learning goals and workflow preferred</p> </ul> <h3 id=your_contribution__8 ><a href="#your_contribution__8">Your contribution</a></h3> <ul> <li><p>Familiarize yourself with the existing ClassImbalance package, including known issues</p> <li><p>Familiarize yourself with the Tables.jl interface</p> <li><p>Assess the merits of different transformer API choices and choose one in consultation with your mentor</p> <li><p>Implement the proposed improvements in parallel with testing and documentation additions to the package. Testing and documentation must be up-to-date before new algorithms are added. </p> </ul> <h3 id=references__9 ><a href="#references__9">References</a></h3> <ul> <li><p><a href="https://github.com/bcbi/ClassImbalance.jl">ClassImbalance.jl</a> </p> <li><p><a href="https://github.com/JuliaML/TableTransforms.jl">TableTransforms.jl</a> Github</p> </ul> <p>repository.</p> <ul> <li><p><a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a></p> <li><p><a href="https://alan-turing-institute.github.io/MLJ.jl/dev/adding_models_for_general_use/">Specification of the MLJ model API</a>. </p> <li><p><a href="https://github.com/invenia/FeatureTransforms.jl">FeatureTransforms.jl</a></p> <li><p><a href="https://mldatapatternjl.readthedocs.io/en/latest/documentation/container.html">The <code>getobs</code> data container interface</a></p> </ul> <h1 id=bayesianoptimization ><a href="#bayesianoptimization">BayesianOptimization</a></h1> <p>Bayesian optimization is a global optimization strategy for &#40;potentially noisy&#41; functions with unknown derivatives. With well-chosen priors, it can find optima with fewer function evaluations than alternatives, making it well suited for the optimization of costly objective functions.</p> <p>Well known examples include hyper-parameter tuning of machine learning models &#40;see e.g. <a href="https://www.cs.ox.ac.uk/people/nando.defreitas/publications/BayesOptLoop.pdf">Taking the Human Out of the Loop: A Review of Bayesian Optimization</a>&#41;. The Julia package <a href="https://github.com/jbrea/BayesianOptimization.jl">BayesianOptimization.jl</a> currently supports only basic Bayesian optimization methods. There are multiple directions to improve the package, including &#40;but not limited to&#41;</p> <ul> <li><p><strong>Hybrid Bayesian Optimization &#40;duration: 175h, expected difficulty: medium&#41;</strong> with discrete and continuous variables. Implement e.g. <a href="https://arxiv.org/abs/2106.04682v1">HyBO</a> see also <a href="https://github.com/jbrea/BayesianOptimization.jl/issues/26">here</a>.</p> <li><p><strong>Scalable Bayesian Optimization &#40;duration: 175h, expected difficulty: medium&#41;</strong>: implement e.g. <a href="https://proceedings.neurips.cc/paper/2019/hash/6c990b7aca7bc7058f5e98ea909e924b-Abstract.html">TuRBO</a> or <a href="http://proceedings.mlr.press/v130/eriksson21a.html">SCBO</a>.</p> <li><p><strong>Better Defaults &#40;duration: 175h, expected difficulty: easy&#41;</strong>: write an extensive test suite and implement better defaults; draw inspiration from e.g. <a href="https://github.com/dragonfly/dragonfly">dragonfly</a>.</p> </ul> <p><strong>Recommended Skills:</strong> Familiarity with Bayesian inference, non-linear optimization, writing Julia code and reading Python code.</p> <p><strong>Expected Outcome:</strong> Well-tested and well-documented new features.</p> <p><strong>Mentor:</strong> <a href="https://github.com/jbrea">Johanni Brea</a></p> <h1 id=compiler_projects_summer_of_code ><a href="#compiler_projects_summer_of_code">Compiler Projects – Summer of Code</a></h1> <p>There are a number of compiler projects that are currently being worked on. Please contact Ian Atol or Jameson Nash for additional details and let us know what specifically interests you about this area of contribution. That way, we can tailor your project to better suit your interests and skillset.</p> <ul> <li><p><strong>Julia Optimization Passes &#40;350 hours&#41;</strong></p> <p>The Julia compiler performs optimizations at two distinct times during native code generation: first at the &quot;Julia level&quot;, and then at the &quot;LLVM level&quot;. At the Julia level, we have some basic optimization passes &#40;inlining, basic DCE, SROA&#41;, but currently many other interesting passes simply don&#39;t yet exist, or have a partial PR but need significant effort to finish. We see potential for many future optimizations at this phase of compilation, especially with some new analyses that have been recently added. For this proposal, we can work together to define which optimizations we could tackle next.</p> <p><strong>Expected Outcomes</strong>: Improve upon the &quot;Julia level&quot; suite of optimizations and analyses. Ideally merge an optimization that improves Julia codegen by the end of the project timeline. <strong>Skills</strong>: Julia programming, some prior knowledge of compiler optimization techniques, creative thinking, and passion for performance&#33; <strong>Difficulty</strong>: Medium</p> </ul> <ul> <li><p><strong>LLVM &#40;350 hours&#41;</strong> As previously mentioned, the Julia language utilizes LLVM as a backend for code generation. This means that there are plenty of opportunities for those with knowledge of or interest in LLVM to contribute via working on Julia&#39;s code generation process. Together, we can figure out an appropriate task if you would like to work in this area. Below are some LLVM-related projects that may be of interest.</p> <p><strong>Expected Outcomes</strong>: Improve upon the &quot;LLVM level&quot; of Julia codegen. <strong>Skills</strong>: C/C&#43;&#43; programming and some prior knowledge of LLVM &#40;in the context of clang, Rust, Swift, etc... is fine&#41; <strong>Difficulty</strong>: Hard</p> <ul> <li><p>Investigating OrcJIT v2 improvements &#40;350 hours&#41;</p> <p>The LLVM JIT has gained many new features. This project would involve finding out what they are and making use of them. Some examples include better resource tracking, parallel compilation, a new linker &#40;which may need upstream work too&#41;, and fine-grained tracking of relocations.</p> </ul> </ul> <ul> <li><p><strong>Parser error messages &#40;and other parts&#41; &#40;350 hours&#41;</strong></p> <p>Error messages and infrastructure could use some work to track source locations more precisely. This may be a large project. Contact me and @c42f for more details if this interests you.</p> <p><strong>Expected Outcomes</strong>: Improve upon Julia parser error messages. <strong>Skills</strong>: Some familiarity with parsers <strong>Difficulty</strong>: Medium</p> <li><p><strong>Macro hygiene re-implementation, to eliminate incorrect predictions inherent in current approach &#40;350 hours&#41;</strong></p> <p>This may be a good project for someone that wants to learn lisp/scheme&#33; Our current algorithm runs in multiple passes, which means sometimes we compute the wrong scope for a variable in the earlier pass than when we assign the actual scope to each value. See <a href="https://github.com/JuliaLang/julia/labels/macros">https://github.com/JuliaLang/julia/labels/macros</a>, and particularly issues such as <a href="https://github.com/JuliaLang/julia/issues/20241">https://github.com/JuliaLang/julia/issues/20241</a> and <a href="https://github.com/JuliaLang/julia/issues/34164">https://github.com/JuliaLang/julia/issues/34164</a>.</p> <p><strong>Expected Outcomes</strong>: Ideally, re-implementation of hygienic macros. Realistically, resolving some or any of the <code>macros</code> issues. <strong>Skills</strong>: Lisp/Scheme/Racket experience desired but not necessarily required. <strong>Difficulty</strong>: Medium</p> <li><p><strong>Better debug information output for variables &#40;350 hours&#41;</strong></p> <p>We have part of the infrastructure in place for representing DWARF information for our variables, but only from limited places. We could do much better since there are numerous opportunities for improvement&#33;</p> </ul> <p><strong>Expected Outcomes</strong>: Varies by project. <strong>Recommended Skills</strong>: Most of these projects involve algorithms work, requiring a willingness and interest in seeing how to integrate with a large system. <strong>Difficulty</strong>: Varies by project.</p> <p><strong>Mentors</strong>: <a href="https://github.com/vtjnash">Jameson Nash</a>, <a href="https://github.com/ianatol">Ian Atol</a></p> <h2 id=improving_test_coverage_350_hours ><a href="#improving_test_coverage_350_hours">Improving test coverage &#40;350 hours&#41;</a></h2> <p>Code coverage reports very good coverage of all of the Julia Stdlib packages, but it&#39;s not complete. Additionally, the coverage tools themselves &#40;–track-coverage and <a href="https://github.com/JuliaCI/Coverage.jl">https://github.com/JuliaCI/Coverage.jl</a>&#41; could be further enhanced, such as to give better accuracy of statement coverage, or more precision. A successful project may combine a bit of both building code and finding faults in others&#39; code.</p> <p>Another related side-project might be to explore adding Type information to the coverage reports?</p> <p><strong>Recommended Skills</strong>: An eye for detail, a thrill for filing code issues, and the skill of breaking things.</p> <p><strong>Contact:</strong> <a href="https://github.com/vtjnash">Jameson Nash</a></p> <h2 id=multi-threading_improvement_projects_350_hours ><a href="#multi-threading_improvement_projects_350_hours">Multi-threading Improvement Projects &#40;350 hours&#41;</a></h2> <p>A few ideas to get you started, in brief:</p> <ul> <li><p>Make better use of threads for GC &#40;and particularly, make the page-allocator multi-threaded&#41;</p> <li><p>Improve granularity of codegen JIT for multi-threading</p> <li><p>Improve granularity of IO operations for multi-threading &#40;and set up a worker thread for running the main libuv event loop&#41;</p> <li><p>Measure and optimize the performance of the <code>partr</code> algorithm, and add the ability to dynamically scale it by workload size</p> <li><p>Automatic insertion of GC safe-points/regions, particularly around loops</p> <li><p>Work towards supporting a dynamic number of threads</p> </ul> <p>Join the regularly scheduled multithreading call for discussion of any of these at <a href="https://calendar.google.com/event?action&#61;TEMPLATE&amp;tmeid&#61;MzQ1MnZxMGNucGt2NGQwYW1zZjA4MzM5dGtfMjAyMTAyMTdUMTYzMDAwWiBqdWxpYWxhbmcub3JnX2tvbWF1YXFldDE0ZW9nOW9pdjNwNm83cG1nQGc&amp;tmsrc&#61;julialang.org_komauaqet14eog9oiv3p6o7pmg&#37;40group.calendar.google.com&amp;scp&#61;ALL">#multithreading BoF calendar invite</a> on the Julia Language Public Events calendar.</p> <p> <strong>Recommended Skills</strong>: Varies by project</p> <p><strong>Contact:</strong> <a href="https://github.com/vtjnash">Jameson Nash</a></p> <h2 id=automation_of_testing_performance_benchmarking_350_hours ><a href="#automation_of_testing_performance_benchmarking_350_hours">Automation of testing / performance benchmarking &#40;350 hours&#41;</a></h2> <p>The Nanosoldier.jl project &#40;and related <a href="https://github.com/JuliaCI/BaseBenchmarks.jl">https://github.com/JuliaCI/BaseBenchmarks.jl</a>&#41; tests for performance impacts of some changes. However, there remains many areas that are not covered &#40;such as compile time&#41; while other areas are over-covered &#40;greatly increasing the duration of the test for no benefit&#41; and some tests may not be configured appropriately for statistical power. Furthermore, the current reports are very primitive and can only do a basic pair-wise comparison, while graphs and other interactive tooling would be more valuable. Thus, there would be many great projects for a summer contributor to tackle here&#33;</p> <p><strong>Expected Outcomes</strong>: Improvement of Julia&#39;s automated testing/benchmarking framework. <strong>Skills</strong>: Interest in and/or experience with CI systems. <strong>Difficulty</strong>: Medium</p> <p><strong>Contact:</strong> <a href="https://github.com/vtjnash">Jameson Nash</a>, <a href="https://github.com/maleadt">Tim Besard</a></p> <h1 id=dftkjl_development_projects_summer_of_code ><a href="#dftkjl_development_projects_summer_of_code">DFTK.jl development projects – Summer of Code</a></h1> <h2 id=bringing_dftk_to_graphics-processing_units_gpus ><a href="#bringing_dftk_to_graphics-processing_units_gpus">Bringing DFTK to graphics-processing units &#40;GPUs&#41;</a></h2> <p>Density-functional theory &#40;DFT&#41; is probably the most widespread method for simulating the quantum-chemical behaviour of electrons in matter and applications cover a wide range of fields such as materials research, chemistry or pharmacy. For aspects like designing the batteries, catalysts or drugs of tomorrow DFT is nowadays a key building block of the ongoing research. The aim to tackle even larger and more involved systems with DFT, however, keeps posing novel challenges with respect to physical models, reliability and performance. For tackling these aspects in the multidisciplinary context of DFT we recently started the <a href="https://dftk.org">density functional toolkit &#40;DFTK&#41;</a>, a DFT package written in pure Julia.</p> <p>Employing GPUs to bring speed improvements to DFT simulations is an established idea. However, in state-of-the-art DFT simulation packages the GPU version of the solution algorithm is usually implemented in a separate code base. In other words the CPU and the GPU version co-exist, which has the drawback of the duplicated effort to fix bugs or for keeping both code bases in sync whenever a novel method or algorithm becomes available. Since conventional GPU programming frameworks feature a steep learning curve for newcomers, oftentimes the GPU version is lagging behind and features an increased code complexity making the investigation of novel GPU algorithms challenging.</p> <p>In this project we want to build on the extensive GPU programming capabilities of the Julia ecosystem to enable DFTK to offload computations to a local GPU. Key aim will be to minimise the code which needs to be adapted from the present CPU code base in DFTK to achieve this. Since GPU counterparts already exist for most computational bottlenecks of a DFT computation, the key challenge of this project will be to handle the overall orchestration of the computational workflow as well as the data transfer between the CPU and the GPU. To keep the task manageable we will not directly tackle the full DFT problem &#40;a non-linear eigenvalue problem&#41;, but restrict ourselves to the reduced setting of linear eigenvalue problems. Expanding from there towards the full DFT is an optional stretch goal of the project.</p> <p><strong>Level of difficulty:</strong> Medium to difficult</p> <p><strong>Project size:</strong> large, i.e. 12 weeks a 30 hours</p> <p><strong>Recommended skills:</strong> Interest to work on an multidisciplinary project bordering physics, mathematics and computer science with a good working knowledge of numerical linear algebra and Julia. Detailed knowledge in the physical background &#40;electrostatics, material science&#41; or about GPU programming is not required, but be prepared to take a closer look at these domains during the project.</p> <p><strong>Expected results:</strong> Use Julias GPU programming ecosystem to implement an algorithm for solving the type of eigenvalue problems arising in density-functional theory.</p> <p><strong>Mentors:</strong> Valentin Churavy, Michael F. Herbst, Antoine Levitt</p> <p><strong>References:</strong> For a nice intro to DFT and DFTK.jl see <a href="https://www.youtube.com/watch?v&#61;-RomkxjlIcQ">Michael&#39;s talk at JuliaCon 2020</a> and the literature given in the <a href="https://docs.dftk.org/stable/guide/density_functional_theory/">DFTK documentation</a>. For an introduction to GPU computing in Julia, see <a href="https://www.youtube.com/watch?v&#61;Hz9IMJuW5hU">the GPU workshop at JuliaCon 2021</a> by Tim Besard, Julian Samaroo and Valentin.</p> <p><strong>Contact:</strong> For any questions, feel free to email <a href="https://github.com/mfherbst">@mfherbst</a>, <a href="https://github.com/antoine-levitt">@antoine-levitt</a> or write us on the <a href="https://join.slack.com/t/juliamolsim/shared_invite/zt-tc060co0-HgiKApazzsQzBHDlQ58A7g">JuliaMolSim slack</a>.</p> <h1 id=documentation_tooling ><a href="#documentation_tooling">Documentation tooling</a></h1> <h2 id=documenterjl ><a href="#documenterjl">Documenter.jl</a></h2> <p>The Julia manual and the documentation for a large chunk of the ecosystem is generated using <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> – essentially a static site generator that integrates with Julia and its docsystem. There are tons of opportunities for improvements for anyone interested in working on the interface of Julia, documentation and various front-end technologies &#40;web, LaTeX&#41;.</p> <ul> <li><p><strong>ElasticSearch-based search backend for Documenter.</strong> &#40;350 hours&#41; Loading the search page of Julia manual is slow because the index is huge and needs to be downloaded and constructed on the client side on every page load. Instead, we should look at hosting the search server-side. Goal is to continue the work done during a MLH fellowship for implementing an <a href="https://www.elastic.co/">ElasticSearch</a>-based search backend.</p> <li><p><strong>Improve the generated PDF in the PDF/LaTeX backend.</strong> &#40;175 hours&#41; The goals is to improve the look of the generated PDF and make sure backend works reliably &#40;improved testing&#41;. See <a href="https://github.com/JuliaDocs/Documenter.jl/issues/949">#949</a>, <a href="https://github.com/JuliaDocs/Documenter.jl/issues/1342">#1342</a> and <a href="https://github.com/JuliaDocs/Documenter.jl/labels/Format&#37;3A&#37;20LaTeX">other related issues</a>.</p> </ul> <p><strong>Recommended skills:</strong> Basic knowledge of web-development &#40;JS, CSS, HTML&#41; or LaTeX, depending on the project.</p> <p><strong>Mentors:</strong> <a href="https://github.com/mortenpi">Morten Piibeleht</a></p> <h2 id=docsystem_api ><a href="#docsystem_api">Docsystem API</a></h2> <p>Julia supports docstrings – inline documentation which gets parsed together with the code and can be accessed dynamically in a Julia session &#40;e.g. via the REPL <code>?&gt;</code> help mode; implemented mostly in the <a href="https://github.com/JuliaLang/julia/tree/master/base/docs">Docs module</a>&#41;.</p> <p>Not all docstrings are created equal however. There are bugs in Julia&#39;s docsystem code, which means that some docstrings do not get stored or are stored with the wrong key &#40;parametric methods&#41;. In addition, the API to fetch and work with docstrings programmatically is not documented, not considered public and could use some polishing.</p> <div class=tight-list ><ul> <li><p>Create a package which would provide a clean up the API for working with docstrings, and abstract away the implementation details &#40;and potential differences between Julia versions&#41; of the docsystem in Base.</p> <li><p>Fix as many docsystem-related bugs in the Julia core as possible &#91;<a href="http://mortenpi.eu/gsoc2019/latest/notes/docsystem-internals/#Docsystem-bugs-1">further reading</a>, <a href="https://github.com/JuliaLang/julia/issues/16730">#16730</a>, <a href="https://github.com/JuliaLang/julia/issues/29437">#29437</a>, <a href="https://github.com/JuliaDocs/Documenter.jl/issues/558">JuliaDocs/Documenter.jl#558</a>&#93;</p> </ul></div> <p><strong>Recommended skills:</strong> Basic familiarity with Julia is sufficient.</p> <p><strong>Duration:</strong> 350 hours</p> <p><strong>Mentors:</strong> <a href="https://github.com/mortenpi">Morten Piibeleht</a></p> <h1 id=fluxml_projects_-_summer_of_code ><a href="#fluxml_projects_-_summer_of_code">FluxML Projects - Summer of Code</a></h1> <p>Flux usually takes part in <a href="https://summerofcode.withgoogle.com">Google Summer of Code</a> as a NumFocus organization. We follow the same <a href="/jsoc/projects/">rules and application guidelines</a> as Julia, so please check there for more information on applying. Below are a set of ideas for potential projects &#40;though you are welcome to explore anything you are interested in&#41;.</p> <p>Flux projects are typically very competitive; we encourage you to get started early, as successful contributors typically have early PRs or working prototypes as part of the application. It is a good idea to simply start contributing via issue discussion and PRs and let a project grow from there; you can take a look at <a href="https://github.com/FluxML/Flux.jl/issues?q&#61;is&#37;3Aopen&#43;is&#37;3Aissue&#43;label&#37;3A&#37;22help&#43;wanted&#37;22">this list of issues</a> for some starter contributions.</p> <h3 id=metalheadjl_developement ><a href="#metalheadjl_developement">Metalhead.jl Developement</a></h3> <p><strong>Difficulty:</strong> Medium &#40;175h&#41;</p> <p><strong>Expected outcomes:</strong> Help us improve <a href="https://github.com/FluxML/Metalhead.jl">Metalhead.jl</a> by</p> <ul> <li><p>adding new models</p> <li><p>porting pre-trained weights</p> <li><p>extending the model interfaces to make them more customizable</p> </ul> <p><strong>Skills:</strong> Familiarity with vision model architectures and Flux.jl</p> <p><strong>Mentors:</strong> <a href="https://github.com/darsnack">Kyle Daruwalla</a></p> <h3 id=fastaijl_time_series_development ><a href="#fastaijl_time_series_development">FastAI.jl Time Series Development</a></h3> <p><strong>Difficulty:</strong> Medium &#40;350h&#41;</p> <p>In this project, you will assist the <a href="https://julialang.zulipchat.com/#narrow/stream/237432-ml-ecosystem-coordination">ML community team</a> with building time series methods for FastAI.jl on top of the existing JuliaML &#43; FluxML ecosystem packages. Some familiarity with the following Julia packages is preferred, but it is not required:</p> <div class=tight-list ><ul> <li><p><a href="https://github.com/JuliaML/MLDataPattern.jl.git">MLDataPattern.jl</a></p> <li><p><a href="https://github.com/lorenzoh/FluxTraining.jl.git">FluxTraining.jl</a></p> <li><p><a href="https://github.com/lorenzoh/DataAugmentation.jl">DataAugmentation.jl</a></p> </ul></div> <p><strong>Expected outcomes:</strong> You will</p> <ul> <li><p>load a working time series dataset using the FastAI.jl data registry</p> <li><p>create new block methods for time series tasks</p> <li><p>load at least one working time series model into a learner</p> <li><p>develop an example tutorial that ties all the previous steps together</p> </ul> <p><strong>Skills:</strong> Familiarity with deep learning pipelines, common practices, Flux.jl, and recurrent neural networks</p> <p><strong>Mentors:</strong> <a href="https://github.com/lorenzoh">Lorenz Ohly</a>, <a href="https://github.com/darsnack">Kyle Daruwalla</a>, <a href="https://github.com/ToucheSir">Brian Chen</a></p> <h3 id=fastaijl_text_development ><a href="#fastaijl_text_development">FastAI.jl Text Development</a></h3> <p><strong>Difficulty:</strong> Medium &#40;350h&#41;</p> <p>In this project, you will assist the <a href="https://julialang.zulipchat.com/#narrow/stream/237432-ml-ecosystem-coordination">ML community team</a> with building text methods for FastAI.jl on top of the existing JuliaML &#43; FluxML ecosystem packages. Some familiarity with the following Julia packages is preferred, but it is not required:</p> <div class=tight-list ><ul> <li><p><a href="https://github.com/JuliaML/MLDataPattern.jl.git">MLDataPattern.jl</a></p> <li><p><a href="https://github.com/lorenzoh/FluxTraining.jl.git">FluxTraining.jl</a></p> <li><p><a href="https://github.com/JuliaText">JuliaText</a></p> </ul></div> <p><strong>Expected outcomes:</strong> You will</p> <ul> <li><p>load a working text dataset using the FastAI.jl data registry</p> <li><p>create new block methods for textual tasks</p> <li><p>load at least one working text model into a learner</p> <li><p>develop an example tutorial that ties all the previous steps together</p> </ul> <p><strong>Skills:</strong> Familiarity with deep learning pipelines, common practices, Flux.jl, and JuliaText</p> <p><strong>Mentors:</strong> <a href="https://github.com/lorenzoh">Lorenz Ohly</a>, <a href="https://github.com/darsnack">Kyle Daruwalla</a>, <a href="https://github.com/ToucheSir">Brian Chen</a></p> <h3 id=differentiable_computer_vision ><a href="#differentiable_computer_vision">Differentiable Computer Vision</a></h3> <p><strong>Difficulty:</strong> Hard &#40;350h&#41;</p> <p>Create a library of utility functions that can consume Julia&#39;s Imaging libraries to make them differentiable. With Zygote.jl, we have the platform to take a general purpose package and apply automatic differentiation to it.</p> <p><strong>Expected outcomes:</strong> You will</p> <ul> <li><p>write AD rules for functions in existing computer vision libraries</p> <li><p>demonstrate the use of these newly differentiable libraries for tasks such as homography regression</p> </ul> <p><strong>Skills:</strong> Familiarity with automatic differentiation, deep learning, and defining &#40;a lot of&#41; Custom Adjoints</p> <p><strong>Mentors:</strong> <a href="https://github.com/DhairyaLGandhi/">Dhairya Gandhi</a></p> <h3 id=ferminets_generative_synthesis_for_automating_the_choice_of_neural_architectures ><a href="#ferminets_generative_synthesis_for_automating_the_choice_of_neural_architectures">FermiNets: Generative Synthesis for Automating the Choice of Neural Architectures</a></h3> <p><strong>Difficulty:</strong> Hard &#40;175h&#41;</p> <p>The application of machine learning requires an understanding a practitioner to optimize a neural architecture for a given problem, or does it? Recently techniques in automated machine learning, also known as AutoML, have dropped this requirement by allowing for good architectures to be found automatically. One such method is the <a href="https://arxiv.org/abs/1809.05989">FermiNet</a> which employs generative synthesis to give a neural architecture which respects certain operational requirements.</p> <p><strong>Expected outcomes:</strong> The goal of this project is to implement the FermiNet in Flux to allow for automated synthesis of neural networks.</p> <p><strong>Mentors:</strong> <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a> and <a href="https://github.com/DhairyaLGandhi/">Dhairya Gandhi</a></p> <h3 id=differentiable_rendering ><a href="#differentiable_rendering">Differentiable Rendering</a></h3> <p><strong>Difficulty:</strong> Hard &#40;350h&#43;&#41;</p> <p>We have an existing package, <a href="https://github.com/avik-pal/RayTracer.jl">RayTracer.jl</a>, which is motivated by OpenDR, and exists to do differentiable raytracing with Flux.jl and Zygote.jl.</p> <p><strong>Expected outcomes:</strong> You will</p> <ul> <li><p>implement at least 2 alternative rendering models like NeRF, VolSDF, Neural Raytracing, etc.</p> <li><p>make improvements to RayTracer.jl to use the latest Flux libraries</p> <li><p>update RayTracer.jl for ChainRules.jl</p> </ul> <p><strong>Skills:</strong> GPU Programming, Deep Learning, familiarity with the literature, familiarity with defining Custom Adjoints</p> <p><strong>Mentors:</strong> <a href="https://github.com/DhairyaLGandhi/">Dhairya Gandhi</a>, <a href="https://github.com/avik-pal">Avik Pal</a>, <a href="https://github.com/jpsamaroo">Julian Samaroo</a></p> <h1 id=graph_neural_networks_-_summer_of_code ><a href="#graph_neural_networks_-_summer_of_code">Graph Neural Networks - Summer of Code</a></h1> <p>Graph Neural Networks &#40;GNN&#41; are deep learning models well adapted to data that takes the form of graphs with feature vectors associated to nodes and edges. GNNs are a growing area of research and find many applications in complex networks analysis, relational reasoning, combinatorial optimization, molecule generation, and many other fields. </p> <p><a href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl">GraphNeuralNetworks.jl</a> is a pure Julia package for GNNs equipped with many features. It implements common graph convolutional layers, with CUDA support and graph batching for fast parallel operations. There are a number of ways by which the package could be improved.</p> <h3 id=adding_graph_convolutional_layers ><a href="#adding_graph_convolutional_layers">Adding graph convolutional layers </a></h3> <p>While we implement a good variety of graph convolutional layers, there is still a vast zoology to be implemented yet. Preprocessing tools, pooling operators, and other GNN-related functionalities can be considered as well.</p> <p><strong>Duration</strong>: 175h.</p> <p><strong>Expected difficulty</strong>: easy to medium. </p> <p><strong>Expected outcome</strong>: Enrich the package with a variety of new layers and operators.</p> <h3 id=adding_models_and_examples ><a href="#adding_models_and_examples">Adding models and examples</a></h3> <p>As part of the documentation and for bootstrapping new projects, we want to add fully worked out examples and applications of graph neural networks. We can start with entry-level tutorials and progressively introduce the reader to more advanced features. </p> <p><strong>Duration</strong>: 175h. </p> <p><strong>Expected difficulty</strong>: medium. </p> <p><strong>Expected outcome</strong>: A few pedagogical and more advanced examples of graph neural networks applications.</p> <h3 id=adding_graph_datasets ><a href="#adding_graph_datasets">Adding graph datasets</a></h3> <p>Provide Julia friendly wrappers for common graph datasets in <a href="https://github.com/JuliaML/MLDatasets.jl"><code>MLDatasets.jl</code></a>. Create convenient interfaces for the Julia ML and data ecosystem. </p> <p><strong>Duration</strong>: 175h. </p> <p><strong>Expected difficulty</strong>: easy. </p> <p><strong>Expected outcome</strong>: A large collection of graph datasets easily available to the Julia ecosystem.</p> <h3 id=supporting_heterogeneous_graphs ><a href="#supporting_heterogeneous_graphs">Supporting heterogeneous graphs</a></h3> <p>In some complex networks, the relations expressed by edges can be of different types. We need to implement an heterogeneous graph type and define convolutional layers supporting it.</p> <p><strong>Duration</strong>: 350h. </p> <p><strong>Expected difficulty</strong>: hard. </p> <p><strong>Expected outcome</strong>: The implementation of a new graph type for heterogeneous networks and corresponding graph convolutional layers.</p> <h3 id=training_on_very_large_graphs ><a href="#training_on_very_large_graphs">Training on very large graphs </a></h3> <p>Graph containing several millions of nodes are too large for gpu memory. Mini-batch training is performed on subgraphs, as in the GraphSAGE algorithm.</p> <p><strong>Duration</strong>: 175h. </p> <p><strong>Expected difficulty</strong>: hard. </p> <p><strong>Expected outcome</strong>: The necessary algorithmic components to scale GNN training to very large graphs.</p> <h3 id=supporting_temporal_graph_neural_networks ><a href="#supporting_temporal_graph_neural_networks">Supporting temporal graph neural networks</a></h3> <p>We aim at implementing temporal graph convolutions for time-varying graph and/or node features. The design of an efficient dynamical graph type is a crucial part of this project.</p> <p><strong>Duration</strong>: 350h. </p> <p><strong>Expected difficulty</strong>: hard.</p> <p><strong>Expected outcome</strong>: A new dynamical graph type and corresponding convolutional layers.</p> <h3 id=improving_performance_using_sparse_linear_algebra ><a href="#improving_performance_using_sparse_linear_algebra">Improving performance using sparse linear algebra </a></h3> <p>Many graph convolutional layers can be expressed as non-materializing algebraic operations involving the adjacency matrix instead of the slower and more memory consuming gather/scatter mechanism. We aim at extending as far as possible and in a gpu-friendly way these <em>fused</em> implementation.</p> <p><strong>Duration</strong>: 175h.</p> <p><strong>Expected difficulty</strong>: hard.</p> <p><strong>Expected outcome</strong>: A noticeable performance increase for many graph convolutional operations.</p> <h2 id=recommended_skills ><a href="#recommended_skills">Recommended skills</a></h2> <p>Familiarity with graph neural networks and Flux.jl.</p> <h2 id=mentors ><a href="#mentors">Mentors </a></h2> <p><a href="https://github.com/CarloLucibello">Carlo Lucibello</a> &#40;author of <a href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl">GraphNeuralNetworks.jl</a>&#41;. For linear algebra, co-mentoring by <a href="https://github.com/Wimmerer">Will Kimmerer</a> &#40;lead developer of <a href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl">SuiteSparseGraphBLAS.jl</a>&#41;. Feel free to contact us on the <a href="https://Julialang.slack.com/">Julia Slack Workspace</a> or by opening an issue in the GitHub repo.</p> <h1 id=gui_projects_summer_of_code ><a href="#gui_projects_summer_of_code">GUI projects – Summer of Code</a></h1> <h2 id=qml_and_makie_integration ><a href="#qml_and_makie_integration">QML and Makie integration</a></h2> <p>The <a href="https://github.com/barche/QML.jl">QML.jl</a> package provides Julia bindings for <a href="https://doc.qt.io/qt-5/qtqml-index.html">Qt QML</a> on Windows, OS X and Linux. In the current state, basic GUI functionality exists, and rough integration with <a href="https://github.com/JuliaPlots/Makie.jl">Makie.jl</a> is available, allowing overlaying QML GUI elements over Makie visualizations.</p> <h3 id=expected_results ><a href="#expected_results">Expected results</a></h3> <ol> <li><p><em>Split off the QML code for Makie into a separate package.</em> This will allow specifying proper package compatibility between QML and Makie, without making Makie a mandatory dependency for QML &#40;currently we use <a href="https://github.com/JuliaPackaging/Requires.jl">Requires.jl</a> for that&#41;</p> <li><p><em>Improve the integration.</em> Currently, connections between Makie and QML need to be set up mostly manually. We need to implement some commonly used functionality, such as the registration of clicks in a viewport with proper coordinate conversion and navigation of 3D viewports.</p> </ol> <p><strong>Recommended Skills</strong>: Familiarity with both Julia and the Qt framework, some basic C&#43;&#43; skills, affinity with 3D graphics and OpenGL.</p> <p><strong>Duration: 175h, expected difficulty: medium</strong></p> <p><strong>Mentors</strong>: <a href="https://github.com/barche">Bart Janssens</a> and <a href="https://github.com/SimonDanisch">Simon Danish</a></p> <h2 id=web_apps_in_makie_and_jsserve ><a href="#web_apps_in_makie_and_jsserve">Web apps in Makie and JSServe</a></h2> <p><a href="https://github.com/JuliaPlots/Makie.jl">Makie.jl</a> is a visualization ecosystem for the Julia programming language, with a focus on interactivity and performance. <a href="https://github.com/SimonDanisch/JSServe.jl">JSServe.jl</a> is the core infrastructure library that makes Makie&#39;s web-based backend possible.</p> <p>At the moment, all the necessary ingredients exist for designing web-based User Interfaces &#40;UI&#41; in Makie, but the process itself is quite low-level and time-consuming. The aim of this project is to streamline that process.</p> <h3 id=expected_results__2 ><a href="#expected_results__2">Expected results</a></h3> <ul> <li><p>Implement novel UI components and refine existing ones.</p> <li><p>Introduce data structures suitable for representing complex UIs.</p> <li><p>Add simpler syntaxes for common scenarios, akin to Interact&#39;s <a href="https://github.com/JuliaGizmos/Interact.jl#manipulate"><code>@manipulate</code></a> macro.</p> <li><p>Improve documentation and tutorials.</p> <li><p>Streamline the deployment process.</p> </ul> <p><strong>Bonus tasks.</strong> If time allows, one of the following directions could be pursued.</p> <ol> <li><p>Make Makie web-based plots more suitable for general web apps &#40;move more computation to the client side, improve interactivity and responsiveness&#41;.</p> <li><p>Generalize the UI infrastructure to native widgets, which are already implemented in Makie but with a different interface.</p> </ol> <p><strong>Desired skills.</strong> Familiarity with HTML, JavaScript, and CSS, as well as reactive programming. Experience with the Julia visualization and UI ecosystem.</p> <p><strong>Duration.</strong> 350h.</p> <p><strong>Difficulty.</strong> Medium.</p> <p><strong>Mentors.</strong> <a href="https://github.com/piever">Pietro Vertechi</a> and <a href="https://github.com/SimonDanisch">Simon Danisch</a>.</p> <h1 id=high_performance_and_parallel_computing_projects_summer_of_code ><a href="#high_performance_and_parallel_computing_projects_summer_of_code">High Performance and Parallel Computing Projects – Summer of Code</a></h1> <p>Julia is emerging as a serious tool for technical computing and is ideally suited for the ever-growing needs of big data analytics. This set of proposed projects addresses specific areas for improvement in analytics algorithms and distributed data management.</p> <h2 id=scheduling_algorithms_for_distributed_algorithms ><a href="#scheduling_algorithms_for_distributed_algorithms">Scheduling algorithms for Distributed algorithms</a></h2> <p><strong>Difficulty:</strong> Medium &#40;175h&#41;</p> <p>Dagger.jl is a native Julia framework and scheduler for distributed execution of Julia code and general purpose data parallelism, using dynamic, runtime-generated task graphs which are flexible enough to describe multiple classes of parallel algorithms. This project proposes to implement different scheduling algorithms for Dagger to optimize scheduling of certain classes of distributed algorithms, such as MapReduce and MergeSort, and properly utilizing heterogeneous compute resources. Contributors will be expected to find published distributed scheduling algorithms and implement them on top of the Dagger framework, benchmarking scheduling performance on a variety of micro-benchmarks and real problems.</p> <p>Mentors: <a href="https://github.com/jpsamaroo">Julian Samaroo</a>, <a href="https://github.com/vchuravy">Valentin Churavy</a></p> <h2 id=distributed_training ><a href="#distributed_training">Distributed Training</a></h2> <p><strong>Difficulty:</strong> Hard &#40;350h&#41;</p> <p>Add a distributed training API for Flux models built on top of <a href="https://github.com/JuliaParallel/Dagger.jl">Dagger.jl</a>. More detailed milestones include building Dagger.jl abstractions for <a href="https://github.com/JuliaParallel/UCX.jl">UCX.jl</a>, then building tools to map Flux models into data parallel Dagger DAGs. The final result should demonstrate a Flux model training with multiple devices in parallel via the Dagger.jl APIs. A stretch goal will include mapping operations with a model to a DAG to facilitate model parallelism as well.</p> <p>There are projects now that host the building blocks: <a href="https://github.com/FluxML/DaggerFlux.jl">DaggerFlux.jl</a> and <a href="https://github.com/DhairyaLGandhi/ResNetImageNet.jl">Distributed Data Parallel Training</a> which can serve as jumping off points.</p> <p><strong>Skills:</strong> Familiarity with UCX, representing execution models as DAGs, Flux.jl, CUDA.jl and data/model parallelism in machine learning</p> <p><strong>Mentors:</strong> <a href="https://github.com/jpsamaroo">Julian Samaroo</a>, and <a href="https://github.com/DhairyaLGandhi">Dhairya Gandhi</a></p> <h1 id=juliaimages_projects_summer_of_code ><a href="#juliaimages_projects_summer_of_code">JuliaImages Projects – Summer of Code</a></h1> <div class=franklin-toc ><ol><li><a href="#view_all_gsocjsoc_projects">View all GSoC/JSoC Projects</a><li><a href="#projects">Projects</a><ol><li><a href="#list_of_projects">List of projects</a></ol><li><a href="#machine_learning_in_predictive_survival_analysis">Machine Learning in Predictive Survival Analysis</a><ol><li><a href="#description">Description</a><li><a href="#prerequisites">Prerequisites</a><li><a href="#your_contribution">Your contribution</a><li><a href="#references">References</a></ol><li><a href="#feature_transformations">Feature transformations</a><ol><li><a href="#description__2">Description</a><li><a href="#prerequisites__2">Prerequisites</a><li><a href="#your_contribution__2">Your contribution</a><li><a href="#references__2">References</a></ol><li><a href="#time_series_forecasting_at_scale_-_speed_up_via_julia">Time series forecasting at scale - speed up via Julia</a><ol><li><a href="#prerequisites__3">Prerequisites</a><li><a href="#your_contribution__3">Your contribution</a><li><a href="#references__3">References</a></ol><li><a href="#interpretable_machine_learning_in_julia">Interpretable Machine Learning in Julia</a><ol><li><a href="#description__3">Description</a><li><a href="#prerequisites__4">Prerequisites</a><li><a href="#your_contribution__4">Your contribution</a><li><a href="#references__4">References</a></ol><li><a href="#model_visualization_in_mlj">Model visualization in MLJ</a><ol><li><a href="#description__4">Description</a><li><a href="#prerequisites__5">Prerequisites</a><li><a href="#your_contribution__5">Your contribution</a><li><a href="#references__5">References</a></ol><li><a href="#deeper_bayesian_integration">Deeper Bayesian Integration</a><ol><li><a href="#description__5">Description</a><li><a href="#your_contributions">Your contributions</a><li><a href="#references__6">References</a><li><a href="#difficulty_medium_to_hard">Difficulty: Medium to Hard</a></ol><li><a href="#tracking_and_sharing_mlj_workflows_using_mlflow">Tracking and sharing MLJ workflows using MLFlow</a><ol><li><a href="#description__6">Description</a><li><a href="#prerequisites__6">Prerequisites</a><li><a href="#your_contribution__6">Your contribution</a><li><a href="#references__7">References</a></ol><li><a href="#speed_demons_only_need_apply">Speed demons only need apply</a><ol><li><a href="#description__7">Description</a><li><a href="#prerequisites__7">Prerequisites</a><li><a href="#your_contribution__7">Your contribution</a><li><a href="#references__8">References</a></ol><li><a href="#correcting_for_class_imbalance_in_classification_problems">Correcting for class imbalance in classification problems</a><ol><li><a href="#description__8">Description</a><li><a href="#prerequisites__8">Prerequisites</a><li><a href="#your_contribution__8">Your contribution</a><li><a href="#references__9">References</a></ol><li><a href="#improving_test_coverage_350_hours">Improving test coverage &#40;350 hours&#41;</a><li><a href="#multi-threading_improvement_projects_350_hours">Multi-threading Improvement Projects &#40;350 hours&#41;</a><li><a href="#automation_of_testing_performance_benchmarking_350_hours">Automation of testing / performance benchmarking &#40;350 hours&#41;</a><li><a href="#bringing_dftk_to_graphics-processing_units_gpus">Bringing DFTK to graphics-processing units &#40;GPUs&#41;</a><li><a href="#documenterjl">Documenter.jl</a><li><a href="#docsystem_api">Docsystem API</a><ol><li><a href="#metalheadjl_developement">Metalhead.jl Developement</a><li><a href="#fastaijl_time_series_development">FastAI.jl Time Series Development</a><li><a href="#fastaijl_text_development">FastAI.jl Text Development</a><li><a href="#differentiable_computer_vision">Differentiable Computer Vision</a><li><a href="#ferminets_generative_synthesis_for_automating_the_choice_of_neural_architectures">FermiNets: Generative Synthesis for Automating the Choice of Neural Architectures</a><li><a href="#differentiable_rendering">Differentiable Rendering</a><li><a href="#adding_graph_convolutional_layers">Adding graph convolutional layers </a><li><a href="#adding_models_and_examples">Adding models and examples</a><li><a href="#adding_graph_datasets">Adding graph datasets</a><li><a href="#supporting_heterogeneous_graphs">Supporting heterogeneous graphs</a><li><a href="#training_on_very_large_graphs">Training on very large graphs </a><li><a href="#supporting_temporal_graph_neural_networks">Supporting temporal graph neural networks</a><li><a href="#improving_performance_using_sparse_linear_algebra">Improving performance using sparse linear algebra </a></ol><li><a href="#recommended_skills">Recommended skills</a><li><a href="#mentors">Mentors </a><li><a href="#qml_and_makie_integration">QML and Makie integration</a><ol><li><a href="#expected_results">Expected results</a></ol><li><a href="#web_apps_in_makie_and_jsserve">Web apps in Makie and JSServe</a><ol><li><a href="#expected_results__2">Expected results</a></ol><li><a href="#scheduling_algorithms_for_distributed_algorithms">Scheduling algorithms for Distributed algorithms</a><li><a href="#distributed_training">Distributed Training</a><li><a href="#benchmarking_against_other_frameworks">Benchmarking against other frameworks</a><li><a href="#gpu_support_for_many_algorithms">GPU support for many algorithms</a><li><a href="#better_imageio_supports_open_ended">Better ImageIO supports &#40;open ended&#41;</a><li><a href="#exif_viewer">EXIF viewer</a><li><a href="#better_qr_code_support_open_ended">Better QR Code support &#40;open ended&#41;</a><li><a href="#where_to_go_for_discussion_and_to_find_mentors">Where to go for discussion and to find mentors</a><li><a href="#c">C&#43;&#43;</a><ol><li><a href="#cxxwrap_stl">CxxWrap STL</a><ol><li><a href="#expected_outcome">Expected outcome</a></ol></ol><li><a href="#rust">Rust</a><li><a href="#improve_javis_performance">Improve Javis Performance</a><li><a href="#building_novel_animation_abilities_for_javis">Building Novel Animation Abilities for Javis</a><li><a href="#agentsjl">Agents.jl</a><li><a href="#dynamicalsystemsjl">DynamicalSystems.jl</a><li><a href="#midification_of_music_from_wave_files">MIDIfication of music from wave files</a><li><a href="#efficient_low-dimensional_symbolic-numeric_set_computations">Efficient low-dimensional symbolic-numeric set computations</a><li><a href="#reachability_with_sparse_polynomial_zonotopes">Reachability with sparse polynomial zonotopes</a><li><a href="#improving_the_hybrid_systems_reachability_api">Improving the hybrid systems reachability API</a><li><a href="#panel_data_analysis">Panel data analysis</a><ol><li><a href="#description__9">Description</a><li><a href="#prerequisites__9">Prerequisites</a><li><a href="#your_contribution__9">Your contribution</a><li><a href="#references__10">References</a></ol><li><a href="#crraojl">CRRao.jl</a><ol><li><a href="#description__10">Description</a><li><a href="#prerequisites__10">Prerequisites</a><li><a href="#your_contribution__10">Your contribution</a></ol><li><a href="#juliastats_improvements">JuliaStats Improvements </a><ol><li><a href="#description__11">Description</a><li><a href="#prerequisites__11">Prerequisites</a><li><a href="#your_contribution__11">Your contribution</a></ol><li><a href="#smoothing_non-linear_continuous_time_systems">Smoothing non-linear continuous time systems</a><li><a href="#developing_a_julia_pluginfrontend_allowing_the_application_of_a_custom_compiler_pipeline">Developing a Julia plugin/frontend allowing the application of a custom compiler pipeline</a><li><a href="#developing_loop_models_350_hours">Developing Loop Models &#40;350 hours&#41;:</a><ol><li><a href="#cuda_hacking">CUDA Hacking</a><ol><li><a href="#expected_outcomes">Expected Outcomes</a></ol><li><a href="#reinforcement_learning_environments">Reinforcement Learning Environments</a><ol><li><a href="#expected_outcome__2">Expected outcome</a></ol><li><a href="#reinforcement_learning_algorithms">Reinforcement Learning Algorithms</a><ol><li><a href="#expected_outcomes__2">Expected Outcomes</a></ol><li><a href="#alphazerojl">AlphaZero.jl</a><ol><li><a href="#expected_outcomes__3">Expected Outcomes</a></ol></ol><li><a href="#numerical_linear_algebra">Numerical Linear Algebra</a><ol><li><a href="#matrix_functions">Matrix functions</a></ol><li><a href="#better_bignums_integration">Better Bignums Integration</a><ol><li><a href="#special_functions">Special functions</a><li><a href="#a_julia-native_ccsa_optimization_algorithm">A Julia-native CCSA optimization algorithm</a></ol><li><a href="#massive_parallel_factorized_bouncy_particle_sampler">Massive parallel factorized bouncy particle sampler</a><li><a href="#pluto_as_a_vs_code_notebook">Pluto as a VS Code notebook</a><li><a href="#tools_for_education">Tools for education</a><li><a href="#electron_app">Electron app</a><li><a href="#wrapping_a_rust_http_server_in_julia">Wrapping a Rust HTTP server in Julia</a><ol><li><a href="#introduction">Introduction</a><li><a href="#details">Details</a></ol><li><a href="#machine_learning_time_series_regression">Machine Learning Time Series Regression</a><li><a href="#machine_learning_for_nowcasting_and_forecasting">Machine learning for nowcasting and forecasting</a><li><a href="#time_series_forecasting_at_scales">Time series forecasting at scales</a><li><a href="#gpu_accelerated_simulator_of_clifford_circuits">GPU accelerated simulator of Clifford Circuits.</a><li><a href="#pauli_frames_for_faster_sampling">Pauli Frames for faster sampling.</a><li><a href="#a_zoo_of_quantum_error_correcting_codes">A Zoo of Quantum Error Correcting codes.</a><li><a href="#leftright_multiplications_with_small_gates">Left/Right multiplications with small gates.</a><li><a href="#symbolic_root_finding">Symbolic root finding</a><li><a href="#symbolic_integration_in_symbolicsjl">Symbolic Integration in Symbolics.jl</a><li><a href="#xla-style_optimization_from_symbolic_tracing">XLA-style optimization from symbolic tracing</a><li><a href="#automatically_improving_floating_point_accuracy_herbie">Automatically improving floating point accuracy &#40;Herbie&#41;</a><li><a href="#implement_flashfill_in_julia">Implement Flashfill in Julia </a><li><a href="#parquetjl_enhancements">Parquet.jl enhancements</a><li><a href="#statistical_transforms">Statistical transforms</a><li><a href="#utility_transforms">Utility transforms</a><li><a href="#how_to_get_started">How to get started?</a><li><a href="#machine_learning_in_topology_optimisation">Machine learning in topology optimisation</a><li><a href="#multi-material_design_representation">Multi-material design representation</a><li><a href="#optimisation_on_a_uniform_rectilinear_grid">Optimisation on a uniform rectilinear grid</a><li><a href="#adaptive_mesh_refinement_for_topology_optimisation">Adaptive mesh refinement for topology optimisation</a><li><a href="#heat_transfer_design_optimisation">Heat transfer design optimisation</a><li><a href="#more_real-world_bayesian_models_in_turing_julia">More real-world Bayesian models in Turing / Julia</a><li><a href="#improving_the_integration_between_turing_and_turings_mcmc_inference_packages">Improving the integration between Turing and Turing&#39;s MCMC inference packages</a><li><a href="#directed-graphical_model_support_for_the_abstract_probabilistic_programming_library">Directed-graphical model support for the abstract probabilistic programming library</a><li><a href="#a_modular_tape_caching_mechanism_for_reversediff">A modular tape caching mechanism for ReverseDiff</a><li><a href="#benchmarking_improving_performance_of_the_juliagaussianprocesses_libraries">Benchmarking &amp; improving performance of the JuliaGaussianProcesses libraries</a><li><a href="#iterative_methods_for_inference_in_gaussian_processes">Iterative methods for inference in Gaussian Processes</a><li><a href="#approximate_inference_methods_for_non-gaussian_likelihoods_in_gaussian_processes">Approximate inference methods for non-Gaussian likelihoods in Gaussian Processes</a><li><a href="#gpu_integration_in_the_juliagps_ecosystem">GPU integration in the JuliaGPs ecosystem</a><li><a href="#vs_code_extension">VS Code extension</a><li><a href="#package_installation_ui">Package installation UI</a><li><a href="#code_generation_improvements_and_async_abi">Code generation improvements and async ABI</a><li><a href="#wasm_threading">Wasm threading</a><li><a href="#high_performance_low-level_integration_of_js_objects">High performance, Low-level integration of js objects</a><li><a href="#dom_integration">DOM Integration</a><li><a href="#porting_existing_web-integration_packages_to_the_wasm_platform">Porting existing web-integration packages to the wasm platform</a><li><a href="#native_dependencies_for_the_web">Native dependencies for the web</a><li><a href="#distributed_computing_with_untrusted_parties">Distributed computing with untrusted parties</a><li><a href="#deployment">Deployment</a></ol></div> <p><a href="https://github.com/JuliaImages">JuliaImages</a> &#40;see the <a href="https://juliaimages.github.io">documentation</a>&#41; is a framework in Julia for multidimensional arrays, image processing, and computer vision &#40;CV&#41;. It has an active development community and offers many features that unify CV and biomedical 3D/4D image processing, support big data, and promote interactive exploration.</p> <p>Often the best ideas are the ones that candidate SoC contributors come up with on their own. We are happy to <a href="https://github.com/JuliaImages/Images.jl/discussions/new?category&#61;jsoc">discuss such ideas</a> and help you refine your proposal. Below are some potential project ideas that might help spur some thoughts. In general, anything that is missing in JuliaImages, and worths three-months&#39; development can be considered as potential GSoC ideas. See the bottom of this page for information about mentors.</p> <h2 id=benchmarking_against_other_frameworks ><a href="#benchmarking_against_other_frameworks">Benchmarking against other frameworks</a></h2> <p><strong>Difficulty:</strong> Medium &#40;175h&#41;</p> <p>JuliaImages provides high-quality implementations of many algorithms; however, as yet there is no set of benchmarks that compare our code against that of other image-processing frameworks. Developing such benchmarks would allow us to advertise our strengths and/or identify opportunities for further improvement. See also the OpenCV project below.</p> <p>Benchmarks for several performance-sensitive packages &#40;e.g., ImageFiltering, ImageTransformations, ImageMorphology, ImageContrastAdjustment, ImageEdgeDetection, ImageFeatures, and/or ImageSegmentation&#41; against frameworks like Scikit-image and OpenCV, and optionally others like ITK, ImageMagick, and Matlab/Octave. See also the <a href="https://github.com/JuliaImages/image_benchmarks">image benchmarks</a> repository.</p> <p>This task splits into at least two pieces:</p> <ul> <li><p>developing frameworks for collecting the data, and</p> <li><p>visualizing the results.</p> </ul> <p>One should also be aware of the fact that differences in implementation &#40;which may include <a href="https://github.com/JuliaImages/Images.jl/pull/855">differences in quality</a>&#41; may complicate the interpretation of some benchmarks.</p> <p><strong>Skills:</strong> JuliaImages experiences is required. Some familiarities with other image processing frameworks is preferred.</p> <p><strong>Mentors:</strong> <a href="https://github.com/johnnychen94">Johnny Chen</a></p> <h2 id=gpu_support_for_many_algorithms ><a href="#gpu_support_for_many_algorithms">GPU support for many algorithms</a></h2> <p><strong>Difficulty:</strong> Hard &#40;350h&#41;</p> <p>JuliaImages supports many common algorithms, but targets only the CPU. With Julia now possessing <a href="https://github.com/JuliaGPU">first-in-class support for GPUs</a>, now is the time to provide GPU implementations of many of the same algorithms.</p> <p><a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions</a> may make it easier to support both CPU and GPU with a common implementation.</p> <p>Fairly widespread GPU support for a single nontrivial package. <a href="https://github.com/JuliaImages/ImageFiltering.jl">ImageFiltering</a> would be a good choice.</p> <p><strong>Skills:</strong> Familiarity with CUDA programming in Julia, i.e., <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> is required.</p> <p><strong>Mentors:</strong> <a href="https://github.com/johnnychen94">Johnny Chen</a></p> <h2 id=better_imageio_supports_open_ended ><a href="#better_imageio_supports_open_ended">Better ImageIO supports &#40;open ended&#41;</a></h2> <p><strong>Difficulty:</strong> Medium&#40;175h&#41; or Hard&#40;350h&#41;</p> <p>ImageIO is the default IO backend shipped with Images.jl. It already supports a lot of image formats, yet there still exists some formats that are missing &#40;e.g., GIF, JPEG 2000&#41;. Potential applicant needs to support new formats by either 1&#41; wrapping available C libraries via BinaryBuilder, or 2&#41; re-implement the functionality with pure Julia. See also the EXIF project below.</p> <p><strong>Skills:</strong> Experiences with Julia is required. For library wrapping projects, experiences with cross-compiling in Linux system is required, and familiarity with the source language &#40;e.g., C&#41; is preferred. The difficulty almost totally depends on how the complicate the format is, and if there exists an easy-to-wrap C library.</p> <p><strong>Mentors:</strong> <a href="https://github.com/johnnychen94">Johnny Chen</a>, <a href="https://github.com/Gnimuc">Yupei Qi</a> and <a href="https://github.com/IanButterworth">Ian Butterworth</a></p> <h2 id=exif_viewer ><a href="#exif_viewer">EXIF viewer</a></h2> <p><strong>Difficulty:</strong> Medium&#40;175h&#41;</p> <p><a href="https://en.wikipedia.org/wiki/Exif">Exchangeable image file format &#40;EXIF&#41;</a> is a widely used specification to store camera information. Potential applicant needs to provide a package to support read/write EXIF data of image file. This can be implemented in pure Julia, or wrapping the C package <a href="https://github.com/libexif/libexif">libexif</a>.</p> <p><strong>Skills:</strong> Similar to above ImageIO skills requirements.</p> <p><strong>Mentors:</strong> <a href="https://github.com/johnnychen94">Johnny Chen</a> and <a href="https://github.com/Gnimuc">Yupei Qi</a></p> <h2 id=better_qr_code_support_open_ended ><a href="#better_qr_code_support_open_ended">Better QR Code support &#40;open ended&#41;</a></h2> <p><strong>Difficulty:</strong> Medium&#40;175h&#41; or Hard&#40;350h&#41;</p> <p><a href="https://github.com/jiegillet/QRCode.jl">QRCode.jl</a> is a legacy package that supports encoding data to QR code. Contributors are required to revive this package to co-exist with the latest JuliaImages ecosystem, and also adding support to decode QR code into Julia data. Decoding QR code can be potentially be challenging and students need to find out a satisfying solution from the literature.</p> <p><strong>Skills:</strong> Experiences in JuliaImages are required. The ability to read and understand the QR code specification.</p> <p><strong>Mentors:</strong> <a href="https://github.com/johnnychen94">Johnny Chen</a></p> <h2 id=where_to_go_for_discussion_and_to_find_mentors ><a href="#where_to_go_for_discussion_and_to_find_mentors">Where to go for discussion and to find mentors</a></h2> <p>Interested contributors are encouraged to <a href="https://github.com/JuliaImages/Images.jl/discussions/new">open an discussion in Images.jl</a> to introduce themselves and discuss the detailed project ideas. To increase the chance of getting useful feedback, please provide detailed plans and ideas &#40;don&#39;t just copy the contents here&#41;.</p> <h1 id=language_interoperability_summer_of_code ><a href="#language_interoperability_summer_of_code">Language interoperability – Summer of Code</a></h1> <h2 id=c ><a href="#c">C&#43;&#43;</a></h2> <h3 id=cxxwrap_stl ><a href="#cxxwrap_stl">CxxWrap STL</a></h3> <p>The <a href="https://github.com/JuliaInterop/CxxWrap.jl">CxxWrap.jl</a> package provides a way to load compiled C&#43;&#43; code into Julia. It exposes a small fraction of the C&#43;&#43; standard library to Julia, but many more functions and containers &#40;e.g. <code>std::map</code>&#41; still need to be exposed. The objective of this project is to improve C&#43;&#43; standard library coverage.</p> <h4 id=expected_outcome ><a href="#expected_outcome">Expected outcome</a></h4> <ol> <li><p>Add missing STL container types &#40;easy&#41;</p> <li><p>Add support for STL algorithms &#40;intermediate&#41;</p> <li><p>Investigate improvement of compile times and selection of included types &#40;advanced&#41;</p> </ol> <p><strong>Recommended Skills</strong>: Familiarity with both Julia and C&#43;&#43;</p> <p><strong>Duration: 175h, expected difficulty: hard</strong></p> <p><strong>Mentor</strong>: <a href="https://github.com/barche">Bart Janssens</a></p> <h2 id=rust ><a href="#rust">Rust</a></h2> <p>Take a look at the <a href=pluto >hyper.rs project, listed on the &quot;Pluto&quot; page</a> about wrapping a Rust HTTP server in a Julia package.</p> <h1 id=javis_projects_summer_of_code ><a href="#javis_projects_summer_of_code">Javis Projects – Summer of Code</a></h1> <blockquote> <p><a href="https://github.com/JuliaAnimators/Javis.jl">Javis: <strong>J</strong>ulia <strong>A</strong>nimations and <strong>Vis</strong>ualizations</a></p> </blockquote> <p>Are you ready to create the next amazing visualization? With Javis you can&#33; <a href="https://github.com/JuliaAnimators/Javis.jl">Javis.jl</a> is a general purpose Julia library to easily construct informative, performant, and winsome animated graphics. It uses a object-action relationship for users to make such visuals.</p> <p>Javis has found application in diverse areas such as <a href="https://juliaanimators.github.io/Javis.jl/dev/examples/">teaching, art and more</a>. To learn more about Javis and what it is capable of, check out our <a href="https://www.youtube.com/watch?v&#61;ckvsc6ukdOc">2021 JuliaCon talk</a>&#33; It builds on top of the drawing framework <a href="https://github.com/JuliaGraphics/Luxor.jl">Luxor.jl</a> by adding functions to simplify the creation of objects and their actions.</p> <p>Below you can find a list of potential projects that can be tackled during Google Summer of Code. If interested in exploring any of these projects, please reach out to any of the following mentors:</p> <ul> <li><p><strong><a href="http://jacobzelko.com/">Jacob Zelko</a></strong> - <a href="mailto:jacobszelko@gmail.com">email</a>, <a href="https://julialang.org/slack/">Slack</a> &#40;username: TheCedarPrince&#41;, or <a href="https://julialang.zulipchat.com/">Zulip</a> &#40;username: TheCedarPrince&#41;</p> <li><p><strong><a href="https://opensourc.es/about/">Ole Kröger</a></strong> - <a href="o.kroeger@opensourc.es">email</a>, <a href="https://julialang.org/slack/">Slack</a> &#40;username: Wikunia&#41;, or <a href="https://julialang.zulipchat.com/">Zulip</a> &#40;username: Wikunia&#41;</p> <li><p><strong><a href="https://gpucce.github.io">Giovanni Puccetti</a></strong> - <a href="https://julialang.zulipchat.com/">Zulip</a> &#40;username: Giovanni&#41;</p> <li><p><strong><a href="https://sov-trotter.github.io/blog/">Arsh Sharma</a></strong> - <a href="https://julialang.zulipchat.com/">Zulip</a> &#40;username: Arsh Sharma&#41;</p> </ul> <p>Thanks for your interest&#33; 🎉</p> <h2 id=improve_javis_performance ><a href="#improve_javis_performance">Improve Javis Performance</a></h2> <p><strong>Mentors:</strong> Ole Kröger, Arsh Sharma</p> <p><strong>Recommended Skills:</strong> Familiarity with profiling, caching approaches, and performance testing</p> <p><strong>Duration:</strong> 175 hrs</p> <p><strong>Difficulty:</strong> Medium</p> <p>As Javis&#39;s interface is largely stabilized and Javis is finding use in different applications, it is now time to deal with one of Javis&#39;s greatest pain points: slowness and high memory usage for large animations. While creating an animation in Javis, there is much room for performance improvements such as in the area of creating Objects and Actions, managing the data structures for Objects and Actions, rendering an animation, and handling different media formats &#40;such as gif and mp4&#41;. For this specific project, a contributor will work with Ole and Arsh to create a profiling scheme for Javis to identify performance bottlenecks and measure allocations, determine caching and memory flexible modes of rendering animations with tools such as <a href="https://github.com/JuliaIO/FFMPEG.jl">FFMPEG.jl</a>, and finish implementing live streaming of animations. The goal for this project will not be to fully fix all identified performance issues but rather to identify and catalogue them for further development by Javis maintainers and contributors.</p> <h2 id=building_novel_animation_abilities_for_javis ><a href="#building_novel_animation_abilities_for_javis">Building Novel Animation Abilities for Javis</a></h2> <p><strong>Mentors:</strong> Jacob Zelko, Giovanni Puccetti</p> <p><strong>Recommended Skills:</strong> General understanding of Luxor and the underlying structure of Javis</p> <p><strong>Duration:</strong> 175 hrs</p> <p><strong>Difficulty:</strong> Medium</p> <p>Javis&#39;s interface has matured to a great point - but we believe Javis can do even more&#33; Although Javis can do complex transformations such as morphing one polygon to another, Javis is capable of more than that. In this project, a contributor will work with Jacob and Giovanni to create new animation abilities for Javis to handle different coordinate systems, developing new types of shorthand expressions for object creation known as JObjects, further developing morphing, building out the flexibility of layers, and developing new interfaces &#40;see this <a href="https://github.com/JuliaAnimators/Javis.jl/pull/434">PR for an idea</a>&#41;. A contributor is encouraged to come to this project with new ideas for what animations Javis can do and to reach out to Jacob and Giovanni to begin discussions early.</p> <h1 id=dynamical_systems_complex_systems_nonlinear_dynamics_summer_of_code ><a href="#dynamical_systems_complex_systems_nonlinear_dynamics_summer_of_code">Dynamical systems, complex systems &amp; nonlinear dynamics – Summer of Code</a></h1> <h2 id=agentsjl ><a href="#agentsjl">Agents.jl</a></h2> <p><strong>Difficulty</strong>: Medium to Hard.</p> <p><strong>Length</strong>: 350 hours.</p> <p><a href="https://juliadynamics.github.io/Agents.jl/stable/">Agents.jl</a> is a pure Julia framework for agent-based modeling &#40;ABM&#41;. It has an extensive list of features, excellent performance and is easy to learn, use, and extend. Comparisons with other popular frameworks written in Python or Java &#40;NetLOGO, MASON, Mesa&#41;, show that Agents.jl outperforms all of them in computational speed, list of features and usability.</p> <p>In this project, contributors will be paired with lead developers of Agents.jl to improve Agents.jl with more features, better performance, and overall higher polish. Possible features to implement are:</p> <div class=tight-list ><ul> <li><p>Automatic performance increase of mixed-agent models by eliminating dynamic dispatch on the stepping function</p> <li><p>GPU support in Agents.jl</p> <li><p>New type of space representing a planet, which can be used in climate policy or human evolution modelling, and new interface for an overarching ABM composed of several smaller ABMs</p> </ul></div> <p><strong>Recommended Skills</strong>: Familiarity with agent based modelling, Agents.jl and Julia&#39;s Type System. Background in complex systems, sociology, or nonlinear dynamics is not required but would be advantageous.</p> <p><strong>Expected Results</strong>: Well-documented, well-tested useful new features for Agents.jl.</p> <p><strong>Mentors</strong>: <a href="https://github.com/Datseris">George Datseris</a>.</p> <h2 id=dynamicalsystemsjl ><a href="#dynamicalsystemsjl">DynamicalSystems.jl</a></h2> <p><strong>Difficulty:</strong> Easy to Medium, depending on the algorithms chosen to implement.</p> <p><strong>Length</strong>: 175 hours.</p> <p><a href="https://juliadynamics.github.io/DynamicalSystems.jl/latest/">DynamicalSystems.jl</a> is an <a href="https://dsweb.siam.org/The-Magazine/Article/winners-of-the-dsweb-2018-software-contest">award-winning</a> Julia software library for dynamical systems, nonlinear dynamics, deterministic chaos and nonlinear time series analysis. It has an impressive list of features, but one can never have enough. In this project, contributors will be able to enrich DynamicalSystems.jl with new algorithms and enrich their knowledge of nonlinear dynamics and computer-assisted exploration of complex systems.</p> <p>Possible projects are summarized in the <a href="https://github.com/issues?q&#61;is&#37;3Aopen&#43;is&#37;3Aissue&#43;repo&#37;3AJuliaDynamics&#37;2FChaosTools.jl&#43;repo&#37;3AJuliaDynamics&#37;2FDynamicalSystemsBase.jl&#43;repo&#37;3AJuliaDynamics&#37;2FDelayEmbeddings.jl&#43;repo&#37;3AJuliaDynamics&#37;2FRecurrenceAnalysis.jl&#43;repo&#37;3AJuliaDynamics&#37;2FDynamicalSystems.jl&#43;label&#37;3A&#37;22wanted&#43;feature&#37;22&#43;">wanted-features of the library</a></p> <p><strong>Recommended Skills</strong>: Familiarity with nonlinear dynamics and/or differential equations and the Julia language.</p> <p><strong>Expected Results</strong>: Well-documented, well-tested new algorithms for DynamicalSystems.jl.</p> <p><strong>Mentors</strong>: <a href="https://github.com/Datseris">George Datseris</a></p> <h1 id=music_data_analysis_-_summer_of_code ><a href="#music_data_analysis_-_summer_of_code">Music data analysis - Summer of Code</a></h1> <p><a href="https://github.com/JuliaMusic">JuliaMusic</a> is an organization providing packages and functionalities that allow analyzing the properties of music performances. </p> <h2 id=midification_of_music_from_wave_files ><a href="#midification_of_music_from_wave_files">MIDIfication of music from wave files</a></h2> <p><strong>Difficulty</strong>: Medium.</p> <p><strong>Length</strong>: 350 hours.</p> <p>It is easy to analyze timing and intensity fluctuations in music that is the form of MIDI data. This format is already digitalized, and packages such as MIDI.jl and MusicManipulations.jl allow for seamless data processing. But arguably the most interesting kind of music to analyze is the live one. Live music performances are recorded in wave formats. Some algorithms exist that can detect the &quot;onsets&quot; of music hits, but they are typically focused only on the timing information and hence forfeit detecting e.g., the intensity of the played note. Plus, there are very few code implementations online for this problem, almost all of which are old and unmaintained. We would like to implement an algorithm in MusicProcessing.jl that given a recording of a single instrument, it can &quot;MIDIfy&quot; it, which means to digitalize it into the MIDI format.</p> <p><strong>Recommended Skills</strong>: Background in music, familiarity with digital signal processing.</p> <p><strong>Expected results</strong>: A well-tested, well-documented function <code>midify</code> in MusicProcessing.jl.</p> <p><strong>Mentors</strong>: <a href="https://github.com/Datseris/">George Datseris</a>.</p> <h1 id=juliareach_-_summer_of_code ><a href="#juliareach_-_summer_of_code">JuliaReach - Summer of Code</a></h1> <p><a href="https://github.com/JuliaReach">JuliaReach</a> is the Julia ecosystem for reachability computations of dynamical systems.</p> <h2 id=efficient_low-dimensional_symbolic-numeric_set_computations ><a href="#efficient_low-dimensional_symbolic-numeric_set_computations">Efficient low-dimensional symbolic-numeric set computations</a></h2> <p><strong>Difficulty</strong>: Medium.</p> <p><strong>Description.</strong> <a href="https://github.com/JuliaReach/LazySets.jl">LazySets</a> is a Julia library for computing with geometric sets, whose focus is on lazy set representations and efficient high-dimensional processing. The main interest in this project is to develop algorithms that leverage the structure of the sets. The special focus will be on low-dimensional &#40;typically 2D and 3D&#41; cases.</p> <p><strong>Expected Results.</strong> The goal is to implement certain efficient algorithms from the literature. The code is to be documented, tested, and evaluated in benchmarks. Specific tasks may include: efficient vertex enumeration of <a href="https://juliareach.github.io/LazySets.jl/dev/lib/sets/Zonotope/#LazySets.Zonotope">zonotopes</a>; operations on <a href="http://archive.www6.in.tum.de/www6/Main/Publications/Althoff2011f.pdf">zonotope bundles</a>; efficient disjointness checks between different set types; <a href="https://ieeexplore.ieee.org/document/7525593">complex zonotopes</a>.</p> <p><strong>Expected Length.</strong> 175 hours.</p> <p><strong>Recommended Skills.</strong> Familiarity with Julia and Git/GitHub is mandatory. Familiarity with <a href="https://github.com/JuliaReach/LazySets.jl">LazySets</a> is recommended. Basic knowledge of geometric terminology is appreciated but not required.</p> <p><strong>Mentors</strong>: <a href="https://github.com/mforets">Marcelo Forets</a>, <a href="https://github.com/schillic">Christian Schilling</a>.</p> <h2 id=reachability_with_sparse_polynomial_zonotopes ><a href="#reachability_with_sparse_polynomial_zonotopes">Reachability with sparse polynomial zonotopes</a></h2> <p><strong>Difficulty</strong>: Hard.</p> <p><strong>Description.</strong> Sparse polynomial zonotopes are a new non-convex set representation that are well-suited for reachability analysis of nonlinear dynamical systems. The task is to add efficient Julia implementations of:</p> <p>&#40;1&#41; sparse polynomial zonotopes in <a href="https://github.com/JuliaReach/LazySets.jl">LazySets</a>,</p> <p>&#40;2&#41; the corresponding reachability algorithm for dynamical systems in <a href="https://github.com/JuliaReach/ReachabilityAnalysis.jl">ReachabilityAnalysis</a>.</p> <p><strong>Expected Results.</strong> The goal is to efficiently implement sparse polynomial zonotopes and the corresponding reachability algorithms. The code is to be documented, tested, and evaluated extensively in benchmarks. If the candidate is interested, it is possible to change task &#40;2&#41; with </p> <p>&#40;3&#41; an integration of the new set representation for neural-network control systems in <a href="https://github.com/JuliaReach/NeuralNetworkAnalysis.jl">NeuralNetworkAnalysis</a>.</p> <p><strong>Expected Length.</strong> 350 hours.</p> <p><strong>Recommended Skills.</strong> Familiarity with Julia and Git/GitHub is mandatory. Familiarity with the mentioned Julia packages is appreciated but not required. The project does not require theoretical contributions, but it requires reading a research article &#40;see below&#41;; hence a certain level of academic experience is recommended.</p> <p><strong>Literature and related packages.</strong> <a href="https://www.youtube.com/watch?v&#61;iMtq6YeIsjA">This video</a> explains the concept of polynomial zonotopes &#40;slides <a href="https://github.com/JuliaReach/juliareach-days-3-reachathon/blob/master/Challenge_5/Challenge5_PolynomialZonotopes.pdf">here</a>&#41;. The relevant theory is described in <a href="https://arxiv.org/pdf/1901.01780">this research article</a>. There exists a Matlab implementation in <a href="https://tumcps.github.io/CORA/">CORA</a> &#40;the implementation of polynomial zonotopes can be found in <a href="https://github.com/TUMcps/CORA/tree/master/contSet/&#37;40polyZonotope">this folder</a>&#41;.</p> <p><strong>Mentors</strong>: <a href="https://github.com/mforets">Marcelo Forets</a>, <a href="https://github.com/schillic">Christian Schilling</a>.</p> <h2 id=improving_the_hybrid_systems_reachability_api ><a href="#improving_the_hybrid_systems_reachability_api">Improving the hybrid systems reachability API</a></h2> <p><strong>Difficulty</strong>: Hard.</p> <p><strong>Description.</strong> <a href="https://github.com/JuliaReach/ReachabilityAnalysis.jl">ReachabilityAnalysis</a> is a Julia library for set propagation of dynamical systems. One of the main aims is to handle systems with mixed discrete-continuous behaviors &#40;known as hybrid systems in the literature&#41;. This project will focus on enhancing the capabilities of the library and overall improvement of the ecosystem for users.</p> <p><strong>Expected Results.</strong> Specific tasks may include: problem-specific heuristics for hybrid systems; API for time-varying input sets; flowpipe underapproximations. The code is to be documented, tested, and evaluated in benchmarks. Integration with <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a> can also be considered if there is interest.</p> <p><strong>Expected Length.</strong> 350 hours.</p> <p><strong>Recommended Skills.</strong> Familiarity with Julia and Git/GitHub is mandatory. Familiarity with <a href="https://github.com/JuliaReach/LazySets.jl">LazySets</a> and <a href="https://github.com/JuliaReach/ReachabilityAnalysis.jl">ReachabilityAnalysis</a> is also required.</p> <p><strong>Mentors</strong>: <a href="https://github.com/mforets">Marcelo Forets</a>, <a href="https://github.com/schillic">Christian Schilling</a>.</p> <h1 id=juliastats_projects_summer_of_code ><a href="#juliastats_projects_summer_of_code">JuliaStats Projects – Summer of Code</a></h1> <p><a href="https://github.com/JuliaStats">JuliaStats</a> is an organization dedicated to providing high-quality packages for statistics in Julia.</p> <h2 id=panel_data_analysis ><a href="#panel_data_analysis">Panel data analysis</a></h2> <p>Implement panel analysis models and estimators in Julia.</p> <p><strong>Difficulty.</strong> Moderate. <strong>Duration.</strong> 350 hours</p> <h3 id=description__9 ><a href="#description__9">Description</a></h3> <p>Panel data is an important kind of statistical data that deals with observations of multiple units across time. Common examples of panel data include economic statistics &#40;where it is common to observe figures for several countries over time&#41;. This combination of longitudinal and cross-sectional data can be powerful for extracting causal structure from data.</p> <p><strong>Mentors.</strong> <a href="https://github.com/nilshg">Nils Gudat</a>, <a href="https://github.com/Nosferican">José Bayoán Santiago Calderón</a>, <a href="https://github.com/ParadaCarleton/">Carlos Parada</a></p> <h3 id=prerequisites__9 ><a href="#prerequisites__9">Prerequisites</a></h3> <ul> <li><p>Must be fluent in at least one language for statistical computing, and willing to learn Julia before the start of projects.</p> <li><p>Knowledge of basic statistical inference covering topics such as maximum likelihood estimation, confidence intervals, and hypothesis testing. &#40;Must know before applying.&#41;</p> <li><p>Basic familiarity with time series statistics &#40;e.g. ARIMA models, autocorrelations&#41; or panel data. &#40;Can be learned after applying.&#41;</p> </ul> <h3 id=your_contribution__9 ><a href="#your_contribution__9">Your contribution</a></h3> <p>Participants will:</p> <ul> <li><p>Learn and build on past approaches and packages for panel data analysis, such as those in <a href="https://github.com/Nosferican/Econometrics.jl">Econometrics.jl</a> and <a href="https://github.com/nilshg/SynthControl.jl">SynthControl.jl</a>.</p> <li><p>Generalize <a href="https://github.com/nilshg/TreatmentPanels.jl">TreatmentPanels.jl</a> into an abstract interface for dealing with and manipulating panel data.</p> <li><p>Integrate existing estimators provided by packages such as Econometrics.jl into a single package for panel data estimation.</p> </ul> <h3 id=references__10 ><a href="#references__10">References</a></h3> <ul> <li><p><a href="http://web.pdx.edu/~crkl/ec510/pda_yaffee.pdf">A Primer for Panel Data Analysis</a></p> <li><p><a href="https://mitpress.mit.edu/books/econometric-analysis-cross-section-and-panel-data-second-edition">Econometric Analysis of Cross Section and Panel Data</a> by Jeffrey Wooldridge</p> </ul> <h2 id=crraojl ><a href="#crraojl">CRRao.jl</a></h2> <p>Implement consistent APIs for statistical modeling in Julia. </p> <p><strong>Difficulty.</strong> Medium. <strong>Duration.</strong> 350 hours</p> <h3 id=description__10 ><a href="#description__10">Description</a></h3> <p>Currently, the Julia statistics ecosystem is quite fragmented. There is value in having a consistent API for a wide variety of statistical models. The <a href="https://github.com/xKDR/CRRao.jl">CRRao.jl</a> package offers this design. We have built several models with this interface, but there is still work to be done here.</p> <p><strong>Mentors.</strong> <a href="https://www.cmi.ac.in/~sourish/">Sourish Das</a>, <a href="https://github.com/ayushpatnaikgit">Ayush Patnaik</a>, <a href=""></a></p> <h3 id=prerequisites__10 ><a href="#prerequisites__10">Prerequisites</a></h3> <ul> <li><p>Must be fluent in Julia.</p> <li><p>Knowledge of basic statistical inference covering topics such as maximum likelihood estimation, confidence intervals, and hypothesis testing. &#40;Must know before applying.&#41;</p> </ul> <h3 id=your_contribution__10 ><a href="#your_contribution__10">Your contribution</a></h3> <p>Participants will:</p> <ul> <li><p>Help create, test, and document standard statistical APIs for Julia.</p> </ul> <h2 id=juliastats_improvements ><a href="#juliastats_improvements">JuliaStats Improvements </a></h2> <p>General improvements to JuliaStats packages, depending on the interests of participants.</p> <p><strong>Difficulty.</strong> Easy-Hard. <strong>Duration.</strong> 175-350 hours.</p> <h3 id=description__11 ><a href="#description__11">Description</a></h3> <p>JuliaStats provides many of the most popular packages in Julia, including:</p> <ul> <li><p>StatsBase.jl for basic statistics &#40;e.g. weights, sample statistics, moments&#41;. </p> <li><p>MixedModels.jl for random and mixed-effects linear models. </p> <li><p>GLM.jl for generalized linear models. </p> </ul> <p>All of these packages are critically important to the Julia statistics community, and all could be improved.</p> <p><strong>Mentors.</strong> Mousum Dutta, <a href="https://github.com/chiraganand">Chirag Anand</a>, <a href="https://github.com/ayushpatnaikgit">Ayush Patnaik</a>, <a href="https://github.com/ayushpatnaikgit">Carlos Parada</a></p> <h3 id=prerequisites__11 ><a href="#prerequisites__11">Prerequisites</a></h3> <ul> <li><p>Must be fluent in at least one language for statistical computing, and willing to learn Julia before the start of projects.</p> <li><p>Knowledge of basic statistical inference covering topics such as maximum likelihood estimation, confidence intervals, and hypothesis testing. &#40;Must know before applying.&#41;</p> </ul> <h3 id=your_contribution__11 ><a href="#your_contribution__11">Your contribution</a></h3> <p>Participants will:</p> <ul> <li><p>Make JuliaStats better&#33; This can include additional estimators, new features, performance improvements, or anything else you&#39;re interested in.</p> <li><p>StatsBase.jl improvements could include support for cumulants, L-moments, or additional estimators.</p> <li><p>Distributions.jl improvements could include support for new distributions &#40;e.g. elliptical distributions&#41;, additional parametrizations and keyword constructors for current distributions, or extending support for distributions of transformed variables.</p> <li><p>Improved nonparametric density estimators, e.g. those in R&#39;s <a href="https://cran.r-project.org/web/packages/locfit/index.html">Locfit</a> or <a href="https://www.sciencedirect.com/science/article/pii/S0167947320301511">log-spline estimators</a>.</p> <li><p>Packages to support survey statistics, similar to R&#39;s <a href="https://cran.r-project.org/web/packages/survey/index.html">survey</a> package.</p> </ul> <h1 id=stochastic_differential_equations_and_continuous_time_signal_processing_summer_of_code ><a href="#stochastic_differential_equations_and_continuous_time_signal_processing_summer_of_code">Stochastic differential equations and continuous time signal processing – Summer of Code</a></h1> <h2 id=smoothing_non-linear_continuous_time_systems ><a href="#smoothing_non-linear_continuous_time_systems">Smoothing non-linear continuous time systems</a></h2> <p>The contributor implements a state of the art smoother for continuous-time systems with additive Gaussian noise. The system&#39;s dynamics can be described as an ordinary differential equation with locally additive Gaussian random fluctuations, in other words a stochastic ordinary differential equation.</p> <p>Given a series of measurements observed over time, containing statistical noise and other inaccuracies, the task is to produce an estimate of the unknown trajectory of the system that led to the observations.</p> <p><em>Linear</em> continuous-time systems are smoothed with the fixed-lag Kalman-Bucy smoother &#40;related to the <a href="https://en.wikipedia.org/wiki/Kalman_filter#Kalman–Bucy_filter">Kalman–Bucy_filter</a>&#41;. It relies on coupled ODEs describing how mean and covariance of the conditional distribution of the latent system state evolve over time. A versatile implementation in Julia is missing.</p> <p><strong>Expected Results</strong>: Build efficient implementation of non-linear smoothing of continuous stochastic dynamical systems.</p> <p><strong>Recommended Skills</strong>: Gaussian random variables, Bayes&#39; formula, Stochastic Differential Equations</p> <p><strong>Mentors</strong>: <a href="https://github.com/mschauer">Moritz Schauer</a></p> <p><strong>Rating</strong>: Hard, 350 hours</p> <h1 id=loop_optimization_projects ><a href="#loop_optimization_projects">Loop Optimization projects</a></h1> <p>LoopModels is the successor to <a href="https://github.com/JuliaSIMD/LoopVectorization.jl">LoopVectorization.jl</a>, supporting more sophisticated analysis and transforms so that it may correctly optimize a much broader set of loop nests. It uses an internal representation of loops that represents the iteration space of each constituent operation as well as their dependencies. The iteration spaces of inner loops are allowed to be functions of the outer loops, and multiple loops are allowed to exist at each level of a loopnest. LoopModels aims to support optimizations including fusion, splitting, permuting loops, unrolling, and vectorization to maximize throughput. Broadly, this functionality can be divided into five pieces:</p> <ol> <li><p>The Julia interface / support for custom LLVM pipelines.</p> <li><p>The internal representation of the loops &#40;Loop IR&#41;.</p> <li><p>Building the internal representation from LLVM IR.</p> <li><p>Analyze the representation to determine an optimal, correct, and target-specific schedule.</p> <li><p>Transform the IR according to the schedule.</p> </ol> <p>Open projects on this effort include:</p> <h2 id=developing_a_julia_pluginfrontend_allowing_the_application_of_a_custom_compiler_pipeline ><a href="#developing_a_julia_pluginfrontend_allowing_the_application_of_a_custom_compiler_pipeline">Developing a Julia plugin/frontend allowing the application of a custom compiler pipeline</a></h2> <p><strong>Difficulty</strong>: Hard.</p> <p><strong>Description</strong>: In order to be able to use LoopModels from Julia, we must be able to apply a custom pass pipeline. This is likely something other packages will want to be able to do in the future, and something some packages &#40;<a href="https://github.com/wsmoses/Enzyme.jl">Enzyme.jl</a>&#41; do already. In this project, your aim will be to create a package that provides infrastructure others can depend on to simplify applying custom pass pipelines.</p> <p><strong>Expected Results</strong>: Register a package that allows applying custom LLVM pass pipelines to Julia code.</p> <p><strong>Skills</strong>: Julia programming, preferably with some understanding of Julia&#39;s IR. Prior familiarity with libraries such as <a href="https://github.com/JuliaGPU/GPUCompiler.jl">GPUCompiler</a> and <a href="https://github.com/tshort/StaticCompiler.jl">StaticCompiler</a> a bonus.</p> <p><strong>Expected Length</strong>: 175 hours.</p> <h2 id=developing_loop_models_350_hours ><a href="#developing_loop_models_350_hours">Developing Loop Models &#40;350 hours&#41;:</a></h2> <p><strong>Difficulty</strong>: Medium.</p> <p><strong>Description</strong>: This is open ended, with many potential projects here. These range from using <a href="https://dl.acm.org/doi/10.1145/3485539">Presburger arithmetic</a> to <a href="https://lirias.kuleuven.be/retrieve/361209">support decidable polyhedral modeling</a>, working on canonicalizations to handle more kinds of loops frequently encountered from Julia &#40;e.g. from <code>CartesianIndicies</code>&#41;, modeling the costs of different schedules, to efficiently searching the iteration space and find the fastest way to evaluate a loop nest. We can discuss your interests and find a task you&#39;ll enjoy and make substantive contributions to.</p> <p><strong>Expected Results</strong>: Help develop some aspect of the loop modeling and/or optimization.</p> <p><strong>Skills</strong>: C&#43;&#43;, knowledge of LLVM, loop optimization, SIMD, and optimizing compute kernels such as GEMM preferred. A passion for performance is a must&#33;</p> <p><strong>Expected Length</strong>: 350 hours.</p> <p>Mentors: <a href="https://github.com/chriselrod">Chris Elrod</a>, <a href="https://github.com/YingboMa">Yingbo Ma</a>.</p> <h1 id=machine_learning_projects_-_summer_of_code ><a href="#machine_learning_projects_-_summer_of_code">Machine Learning Projects - Summer of Code</a></h1> <h3 id=cuda_hacking ><a href="#cuda_hacking">CUDA Hacking</a></h3> <p>Time: 175h</p> <p>Are you a performance nut? This project is aimed at expanding our coverage of high performance kernels and libraries widely used across machine learning workflows. </p> <h4 id=expected_outcomes ><a href="#expected_outcomes">Expected Outcomes</a></h4> <p>Help us implement cutting-edge CUDA kernels in Julia for operations important across deep learning, scientific computing and more. We also need help developing our wrappers for machine learning, sparse matrices and more, as well as CI and infrastructure. Contact us to develop a project plan.</p> <p>Mentors: <a href="https://github.com/maleadt">Tim Besard</a>, <a href="https://github.com/DhairyaLGandhi">Dhairya Gandhi</a>.</p> <h3 id=reinforcement_learning_environments ><a href="#reinforcement_learning_environments">Reinforcement Learning Environments</a></h3> <p>Time: 175h</p> <p>Develop a series of reinforcement learning environments, in the spirit of the <a href="https://gym.openai.com">OpenAI Gym</a>. Although we have wrappers for the gym available, it is hard to install &#40;due to the Python dependency&#41; and, since it&#39;s written in Python and C code, we can&#39;t do more interesting things with it &#40;such as differentiate through the environments&#41;.</p> <h4 id=expected_outcome__2 ><a href="#expected_outcome__2">Expected outcome</a></h4> <p>A pure-Julia version of selected environments that supports a similar API and visualisation options would be valuable to anyone doing RL with Flux.</p> <p>Mentors: <a href="https://github.com/DhairyaLGandhi/">Dhairya Gandhi</a>.</p> <h3 id=reinforcement_learning_algorithms ><a href="#reinforcement_learning_algorithms">Reinforcement Learning Algorithms</a></h3> <p>Recent advances in reinforcement learning led to many breakthroughs in artificial intelligence. Some of the latest deep reinforcement learning algorithms have been implemented in <a href="https://github.com/JuliaReinforcementLearning/ReinforcementLearning.jl">ReinforcementLearning.jl</a> with Flux. We&#39;d like to have more interesting and practical algorithms added to enrich the whole community, including but not limited to the following directions:</p> <ul> <li><p><strong>&#91;Easy&#40;175h&#41;&#93; Recurrent version of existing algorithms</strong>. Contributors with a basic understanding of Q-learning and recurrent neural networks are preferred. We&#39;d like to have a general implementation to easily extend existing algorithms to the sequential version.</p> <li><p><strong>&#91;Medium&#40;175h&#41;&#93; Multi-agent reinforcement learning algorithms</strong>. Currently, we only have some CFR， MADDPG and NFSP related algorithms implemented. We&#39;d like to see more implemented, including <a href="https://arxiv.org/abs/1705.08926">COMA</a> and its variants, <a href="https://arxiv.org/abs/1711.00832">PSRO</a>.</p> <li><p><strong>&#91;Medium&#40;350h&#41;&#93; Model-based reinforcement learning algorithms</strong>. Contributors interested in this topic may refer <a href="https://arxiv.org/abs/2006.16712">Model-based Reinforcement Learning: A Survey</a> and design some general interfaces to implement typical model based algorithms.</p> <li><p><strong>&#91;Hard&#40;350h&#41;&#93; Distributed reinforcement learning framework</strong>. Inspired by <a href="https://arxiv.org/abs/2006.00979">Acme</a>, a similar design is proposed in <a href="https://github.com/JuliaReinforcementLearning/DistributedReinforcementLearning.jl">DistributedReinforcementLearning.jl</a>. However, it is still in a very early stage. Contributors interested in this direction are required to have a basic understanding of distributed computing in Julia. Ideally we&#39;d like to see some distributed reinforcement learning algorithms implemented under this framework, like <a href="https://openreview.net/forum?id&#61;r1lyTjAqYX&amp;utm_campaign&#61;RL&#37;20Weekly&amp;utm_medium&#61;email&amp;utm_source&#61;Revue&#37;20newsletter">R2D2</a>, <a href="https://arxiv.org/abs/1804.08617v1">D4PG</a>.</p> </ul> <h4 id=expected_outcomes__2 ><a href="#expected_outcomes__2">Expected Outcomes</a></h4> <p>For each new algorithm, at least two experiments are expected to be added into <a href="https://github.com/JuliaReinforcementLearning/ReinforcementLearningZoo.jl">ReinforcementLearningZoo.jl</a>. A simple one to make sure it works on some toy games with CPU only and another more practical one to produce comparable results on the original paper with GPU enabled. Besides, a technical report on the implementation details and speed/performance comparison with other baselines is preferred.</p> <p>Mentors: <a href="https://github.com/findmyway">Jun Tian</a></p> <h3 id=alphazerojl ><a href="#alphazerojl">AlphaZero.jl</a></h3> <p>The philosophy of the <a href="https://github.com/jonathan-laurent/AlphaZero.jl">AlphaZero.jl</a> project is to provide an implementation of AlphaZero that is simple enough to be widely accessible for contributors and researchers, while also being sufficiently powerful and fast to enable meaningful experiments on limited computing resources &#40;our latest release is consistently between one and two orders of magnitude faster than competing Python implementations&#41;.</p> <p>Here are a few project ideas that build on AlphaZero.jl. Please contact us for additional details and let us know about your experience and interests so that we can build a project that best suits your profile.</p> <ul> <li><p>&#91;Easy &#40;175h&#41;&#93; Integrate AlphaZero.jl with the <a href="https://github.com/JuliaReinforcementLearning/OpenSpiel.jl">OpenSpiel</a> game library and benchmark it on a series of simple board games.</p> <li><p>&#91;Medium &#40;175h&#41;&#93; Use AlphaZero.jl to train a chess agent. In order to save computing resources and allow faster bootstrapping, you may train an initial policy using supervised learning.</p> <li><p>&#91;Hard &#40;350h&#41;&#93; Build on AlphaZero.jl to implement the <a href="https://deepmind.com/blog/article/muzero-mastering-go-chess-shogi-and-atari-without-rules">MuZero</a> algorithm.</p> <li><p>&#91;Hard &#40;350h&#41;&#93; Explore applications of AlphaZero beyond board games &#40;e.g. theorem proving, chip design, chemical synthesis...&#41;.</p> </ul> <h4 id=expected_outcomes__3 ><a href="#expected_outcomes__3">Expected Outcomes</a></h4> <p>In all these projects, the goal is not only to showcase the current Julia ecosystem and test its limits, but also to push it forward through concrete contributions that other people can build on. Such contributions include:</p> <ul> <li><p>Improvements to existing Julia packages &#40;e.g. AlphaZero, ReinforcementLearning, CommonRLInterface, Dagger, Distributed, CUDA...&#41; through code, documentation or benchmarks.</p> <li><p>A well-documented and replicable artifact to be added to <a href="https://github.com/jonathan-laurent/AlphaZero.jl/tree/master/games">AlphaZero.Examples</a>, <a href="https://github.com/JuliaReinforcementLearning/ReinforcementLearningZoo.jl">ReinforcementLearningZoo</a> or released in its own package.</p> <li><p>A blog post that details your experience, discusses the challenges you went through and identifies promising areas for future work.</p> </ul> <p><strong>Mentors</strong>: <a href="https://github.com/jonathan-laurent">Jonathan Laurent</a></p> <h1 id=molecular_simulation_-_summer_of_code ><a href="#molecular_simulation_-_summer_of_code">Molecular Simulation - Summer of Code</a></h1> <p>Much of science can be explained by the movement and interaction of molecules. Molecular dynamics &#40;MD&#41; is a computational technique used to explore these phenomena, from noble gases to biological macromolecules. <a href="https://github.com/JuliaMolSim/Molly.jl">Molly.jl</a> is a pure Julia package for MD, and for the simulation of physical systems more broadly. The package is currently under development for research with a focus on proteins and differentiable molecular simulation. There are a number of ways that the package could be improved:</p> <ul> <li><p><strong>Adding simulators &#40;duration: 175h, expected difficulty: easy to medium&#41;:</strong> a variety of standard approaches to simulating molecules can be added including Langevin dynamics, FIRE minimisation, pressure coupling &#40;NPT ensemble&#41; and enhanced sampling approaches such as replica-exchange MD &#40;REMD&#41;.</p> <li><p><strong>Adding constraint algorithms &#40;duration: 175h, expected difficulty: medium&#41;:</strong> many simulations keep fast degrees of freedom such as bond lengths and bond angles fixed using approaches such as SHAKE, RATTLE and SETTLE. A fast implementation of these algorithms would be a valuable contribution.</p> <li><p><strong>Adding electrostatic summation &#40;duration: 175h, expected difficulty: medium to hard&#41;:</strong> methods such as particle-mesh Ewald &#40;PME&#41; are in wide use for molecular simulation. Developing fast, flexible implementations and exploring compatibility with GPU acceleration and automatic differentiation would be an <a href="https://discourse.julialang.org/t/electrostatics-in-julia/41633">important contribution</a>.</p> </ul> <p><strong>Recommended skills:</strong> familiarity with computational chemistry, structural bioinformatics or simulating physical systems.</p> <p><strong>Expected results:</strong> new features added to the package along with tests and relevant documentation.</p> <p><strong>Mentor:</strong> <a href="https://github.com/jgreener64">Joe Greener</a></p> <p><strong>Contact:</strong> feel free to ask questions via <a href="http://jgreener64.github.io">email</a> or the <a href="https://join.slack.com/t/juliamolsim/shared_invite/zt-tc060co0-HgiKApazzsQzBHDlQ58A7g">JuliaMolSim Slack</a>.</p> <h1 id=numerical_projects_summer_of_code ><a href="#numerical_projects_summer_of_code">Numerical Projects – Summer of Code</a></h1> <div class=franklin-toc ><ol><li><a href="#view_all_gsocjsoc_projects">View all GSoC/JSoC Projects</a><li><a href="#projects">Projects</a><ol><li><a href="#list_of_projects">List of projects</a></ol><li><a href="#machine_learning_in_predictive_survival_analysis">Machine Learning in Predictive Survival Analysis</a><ol><li><a href="#description">Description</a><li><a href="#prerequisites">Prerequisites</a><li><a href="#your_contribution">Your contribution</a><li><a href="#references">References</a></ol><li><a href="#feature_transformations">Feature transformations</a><ol><li><a href="#description__2">Description</a><li><a href="#prerequisites__2">Prerequisites</a><li><a href="#your_contribution__2">Your contribution</a><li><a href="#references__2">References</a></ol><li><a href="#time_series_forecasting_at_scale_-_speed_up_via_julia">Time series forecasting at scale - speed up via Julia</a><ol><li><a href="#prerequisites__3">Prerequisites</a><li><a href="#your_contribution__3">Your contribution</a><li><a href="#references__3">References</a></ol><li><a href="#interpretable_machine_learning_in_julia">Interpretable Machine Learning in Julia</a><ol><li><a href="#description__3">Description</a><li><a href="#prerequisites__4">Prerequisites</a><li><a href="#your_contribution__4">Your contribution</a><li><a href="#references__4">References</a></ol><li><a href="#model_visualization_in_mlj">Model visualization in MLJ</a><ol><li><a href="#description__4">Description</a><li><a href="#prerequisites__5">Prerequisites</a><li><a href="#your_contribution__5">Your contribution</a><li><a href="#references__5">References</a></ol><li><a href="#deeper_bayesian_integration">Deeper Bayesian Integration</a><ol><li><a href="#description__5">Description</a><li><a href="#your_contributions">Your contributions</a><li><a href="#references__6">References</a><li><a href="#difficulty_medium_to_hard">Difficulty: Medium to Hard</a></ol><li><a href="#tracking_and_sharing_mlj_workflows_using_mlflow">Tracking and sharing MLJ workflows using MLFlow</a><ol><li><a href="#description__6">Description</a><li><a href="#prerequisites__6">Prerequisites</a><li><a href="#your_contribution__6">Your contribution</a><li><a href="#references__7">References</a></ol><li><a href="#speed_demons_only_need_apply">Speed demons only need apply</a><ol><li><a href="#description__7">Description</a><li><a href="#prerequisites__7">Prerequisites</a><li><a href="#your_contribution__7">Your contribution</a><li><a href="#references__8">References</a></ol><li><a href="#correcting_for_class_imbalance_in_classification_problems">Correcting for class imbalance in classification problems</a><ol><li><a href="#description__8">Description</a><li><a href="#prerequisites__8">Prerequisites</a><li><a href="#your_contribution__8">Your contribution</a><li><a href="#references__9">References</a></ol><li><a href="#improving_test_coverage_350_hours">Improving test coverage &#40;350 hours&#41;</a><li><a href="#multi-threading_improvement_projects_350_hours">Multi-threading Improvement Projects &#40;350 hours&#41;</a><li><a href="#automation_of_testing_performance_benchmarking_350_hours">Automation of testing / performance benchmarking &#40;350 hours&#41;</a><li><a href="#bringing_dftk_to_graphics-processing_units_gpus">Bringing DFTK to graphics-processing units &#40;GPUs&#41;</a><li><a href="#documenterjl">Documenter.jl</a><li><a href="#docsystem_api">Docsystem API</a><ol><li><a href="#metalheadjl_developement">Metalhead.jl Developement</a><li><a href="#fastaijl_time_series_development">FastAI.jl Time Series Development</a><li><a href="#fastaijl_text_development">FastAI.jl Text Development</a><li><a href="#differentiable_computer_vision">Differentiable Computer Vision</a><li><a href="#ferminets_generative_synthesis_for_automating_the_choice_of_neural_architectures">FermiNets: Generative Synthesis for Automating the Choice of Neural Architectures</a><li><a href="#differentiable_rendering">Differentiable Rendering</a><li><a href="#adding_graph_convolutional_layers">Adding graph convolutional layers </a><li><a href="#adding_models_and_examples">Adding models and examples</a><li><a href="#adding_graph_datasets">Adding graph datasets</a><li><a href="#supporting_heterogeneous_graphs">Supporting heterogeneous graphs</a><li><a href="#training_on_very_large_graphs">Training on very large graphs </a><li><a href="#supporting_temporal_graph_neural_networks">Supporting temporal graph neural networks</a><li><a href="#improving_performance_using_sparse_linear_algebra">Improving performance using sparse linear algebra </a></ol><li><a href="#recommended_skills">Recommended skills</a><li><a href="#mentors">Mentors </a><li><a href="#qml_and_makie_integration">QML and Makie integration</a><ol><li><a href="#expected_results">Expected results</a></ol><li><a href="#web_apps_in_makie_and_jsserve">Web apps in Makie and JSServe</a><ol><li><a href="#expected_results__2">Expected results</a></ol><li><a href="#scheduling_algorithms_for_distributed_algorithms">Scheduling algorithms for Distributed algorithms</a><li><a href="#distributed_training">Distributed Training</a><li><a href="#benchmarking_against_other_frameworks">Benchmarking against other frameworks</a><li><a href="#gpu_support_for_many_algorithms">GPU support for many algorithms</a><li><a href="#better_imageio_supports_open_ended">Better ImageIO supports &#40;open ended&#41;</a><li><a href="#exif_viewer">EXIF viewer</a><li><a href="#better_qr_code_support_open_ended">Better QR Code support &#40;open ended&#41;</a><li><a href="#where_to_go_for_discussion_and_to_find_mentors">Where to go for discussion and to find mentors</a><li><a href="#c">C&#43;&#43;</a><ol><li><a href="#cxxwrap_stl">CxxWrap STL</a><ol><li><a href="#expected_outcome">Expected outcome</a></ol></ol><li><a href="#rust">Rust</a><li><a href="#improve_javis_performance">Improve Javis Performance</a><li><a href="#building_novel_animation_abilities_for_javis">Building Novel Animation Abilities for Javis</a><li><a href="#agentsjl">Agents.jl</a><li><a href="#dynamicalsystemsjl">DynamicalSystems.jl</a><li><a href="#midification_of_music_from_wave_files">MIDIfication of music from wave files</a><li><a href="#efficient_low-dimensional_symbolic-numeric_set_computations">Efficient low-dimensional symbolic-numeric set computations</a><li><a href="#reachability_with_sparse_polynomial_zonotopes">Reachability with sparse polynomial zonotopes</a><li><a href="#improving_the_hybrid_systems_reachability_api">Improving the hybrid systems reachability API</a><li><a href="#panel_data_analysis">Panel data analysis</a><ol><li><a href="#description__9">Description</a><li><a href="#prerequisites__9">Prerequisites</a><li><a href="#your_contribution__9">Your contribution</a><li><a href="#references__10">References</a></ol><li><a href="#crraojl">CRRao.jl</a><ol><li><a href="#description__10">Description</a><li><a href="#prerequisites__10">Prerequisites</a><li><a href="#your_contribution__10">Your contribution</a></ol><li><a href="#juliastats_improvements">JuliaStats Improvements </a><ol><li><a href="#description__11">Description</a><li><a href="#prerequisites__11">Prerequisites</a><li><a href="#your_contribution__11">Your contribution</a></ol><li><a href="#smoothing_non-linear_continuous_time_systems">Smoothing non-linear continuous time systems</a><li><a href="#developing_a_julia_pluginfrontend_allowing_the_application_of_a_custom_compiler_pipeline">Developing a Julia plugin/frontend allowing the application of a custom compiler pipeline</a><li><a href="#developing_loop_models_350_hours">Developing Loop Models &#40;350 hours&#41;:</a><ol><li><a href="#cuda_hacking">CUDA Hacking</a><ol><li><a href="#expected_outcomes">Expected Outcomes</a></ol><li><a href="#reinforcement_learning_environments">Reinforcement Learning Environments</a><ol><li><a href="#expected_outcome__2">Expected outcome</a></ol><li><a href="#reinforcement_learning_algorithms">Reinforcement Learning Algorithms</a><ol><li><a href="#expected_outcomes__2">Expected Outcomes</a></ol><li><a href="#alphazerojl">AlphaZero.jl</a><ol><li><a href="#expected_outcomes__3">Expected Outcomes</a></ol></ol><li><a href="#numerical_linear_algebra">Numerical Linear Algebra</a><ol><li><a href="#matrix_functions">Matrix functions</a></ol><li><a href="#better_bignums_integration">Better Bignums Integration</a><ol><li><a href="#special_functions">Special functions</a><li><a href="#a_julia-native_ccsa_optimization_algorithm">A Julia-native CCSA optimization algorithm</a></ol><li><a href="#massive_parallel_factorized_bouncy_particle_sampler">Massive parallel factorized bouncy particle sampler</a><li><a href="#pluto_as_a_vs_code_notebook">Pluto as a VS Code notebook</a><li><a href="#tools_for_education">Tools for education</a><li><a href="#electron_app">Electron app</a><li><a href="#wrapping_a_rust_http_server_in_julia">Wrapping a Rust HTTP server in Julia</a><ol><li><a href="#introduction">Introduction</a><li><a href="#details">Details</a></ol><li><a href="#machine_learning_time_series_regression">Machine Learning Time Series Regression</a><li><a href="#machine_learning_for_nowcasting_and_forecasting">Machine learning for nowcasting and forecasting</a><li><a href="#time_series_forecasting_at_scales">Time series forecasting at scales</a><li><a href="#gpu_accelerated_simulator_of_clifford_circuits">GPU accelerated simulator of Clifford Circuits.</a><li><a href="#pauli_frames_for_faster_sampling">Pauli Frames for faster sampling.</a><li><a href="#a_zoo_of_quantum_error_correcting_codes">A Zoo of Quantum Error Correcting codes.</a><li><a href="#leftright_multiplications_with_small_gates">Left/Right multiplications with small gates.</a><li><a href="#symbolic_root_finding">Symbolic root finding</a><li><a href="#symbolic_integration_in_symbolicsjl">Symbolic Integration in Symbolics.jl</a><li><a href="#xla-style_optimization_from_symbolic_tracing">XLA-style optimization from symbolic tracing</a><li><a href="#automatically_improving_floating_point_accuracy_herbie">Automatically improving floating point accuracy &#40;Herbie&#41;</a><li><a href="#implement_flashfill_in_julia">Implement Flashfill in Julia </a><li><a href="#parquetjl_enhancements">Parquet.jl enhancements</a><li><a href="#statistical_transforms">Statistical transforms</a><li><a href="#utility_transforms">Utility transforms</a><li><a href="#how_to_get_started">How to get started?</a><li><a href="#machine_learning_in_topology_optimisation">Machine learning in topology optimisation</a><li><a href="#multi-material_design_representation">Multi-material design representation</a><li><a href="#optimisation_on_a_uniform_rectilinear_grid">Optimisation on a uniform rectilinear grid</a><li><a href="#adaptive_mesh_refinement_for_topology_optimisation">Adaptive mesh refinement for topology optimisation</a><li><a href="#heat_transfer_design_optimisation">Heat transfer design optimisation</a><li><a href="#more_real-world_bayesian_models_in_turing_julia">More real-world Bayesian models in Turing / Julia</a><li><a href="#improving_the_integration_between_turing_and_turings_mcmc_inference_packages">Improving the integration between Turing and Turing&#39;s MCMC inference packages</a><li><a href="#directed-graphical_model_support_for_the_abstract_probabilistic_programming_library">Directed-graphical model support for the abstract probabilistic programming library</a><li><a href="#a_modular_tape_caching_mechanism_for_reversediff">A modular tape caching mechanism for ReverseDiff</a><li><a href="#benchmarking_improving_performance_of_the_juliagaussianprocesses_libraries">Benchmarking &amp; improving performance of the JuliaGaussianProcesses libraries</a><li><a href="#iterative_methods_for_inference_in_gaussian_processes">Iterative methods for inference in Gaussian Processes</a><li><a href="#approximate_inference_methods_for_non-gaussian_likelihoods_in_gaussian_processes">Approximate inference methods for non-Gaussian likelihoods in Gaussian Processes</a><li><a href="#gpu_integration_in_the_juliagps_ecosystem">GPU integration in the JuliaGPs ecosystem</a><li><a href="#vs_code_extension">VS Code extension</a><li><a href="#package_installation_ui">Package installation UI</a><li><a href="#code_generation_improvements_and_async_abi">Code generation improvements and async ABI</a><li><a href="#wasm_threading">Wasm threading</a><li><a href="#high_performance_low-level_integration_of_js_objects">High performance, Low-level integration of js objects</a><li><a href="#dom_integration">DOM Integration</a><li><a href="#porting_existing_web-integration_packages_to_the_wasm_platform">Porting existing web-integration packages to the wasm platform</a><li><a href="#native_dependencies_for_the_web">Native dependencies for the web</a><li><a href="#distributed_computing_with_untrusted_parties">Distributed computing with untrusted parties</a><li><a href="#deployment">Deployment</a></ol></div> <h2 id=numerical_linear_algebra ><a href="#numerical_linear_algebra">Numerical Linear Algebra</a></h2> <h3 id=matrix_functions ><a href="#matrix_functions">Matrix functions</a></h3> <p>Matrix functions map matrices onto other matrices, and can often be interpreted as generalizations of ordinary functions like sine and exponential, which map numbers to numbers. Once considered a niche province of numerical algorithms, matrix functions now appear routinely in applications to cryptography, aircraft design, nonlinear dynamics, and finance.</p> <p>This project proposes to implement state of the art algorithms that extend the currently available matrix functions in Julia, as outlined in issue <a href="https://github.com/JuliaLang/julia/issues/5840">#5840</a>. In addition to matrix generalizations of standard functions such as real matrix powers, surds and logarithms, contributors will be challenged to design generic interfaces for lifting general scalar-valued functions to their matrix analogues for the efficient computation of arbitrary &#40;well-behaved&#41; matrix functions and their derivatives.</p> <p><strong>Recommended Skills</strong>: A strong understanding of calculus and numerical analysis.</p> <p><strong>Expected Results</strong>: New and faster methods for evaluating matrix functions.</p> <p><strong>Mentors:</strong> <a href="https://github.com/jiahao">Jiahao Chen</a>, <a href="https://github.com/stevengj">Steven Johnson</a>.</p> <p><strong>Difficulty:</strong> Hard</p> <h2 id=better_bignums_integration ><a href="#better_bignums_integration">Better Bignums Integration</a></h2> <p>Julia currently supports big integers and rationals, making use of the GMP. However, GMP currently doesn&#39;t permit good integration with a garbage collector.</p> <p>This project therefore involves exploring ways to improve BigInt, possibly including:</p> <div class=tight-list ><ul> <li><p>Modifying GMP to support high-performance garbage-collection</p> <li><p>Reimplementation of aspects of BigInt in Julia</p> <li><p>Lazy graph style APIs which can rewrite terms or apply optimisations</p> </ul></div> <p>This experimentation could be carried out as a package with a new implementation, or as patches over the existing implementation in Base.</p> <p><strong>Expected Results</strong>: An implementation of BigInt in Julia with increased performance over the current one.</p> <p><strong>Require Skills</strong>: Familiarity with extended precision numerics OR performance considerations. Familiarity either with Julia or GMP.</p> <p><strong>Mentors</strong>: <a href="https://github.com/vtjnash">Jameson Nash</a></p> <p><strong>Difficulty:</strong> Hard</p> <h3 id=special_functions ><a href="#special_functions">Special functions</a></h3> <p>As a technical computing language, Julia provides a huge number of <a href="https://en.wikipedia.org/wiki/Special_functions">special functions</a>, both in Base as well as packages such as <a href="https://github.com/JuliaStats/StatsFuns.jl">StatsFuns.jl</a>. At the moment, many of these are implemented in external libraries such as <a href="https://github.com/JuliaLang/Rmath-julia">Rmath</a> and <a href="https://github.com/JuliaLang/openspecfun">openspecfun</a>. This project would involve implementing these functions in native Julia &#40;possibly utilising the work in <a href="https://github.com/nolta/SpecialFunctions.jl">SpecialFunctions.jl</a>&#41;, seeking out opportunities for possible improvements along the way, such as supporting <code>Float32</code> and <code>BigFloat</code>, exploiting fused multiply-add operations, and improving errors and boundary cases.</p> <p><strong>Recommended Skills</strong>: A strong understanding of calculus.</p> <p><strong>Expected Results</strong>: New and faster methods for evaluating properties of special functions.</p> <p><strong>Mentors:</strong> <a href="https://github.com/stevengj">Steven Johnson</a>, <a href="https://github.com/oscardssmith">Oscar Smith</a>. Ask on Discourse or on slack</p> <h3 id=a_julia-native_ccsa_optimization_algorithm ><a href="#a_julia-native_ccsa_optimization_algorithm">A Julia-native CCSA optimization algorithm</a></h3> <p>The CCSA algorithm by <a href="https://epubs.siam.org/doi/10.1137/S1052623499362822">Svanberg &#40;2001&#41;</a> is a <a href="https://en.wikipedia.org/wiki/Nonlinear_programming">nonlinear programming algorithm</a> widely used in <a href="https://en.wikipedia.org/wiki/Topology_optimization">topology optimization</a> and for other large-scale optimization problems: it is a robust algorithm that can handle arbitrary nonlinear inequality constraints and huge numbers of degrees of freedom. Moreover, the relative simplicity of the algorithm makes it possible to easily incorporate sparsity in the Jacobian matrix &#40;for handling huge numbers of constraints&#41;, approximate-Hessian preconditioners, and as special-case optimizations for affine terms in the objective or constraints. However, currently it is only available in Julia via the <a href="https://github.com/JuliaOpt/NLopt.jl">NLopt.jl</a> interface to an external C implementation, which greatly limits its flexibility.</p> <p><strong>Recommended Skills</strong>: Experience with nonlinear optimization algorithms and understanding of <a href="https://en.wikipedia.org/wiki/Duality_&#40;optimization&#41;">Lagrange duality</a>, familiarity with sparse matrices and other Julia data structures.</p> <p><strong>Expected Results</strong>: A package implementing a native-Julia CCSA algorithm.</p> <p><strong>Mentors:</strong> <a href="https://github.com/stevengj">Steven Johnson</a>.</p> <h1 id=event-chain_monte_carlo_methods_summer_of_code ><a href="#event-chain_monte_carlo_methods_summer_of_code">Event-chain Monte Carlo methods – Summer of Code</a></h1> <h2 id=massive_parallel_factorized_bouncy_particle_sampler ><a href="#massive_parallel_factorized_bouncy_particle_sampler">Massive parallel factorized bouncy particle sampler</a></h2> <p>At JuliaCon 2021 a new sampler Monte Carlo method &#40;for example as sampling algorithm for the posterior in Bayesian inference&#41; was introduced &#91;1&#93;. The method exploits the factorization structure to sample <em>a single</em> continuous time Markov chain targeting a joint distribution in parallel. In contrast to parallel Gibbs sampling in the method at no time a subset of coordinates is kept fixed. In Gibbs sampling keeping a subset fixed is the main device to achieve massive parallelism: given a separating set of coordinates, the conditional posterior factorizes into independent subproblems. In the presented method, a particle representing a parameter vector sampled from the posterior never ceases to move, and it is only the decisions about changes of the direction of the movement which happen in parallel on subsets of coordinates.</p> <p>There are already two implementations available which make use of Julias multithreading capabilities. Starting from that, the contributor implements a version of the algorithm using GPU computing techniques as the methods is are suitable for these approaches.</p> <p><strong>Expected Results</strong>: Implement massive parallel factorized bouncy particle sampler &#91;1,2&#93; using GPU computing.</p> <p><strong>Recommended Skills</strong>: GPU computing, Markov processes, Bayesian inference.</p> <p><strong>Mentors</strong>: <a href="https://github.com/mschauer">Moritz Schauer</a></p> <p><strong>Rating</strong>: Hard, 350 hours</p> <p>&#91;1&#93; Moritz Schauer: ZigZagBoomerang.jl - parallel inference and variable selection. JuliaCon 2021 contribution &#91;https://pretalx.com/juliacon2021/talk/LUVWJZ/&#93;, Youtube: &#91;https://www.youtube.com/watch?v&#61;wJAjP_I1BnQ&#93;, 2021.</p> <p>&#91;2&#93; Joris Bierkens, Paul Fearnhead, Gareth Roberts: The Zig-Zag Process and Super-Efficient Sampling for Bayesian Analysis of Big Data. The Annals of Statistics, 2019, 47. Vol., Nr. 3, pp. 1288-1320. &#91;https://arxiv.org/abs/1607.03188&#93;.</p> <h1 id=plutojl_projects ><a href="#plutojl_projects">Pluto.jl projects</a></h1> <h2 id=pluto_as_a_vs_code_notebook ><a href="#pluto_as_a_vs_code_notebook">Pluto as a VS Code notebook</a></h2> <p>VS Code is an extensible editor, and one of its most recent features is a notebook GUI, with a corresponding <a href="https://code.visualstudio.com/api/extension-guides/notebook">Notebook API</a>, allowing extension developers to write their own <em>notebook backend</em>. We want to combine two popular Julia IDEs: VS Code and Pluto.jl, and use it to provide a mature editing and debugging experience combined with Pluto&#39;s reactivity.</p> <p><strong>Expected Results:</strong> Reactive notebook built on top of VSCode&#39;s notebook API.</p> <p><strong>Required skills:</strong> JavaScript/TypeScript</p> <p><strong>Duration:</strong> 175 h</p> <p><strong>Difficulty:</strong> Medium</p> <p><strong>Mentors:</strong> <a href="https://github.com/pfitzseb">Sebastian Pfitzner</a> &#40;core maintainer of julia-vscode&#41;, <a href="https://github.com/pankgeorg">Panagiotis Georgakopoulos</a> and <a href="https://github.com/fonsp">Fons van der Plas</a> &#40;core maintainers of Pluto.jl&#41; and friends</p> <p><em>Also see the other <a href="https://julialang.org/jsoc/gsoc/vscode/">VS Code projects</a>&#33;</em></p> <h2 id=tools_for_education ><a href="#tools_for_education">Tools for education</a></h2> <p>Pluto&#39;s primary use case is education, and we recently started using Pluto notebooks as an &#39;interactive textbook&#39;: https://computationalthinking.mit.edu/ . If you are interested in design and interactive visualization, there are lots of cool JS projects in this area. Examples include:</p> <ul> <li><p>Linking video content to dynamic content, better integration between exercise and lecture material.</p> <li><p>Experiment with playing back the edits to a notebook session, like a video, but on a scrollable page. &#40;<a href="https://www.notion.so/malyvsen/Replay-notebook-computations-8bcd4787842e40a199806ebe1c368acb">link</a>&#41;.</p> <li><p>Syntax analysis to automatically review &#39;code style&#39;</p> <li><p>Improved live check and autograding tools</p> <li><p>And so on&#33; Take a look at our <a href="https://www.notion.so/malyvsen/Pluto-jl-a9982e79b7bb4c658e6216c15a9d4cab">project board</a> and get in touch if you have further ideas: fons@plutojl.org</p> </ul> <p><strong>Expected Results:</strong> <em>One</em> of the items above&#33; When finished, your work will be used in future editions of the Computational Thinking course and more&#33;</p> <p><strong>Required skills:</strong> JavaScript &amp; CSS. &#40;You can learn Julia as part of the project.&#41;</p> <p><strong>Duration:</strong> 175 h</p> <p><strong>Difficulty:</strong> Easy/Medium depending on the choice</p> <p><strong>Mentors:</strong> <a href="https://github.com/fonsp">Fons van der Plas</a>, <a href="https://github.com/ctrekker">Connor Burns</a> and fellow Pluto.jl maintainers, with feedback from <a href="https://math.mit.edu/directory/profile.php?pid&#61;63">Alan Edelman</a></p> <h2 id=electron_app ><a href="#electron_app">Electron app</a></h2> <p>Right now, <a href="">Pluto</a> is a <em>Julia package</em> with one function, <code>Pluto.run&#40;&#41;</code>:</p> <pre><code class=language-julia >julia&gt; using Pluto
julia&gt; Pluto.run&#40;&#41;

Welcome to Pluto&#33; Go to http://localhost:1234/ to start writing&#33;</code></pre> <p>This makes sense, because Pluto is written in Julia&#33; But for many people, the steps <em>install Julia, open a terminal, run the Julia REPL, use Pkg to install Pluto, import Pluto, run Pluto</em> are still much too intimidating. Ideally, we hope that Pluto will make scientific computing more accessible and fun for everyone, especially beginner students and programmers who might not have used a terminal before&#33;</p> <p>For this reason, we want Pluto to be a standalone <a href="https://www.electronjs.org/">Electron</a> app, just like VS Code, Slack, WhatsApp, GitHub Desktop, Atom, and many others. Pluto as a standalone app opens the door to a more smooth and uniform user experience across the board, through Electron&#39;s native file system capabilities, setting the app to open notebook files when double-clicked, and configurable automated updates for both Pluto and Julia.</p> <p>This project can be broken down into four smaller chunks.</p> <ol> <li><p>Serve Pluto&#39;s web files in Electron</p> <li><p>Get the Electron view talking with a local Pluto server</p> <li><p>Implement native file system features for Pluto in Electron</p> <li><p>Package the app into an easily installable binary &#40;exe for Windows, dmg for MacOS, etc.&#41;, with the Julia executable embedded.</p> </ol> <p><strong>Expected Results:</strong> An Electron app for editing Pluto.jl notebooks, with support for operating system-specific features like file open or double-click. </p> <p><strong>Required skills:</strong> JavaScript, NodeJS.</p> <p><strong>Duration:</strong> 175 h</p> <p><strong>Difficulty:</strong> Easy</p> <p><strong>Mentors:</strong> <a href="https://github.com/ctrekker">Connor Burns</a>, <a href="https://github.com/dralletje">Michiel Dral</a>, <a href="https://github.com/fonsp">Fons van der Plas</a> and fellow Pluto.jl maintainers</p> <h2 id=wrapping_a_rust_http_server_in_julia ><a href="#wrapping_a_rust_http_server_in_julia">Wrapping a Rust HTTP server in Julia</a></h2> <h3 id=introduction ><a href="#introduction">Introduction</a></h3> <p>Context: <em>Pluto is a notebook system written in Julia, which means that it runs an HTTP/WS web server in Julia. We currently use the <a href="https://github.com/JuliaWeb/HTTP.jl">HTTP.jl</a> for this, an ambitious project to write an HTTP server and client in pure Julia. While HTTP.jl works well in most scenarios, we still find that Pluto&#39;s connection is not always reliable. This is because people use Pluto on such a wide range of systems, with all kinds of network configurations, proxies, firewalls, browser interactions etc.</em> </p> <p>Looking for alternatives, we believe that, instead of using a pure-Julia implementation of HTTP, we should wrap around an existing, high-production web server like <a href="http://hyper.rs/">hyper.rs</a>. Julia has a rich history of wrapping libraries written in C, C&#43;&#43;, Python, Go, JS and more, and the package manager has first-class support for external binaries.</p> <h3 id=details ><a href="#details">Details</a></h3> <p>As a participant of this project, you will build on top of the Julia and Rust ecosystems. A potential starting point would be looking at the Deno <a href="https://github.com/denoland/deno/blob/2dc5dba8baf148a525cbb7987cdad0ba6398c5e4/ext/http/lib.rs">http server</a> implementation also built on top of hyper.rs. Initially, the goal would be to start using the <a href="https://docs.rs/hyper/latest/hyper/ffi/index.html">hyper C API</a> to interoperate with Julia &#40;there is already a <a href="https://github.com/JuliaBinaryWrappers/hyper_jll.jl">hyper_jll</a> package ❤ &#33;&#33;&#41;. Depending on the progress, another area of exploration is to investigate rustier tools like <a href="https://github.com/Taaitaaiger/jlrs">jlrs</a>.</p> <p><strong>Expected Results:</strong> A prototype of wrapping the <code>hyper</code> library in Julia, with a focus on reliability and efficiency, forming the basis of the package.</p> <p><strong>Required skills:</strong> Rust, some Julia experience, some previous experience with language interoperability or inter-process communication.</p> <p><strong>Duration:</strong> 175 h</p> <p><strong>Mentors:</strong> <a href="https://github.com/pangoraw">Paul Berg</a> and <a href="https://github.com/fonsp">Fons van der Plas</a></p> <p><strong>Difficulty:</strong> Hard</p> <h1 id=pythia_summer_of_code ><a href="#pythia_summer_of_code">Pythia – Summer of Code</a></h1> <h2 id=machine_learning_time_series_regression ><a href="#machine_learning_time_series_regression">Machine Learning Time Series Regression</a></h2> <p><a href="https://github.com/ababii/Pythia.jl">Pythia</a> is a package for scalable machine learning time series forecasting and nowcasting in Julia.</p> <p>The project mentors are <a href="https://ababii.github.io/">Andrii Babii</a> and <a href="https://www.turing.ac.uk/people/researchers/sebastian-vollmer/">Sebastian Vollmer</a>.</p> <h2 id=machine_learning_for_nowcasting_and_forecasting ><a href="#machine_learning_for_nowcasting_and_forecasting">Machine learning for nowcasting and forecasting</a></h2> <p>This project involves developing scalable machine learning time series regressions for nowcasting and forecasting. Nowcasting in economics is the prediction of the present, the very near future, and the very recent past state of an economic indicator. The term is a contraction of &quot;now&quot; and &quot;forecasting&quot; and originates in meteorology. </p> <p>The objective of this project is to introduce scalable regression-based nowcasting and forecasting methodologies that demonstrated the empirical success in data-rich environment recently. Examples of existing popular packages for regression-based nowcasting on other platforms include the &quot;MIDAS Matlab Toolbox&quot;, as well as the &#39;midasr&#39; and &#39;midasml&#39; packages in R. The starting point for this project is porting the &#39;midasml&#39; package from R to Julia. Currently Pythia has the sparse-group LASSO regression functionality for forecasting. </p> <p>The following functions are of interest: in-sample and out-of sample forecasts/nowcasts, regularized MIDAS with Legendre polynomials, visualization of nowcasts, AIC/BIC and time series cross-validation tuning, forecast evaluation, pooled and fixed effects panel data regressions for forecasting and nowcasting, HAC-based inference for sparse-group LASSO, high-dimensional Granger causality tests. Other widely used existing functions from R/Python/Matlab are also of interest.</p> <p><strong>Recommended skills:</strong> Graduate-level knowledge of time series analysis, machine learning, and optimization is helpful.</p> <p><strong>Expected output:</strong> The contributor is expected to produce code, documentation, visualization, and real-data examples.</p> <p><strong>References:</strong> Contact project mentors for references.</p> <h2 id=time_series_forecasting_at_scales ><a href="#time_series_forecasting_at_scales">Time series forecasting at scales</a></h2> <p>Modern business applications often involve forecasting hundreds of thousands of time series. Producing such a gigantic number of reliable and high-quality forecasts is computationally challenging, which limits the scope of potential methods that can be used in practice, see, e.g., the &#39;forecast&#39;, &#39;fable&#39;, or &#39;prophet&#39; packages in R. Currently, Julia lacks the scalable time series forecasting functionality and this project aims to develop the automated data-driven and scalable time series forecasting methods. </p> <p>The following functionality is of interest: forecasting intermittent demand &#40;Croston, adjusted Croston, INARMA&#41;, scalable seasonal ARIMA with covariates, loss-based forecasting &#40;gradient boosting&#41;, unsupervised time series clustering, forecast combinations, unit root tests &#40;ADF, KPSS&#41;. Other widely used existing functions from R/Python/Matlab are also of interest.</p> <p><strong>Recommended skills:</strong> Graduate-level knowledge of time series analysis is helpful.</p> <p><strong>Expected output:</strong> The contributor is expected to produce code, documentation, visualization, and real-data examples.</p> <p><strong>References:</strong> Contact project mentors for references.</p> <h1 id=tools_for_simulation_of_quantum_clifford_circuits ><a href="#tools_for_simulation_of_quantum_clifford_circuits">Tools for simulation of Quantum Clifford Circuits</a></h1> <p>Clifford circuits are a class of quantum circuits that can be simulated efficiently on a classical computer. As such, they do not provide the computational advantage expected of universal quantum computers. Nonetheless, they are extremely important, as they underpin most techniques for quantum error correction and quantum networking. Software that efficiently simulates such circuits, at the scale of thousands or more qubits, is essential to the design of quantum hardware. The <a href="https://github.com/Krastanov/QuantumClifford.jl">QuantumClifford.jl</a> Julia project enables such simulations.</p> <h2 id=gpu_accelerated_simulator_of_clifford_circuits ><a href="#gpu_accelerated_simulator_of_clifford_circuits">GPU accelerated simulator of Clifford Circuits.</a></h2> <p>Simulation of Clifford circuits involves significant amounts of linear algebra with boolean matrices. This enables the use of many standard computation accelerators like GPUs, as long as these accelerators support bit-wise operations. The main complications is that the elements of the matrices under consideration are usually packed in order to increase performance and lower memory usage, i.e. a vector of 64 elements would be stored as a single 64 bit integer instead of as an array of 64 bools. A Summer of Code project could consist of implement the aforementioned linear algebra operations in GPU kernels, and then seamlessly integrating them in the rest of the QuantumClifford library. At a minimum that would include <a href="https://github.com/Krastanov/QuantumClifford.jl/blob/v0.4.0/src/QuantumClifford.jl#L725">Pauli-Pauli products</a> and certain <a href="https://github.com/Krastanov/QuantumClifford.jl/blob/v0.4.0/src/symbolic_cliffords.jl">small Clifford operators</a>, but could extend to general <a href="https://github.com/Krastanov/QuantumClifford.jl/blob/v0.4.0/src/QuantumClifford.jl#L1385">stabilizer tableau multiplication</a> and even <a href="https://github.com/Krastanov/QuantumClifford.jl/blob/v0.4.0/src/QuantumClifford.jl#L985">tableau diagonalization</a>. </p> <p><strong>Recommended skills:</strong> Basic knowledge of the <a href="https://krastanov.github.io/QuantumClifford.jl/dev/references/">stabilizer formalism</a> used for simulating Clifford circuits. Familiarity with performance profiling tools in Julia and Julia&#39;s GPU stack, including <a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions</a> and <a href="https://github.com/mcabbott/Tullio.jl">Tullio</a>.</p> <p><strong>Mentors:</strong> <a href="https://github.com/Krastanov">Stefan Krastanov</a></p> <p><strong>Expected duration:</strong> 175 hours &#40;but applicants can scope it to a longer project by including work on GPU-accelerated Gaussian elimination used in the canonicalization routines&#41;</p> <p><strong>Difficulty:</strong> Medium if the applicant is familiar with Julia, even without understanding of Quantum Information Science &#40;but applicants can scope it to &quot;hard&quot; by including the aforementioned additional topics&#41;</p> <h2 id=pauli_frames_for_faster_sampling ><a href="#pauli_frames_for_faster_sampling">Pauli Frames for faster sampling.</a></h2> <p>Often, stabilizer circuit simulations are structured as a repeated simulation of the same circuit with random Pauli errors superimposed on it. This is useful, for instance, when studying the performance of error-correcting codes. In such simulations it is possible to run one single relatively expensive simulation of the noise-less circuit in order to get a reference and then run a large number of much faster &quot;Pauli Frame&quot; simulations that include the random noise. By utilizing the reference simulation, the random noise simulations could more efficiently provide samples of the performance of the circuit under noise. This project would involve creating an API for such simulations in QuantumClifford.jl. A useful reference would be the <a href="https://arxiv.org/abs/2103.02202">Stim C&#43;&#43; library</a>.</p> <p><strong>Recommended skills:</strong> Knowledge of the <a href="https://krastanov.github.io/QuantumClifford.jl/dev/references/">stabilizer formalism</a> used for simulating Clifford circuits. Familiarity with performance profiling tools in Julia.</p> <p><strong>Mentors:</strong> <a href="https://github.com/Krastanov">Stefan Krastanov</a></p> <p><strong>Expected duration:</strong> 350 hours</p> <p><strong>Difficulty:</strong> Hard, due to requiring in-depth knowledge of the stabilizer formalism.</p> <h2 id=a_zoo_of_quantum_error_correcting_codes ><a href="#a_zoo_of_quantum_error_correcting_codes">A Zoo of Quantum Error Correcting codes.</a></h2> <p>Quantum Error Correcting codes are typically represented in a form similar to the parity check matrix of a classical code. This form is called a Stabilizer tableaux. This project would involve creating a comprehensive library of frequently used quantum error correcting codes. As an initial step that would involve implementing the tableaux corresponding to simple pedagogical codes like the Steane and Shor codes, toric and surface codes, some CSS codes, etc. The project can be extended to a much longer one by including work on decoders for some of these codes. A large part of this project would involve literature surveys.</p> <p><strong>Recommended skills:</strong> Knowledge of the <a href="https://krastanov.github.io/QuantumClifford.jl/dev/references/">stabilizer formalism</a> used for simulating Clifford circuits.</p> <p><strong>Mentors:</strong> <a href="https://github.com/Krastanov">Stefan Krastanov</a></p> <p><strong>Expected duration:</strong> 175 hours &#40;but applicants can scope it as longer, depending on the list of functionality they plan to implement&#41;</p> <p><strong>Difficulty:</strong> Medium. Easy with some basic knowledge of quantum error correction</p> <h2 id=leftright_multiplications_with_small_gates ><a href="#leftright_multiplications_with_small_gates">Left/Right multiplications with small gates.</a></h2> <p>Applying an n-qubit Clifford gate to an n-qubit state &#40;tableaux&#41; is an operation similar to matrix multiplication, requiring O&#40;n^3&#41; steps. However, applying a single-qubit or two-qubit gate to an n-qubit tableaux is much faster as it needs to address only one or two columns of the tableaux. This project would focus on extending the left-multiplication special cases already started in <a href="https://github.com/Krastanov/QuantumClifford.jl/blob/master/src/symbolic_cliffords.jl">symbolic_cliffords.jl</a> and creating additional right-multiplication special cases &#40;for which <a href="https://github.com/Krastanov/QuantumClifford.jl/commit/d3e84c16b7b08ef6f1bc24e2bcf98641c2fff1ab#r67183201">the Stim library is a good reference</a>&#41;.</p> <p><strong>Recommended skills:</strong> Knowledge of the <a href="https://krastanov.github.io/QuantumClifford.jl/dev/references/">stabilizer formalism</a> used for simulating Clifford circuits. Familiarity with performance profiling tools in Julia. Understanding of C/C&#43;&#43; if you plan to use the Stim library as a reference.</p> <p><strong>Mentors:</strong> <a href="https://github.com/Krastanov">Stefan Krastanov</a></p> <p><strong>Expected duration:</strong> 175 hours &#40;but applicants can scope it as longer if they &#41;</p> <p><strong>Difficulty:</strong> Easy</p> <h1 id=symbolic_computation_project_ideas ><a href="#symbolic_computation_project_ideas">Symbolic computation project ideas</a></h1> <h2 id=symbolic_root_finding ><a href="#symbolic_root_finding">Symbolic root finding</a></h2> <p>Symbolics.jl have robust ways to convert symbolic expressions into multi-variate polynomials. There is now a robust Groebner basis implementation in &#40;Groebner.jl&#41;. Finding roots and varieties of sets of polynomials would be extremely useful in many applications. This project would involve implementing various techniques for solving polynomial systems, and where possible other non-linear equation systems. A good proposal should try to enumerate a number of techniques that are worth implementing, for example:</p> <ol> <li><p>Analytical solutions for polynomial systems of degree &lt;&#61; 4</p> <li><p>Use of HomotopyContinuations.jl for testing for solvability and finding numerical solutions</p> <li><p>Newton-raphson methods</p> <li><p>Using Groebner basis computations to find varieties</p> </ol> <p>The API for these features should be extremely user-friendly:</p> <ol> <li><p>A single <code>roots</code> function should take the sets of equations and result in the right type of roots as output &#40;either varieties or numerical answers&#41;</p> <li><p>It should automatically find the fastest strategy to solve the set of equations and apply it.</p> <li><p>It should fail with descriptive error messages when equations are not solvable, or degenerate in some way.</p> <li><p>This should allow implementing symbolic eigenvalue computation when <code>eigs</code> is called.</p> </ol> <p><strong>Mentors</strong>: <a href="https://github.com/shashi">Shashi Gowda</a>, <a href="https://github.com/sumiya11">Alexander Demin</a> <strong>Duration</strong>: 350 hours</p> <h2 id=symbolic_integration_in_symbolicsjl ><a href="#symbolic_integration_in_symbolicsjl">Symbolic Integration in Symbolics.jl</a></h2> <p>Implement the <a href="https://dspace.mit.edu/handle/1721.1/11997">heuristic approach to symbolic integration</a>. Then hook into a repository of rules such as <a href="https://rulebasedintegration.org/">RUMI</a>. See also the potential of using symbolic-numeric integration techniques &#40;https://github.com/SciML/SymbolicNumericIntegration.jl&#41;</p> <p><strong>Recommended Skills</strong>: High school/Freshman Calculus</p> <p><strong>Expected Results</strong>: A working implementation of symbolic integration in the Symbolics.jl library, along with documentation and tutorials demonstrating its use in scientific disciplines.</p> <p><strong>Mentors</strong>: <a href="https://github.com/shashi">Shashi Gowda</a>, <a href="https://github.com/YingboMa">Yingbo Ma</a></p> <p><strong>Duration</strong>: 350 hours</p> <h2 id=xla-style_optimization_from_symbolic_tracing ><a href="#xla-style_optimization_from_symbolic_tracing">XLA-style optimization from symbolic tracing</a></h2> <p>Julia functions that take arrays and output arrays or scalars can be traced using Symbolics.jl variables to produce a trace of operations. This output can be optimized to use fused operations or call highly specific NNLib functions. In this project you will trace through Flux.jl neural-network functions and apply optimizations on the resultant symbolic expressions. This can be mostly implemented as rule-based rewriting rules &#40;see https://github.com/JuliaSymbolics/Symbolics.jl/pull/514&#41;.</p> <p><strong>Recommended Skills</strong>: Knowledge of space and time complexities of array operations, experience in optimizing array code.</p> <p><strong>Mentors</strong>: <a href="https://github.com/shashi">Shashi Gowda</a></p> <p><strong>Duration</strong>: 175 hours</p> <h2 id=automatically_improving_floating_point_accuracy_herbie ><a href="#automatically_improving_floating_point_accuracy_herbie">Automatically improving floating point accuracy &#40;Herbie&#41;</a></h2> <p><a href="https://herbie.uwplse.org/">Herbie</a> documents a way to optimize floating point functions so as to reduce instruction count while reorganizing operations such that floating point inaccuracies do not get magnified. It would be a great addition to have this written in Julia and have it work on Symbolics.jl expressions. An ideal implementation would use the e-graph facilities of Metatheory.jl to implement this.</p> <p><strong>Mentors</strong>: <a href="https://github.com/shashi">Shashi Gowda</a>, <a href="https://github.com/0x0f0f0f">Alessandro Cheli</a></p> <p><strong>Duration</strong>: 350 hours</p> <h1 id=tabular_data_summer_of_code ><a href="#tabular_data_summer_of_code">Tabular Data – Summer of Code</a></h1> <h2 id=implement_flashfill_in_julia ><a href="#implement_flashfill_in_julia">Implement Flashfill in Julia </a></h2> <p><strong>Difficulty</strong>: Medium</p> <p><strong>Duration</strong>: 350 hours</p> <p><em>FlashFill</em> is mechanism for creating data manipulation pipelines using programming by example &#40;PBE&#41;. As an example see this <a href="https://support.microsoft.com/en-us/office/using-flash-fill-in-excel-3f9bcf1e-db93-4890-94a0-1578341f73f7">implementation in Microsoft Excel</a>. We want a version of Flashfill that can work against Julia tabular data structures, such as DataFrames and Tables.jl. </p> <p><strong>Resources</strong>:</p> <div class=tight-list ><ul> <li><p>A <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/04/pldi16-tutorial.pptx">presentation</a> by Sumit Gulwani of Microsoft Research</p> <li><p>A <a href="https://youtu.be/X1YXge3C8RI">video</a></p> <li><p><a href="https://www.microsoft.com/en-us/research/group/prose/">MSR Prose research group</a></p> <li><p><a href="https://www.microsoft.com/en-us/research/group/prose/#&#33;publications">Papers</a></p> </ul></div> <p><strong>Recommended Skills</strong>: Compiler techniques, DSL generation, Program synthesis</p> <p><strong>Expected Output</strong>: A practical flashfill implementation that can be used on any tabular data structure in Julia</p> <p><strong>Mentors</strong>: <a href="https://github.com/aviks/">Avik Sengupta</a></p> <h2 id=parquetjl_enhancements ><a href="#parquetjl_enhancements">Parquet.jl enhancements</a></h2> <p><strong>Difficulty</strong>: Medium</p> <p><strong>Duration</strong>: 175 hours </p> <p><a href="https://parquet.apache.org/">Apache Parquet</a> is a binary data format for tabular data. It has features for compression and memory-mapping of datasets on disk. A decent implementation of Parquet in Julia is likely to be highly performant. It will be useful as a standard format for distributing tabular data in a binary format. There exists a Parquet.jl package that has a Parquet reader and a writer. It currently conforms to the Julia Tabular file IO interface at a very basic level. It needs more work to add support for critical elements that would make Parquet.jl usable for fast large scale parallel data processing. Each of these goals can be targetted as a single, short duration &#40;175 hrs&#41; project. </p> <div class=tight-list ><ul> <li><p>Lazy loading and support for out-of-core processing, with Arrow.jl and Tables.jl integration. Improved usability and performance of Parquet reader and writer for large files.</p> <li><p>Reading from and writing data on to cloud data stores, including support for partitioned data.</p> <li><p>Support for missing data types and encodings making the Julia implementation fully featured.</p> </ul></div> <p><strong>Resources:</strong></p> <div class=tight-list ><ul> <li><p>The <a href="https://parquet.apache.org/documentation/latest/">Parquet</a> file format &#40;also are many articles and talks on the Parquet storage format on the internet&#41;</p> <li><p><a href="https://quinnj.home.blog/2019/07/21/a-tour-of-the-data-ecosystem-in-julia/">A tour of the data ecosystem in Julia</a></p> <li><p><a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a></p> <li><p><a href="https://github.com/JuliaData/Arrow.jl">Arrow.jl</a></p> </ul></div> <p><strong>Recommended skills:</strong> Good knowledge of Julia language, Julia data stack and writing performant Julia code.</p> <p><strong>Expected Results:</strong> Depends on the specific projects we would agree on.</p> <p><strong>Mentors:</strong> <a href="https://github.com/tanmaykm">Tanmay Mohapatra</a></p> <h1 id=tabletransformsjl_-_summer_of_code ><a href="#tabletransformsjl_-_summer_of_code">TableTransforms.jl - Summer of Code</a></h1> <p><a href="https://github.com/JuliaML/TableTransforms.jl">TableTransforms.jl</a> provides transforms that are commonly used in statistics and machine learning. It was developed to address specific needs in feature engineering and works with general Tables.jl tables.</p> <p>Project mentors: <a href="https://github.com/juliohm">Júlio Hoffimann</a></p> <h2 id=statistical_transforms ><a href="#statistical_transforms">Statistical transforms</a></h2> <p>Statistical transforms such as PCA, Z-score, etc, can greatly improve the convergence of various statistical learning models, and are widely used in advanced machine learning pipelines. In this project the mentee will learn how to implement advanced transforms such as PPMT and other transforms for imputation of missing values.</p> <p><strong>Desired skills:</strong> Statistics, Machine Learning</p> <p><strong>Difficulty level:</strong> Medium</p> <p><strong>Expected duration:</strong> 350hrs</p> <p><strong>References:</strong></p> <div class=tight-list ><ul> <li><p><a href="https://geostatisticslessons.com/lessons/ppmt">Project Pursuit Multivariate Transform</a></p> </ul></div> <h2 id=utility_transforms ><a href="#utility_transforms">Utility transforms</a></h2> <p>Utility transforms such as standardization of column names and other string-based transforms are extremely important for digesting real-world data. In this project the mentee will learn good coding practices and will implement various utility transforms available in other languages &#40;e.g. Janitor package in R, pyjanitor in Python&#41;.</p> <p><strong>Desired skills:</strong> Text processing, Regex</p> <p><strong>Difficulty level:</strong> Easy</p> <p><strong>Expected duration:</strong> 175hrs</p> <p><strong>References:</strong></p> <div class=tight-list ><ul> <li><p><a href="https://garthtarr.github.io/meatR/janitor.html">Janitor R</a></p> <li><p><a href="https://github.com/pyjanitor-devs/pyjanitor">pyjanitor</a></p> </ul></div> <h2 id=how_to_get_started ><a href="#how_to_get_started">How to get started?</a></h2> <p>Address <a href="https://github.com/JuliaML/TableTransforms.jl">open issues in the package</a>.</p> <p>Please contact <a href="https://github.com/juliohm">Júlio Hoffimann</a> on <a href="https://julialang.zulipchat.com">Zulip</a> if you have any questions.</p> <h1 id=topopt_projects_summer_of_code ><a href="#topopt_projects_summer_of_code">TopOpt Projects – Summer of Code</a></h1> <p><a href="https://github.com/JuliaTopOpt/TopOpt.jl">TopOpt.jl</a> is a <a href="https://en.wikipedia.org/wiki/Topology_optimization">topology optimisation</a> package written in pure Julia. Topology optimisation is an exciting field at the intersection of shape representation, physics simulations and mathematical optimisation, and the Julia language is a great fit for this field. To learn more about <code>TopOpt.jl</code>, check the following <a href="https://www.youtube.com/watch?v&#61;sBqdkxPXluU">JuliaCon talk</a>.</p> <p>The following is a tentative list of projects in topology optimisation that you could be working on in the coming Julia Season of Contributions or Google Summer of Code. If you are interested in exploring any of these topics or if you have other interests related to topology optimisation, please reach out to the main mentor <a href="https://github.com/mohamed82008">Mohamed Tarek</a> via email.</p> <h2 id=machine_learning_in_topology_optimisation ><a href="#machine_learning_in_topology_optimisation">Machine learning in topology optimisation</a></h2> <p><strong>Project difficulty</strong>: Easy to Medium</p> <p><strong>Work load</strong>: 175 or 350 hours</p> <p><strong>Description</strong>: There are numerous ways to use machine learning for design optimisation in topology optimisation. The following are all recent papers with applications of neural networks and machine learning in topology optimisation. There are also exciting research opportunities in this direction.</p> <ul> <li><p><a href="https://openreview.net/pdf?id&#61;DUy-qLzqvlU">DNN-based Topology Optimisation: Spatial Invariance and Neural Tangent Kernel</a></p> <li><p><a href="https://openreview.net/pdf?id&#61;bBHHU4dW88g">NTopo: Mesh-free Topology Optimization using Implicit Neural Representations</a></p> <li><p><a href="https://www.sciencedirect.com/science/article/pii/S004578252100414X?via&#37;3Dihub">TONR: An exploration for a novel way combining neural network with topology optimization</a></p> <li><p><a href="https://link.springer.com/article/10.1007/s00158-020-02748-4">TOuNN: Topology Optimization using Neural Networks</a></p> </ul> <p>In this project you will implement one of the algorithms discussed in any of these papers.</p> <p><strong>Knowledge prerequisites</strong>: neural networks, optimisation, Julia programming</p> <h2 id=multi-material_design_representation ><a href="#multi-material_design_representation">Multi-material design representation</a></h2> <p><strong>Project difficulty</strong>: Easy</p> <p><strong>Work load</strong>: 175 hours</p> <p><strong>Description</strong>: There are some topology optimisation formulations that enable the optimisation of the shape of the structure and the material selected simultaneously. In this project, you will implement some multi-material design optimisation formulations, e.g. <a href="https://link.springer.com/article/10.1007/s00158-011-0625-z">this paper</a> has a relatively simple approach to integrate in TopOpt.jl. Other methods include using mixed integer nonlinear programming from <a href="https://github.com/JuliaNonconvex/Nonconvex.jl">Nonconvex.jl</a> to select materials in different parts of the design.</p> <p><strong>Knowledge prerequisites</strong>: basic optimisation, Julia programming</p> <h2 id=optimisation_on_a_uniform_rectilinear_grid ><a href="#optimisation_on_a_uniform_rectilinear_grid">Optimisation on a uniform rectilinear grid</a></h2> <p><strong>Project difficulty</strong>: Medium</p> <p><strong>Work load</strong>: 350 hours</p> <p><strong>Description</strong>: Currently in TopOpt.jl, there are only unstructured meshes supported. This is a very flexible type of mesh but it&#39;s not as memory efficient as uniform rectilinear grids where all the elements are assumed to have the same shape. This is the most common grid used in topology optimisation in practice. Currently in TopOpt.jl, the uniform rectilinear grid will be stored as an unstructured mesh which is unnecessarily inefficient. In this project, you will optimise the finite element analysis and topology optimisation codes in TopOpt.jl for uniform rectilinear grids.</p> <p><strong>Knowledge prerequisites</strong>: knowledge of mesh types, Julia programming</p> <h2 id=adaptive_mesh_refinement_for_topology_optimisation ><a href="#adaptive_mesh_refinement_for_topology_optimisation">Adaptive mesh refinement for topology optimisation</a></h2> <p><strong>Project difficulty</strong>: Medium</p> <p><strong>Work load</strong>: 350 hours</p> <p><strong>Description</strong>: Topology optimisation problems with more mesh elements take longer to simulate and to optimise. In this project, you will explore the use of adaptive mesh refinement starting from a coarse mesh, optimising and only refining the elements that need further optimisation. This is an effective way to accelerate topology optimisation algorithms.</p> <p><strong>Knowledge prerequisites</strong>: adaptive mesh refinement, Julia programming</p> <h2 id=heat_transfer_design_optimisation ><a href="#heat_transfer_design_optimisation">Heat transfer design optimisation</a></h2> <p><strong>Project difficulty</strong>: Medium</p> <p><strong>Work load</strong>: 175 or 350 hours</p> <p><strong>Description</strong>: All of the examples in TopOpt.jl and problem types are currently of the linear elasticity, quasi-static class of problems. The goal of this project is to implement more problem types and examples from the field of heat transfer. Both steady-state heat transfer problems and linear elasticity problems make use of elliptic partial differential equations so the code from linear elasticity problems should be largely reusable for heat transfer problems with minimum changes.</p> <p><strong>Knowledge prerequisites</strong>: finite element analysis, heat equation, Julia programming</p> <h1 id=turing_projects_summer_of_code ><a href="#turing_projects_summer_of_code">Turing Projects – Summer of Code</a></h1> <p><a href="https://turing.ml/">Turing</a> is a universal probabilistic programming language embedded in Julia. Turing allows the user to write models in standard Julia syntax, and provide a wide range of sampling-based inference methods for solving problems across probabilistic machine learning, Bayesian statistics and data science etc. Since Turing is implemented in pure Julia code, its compiler and inference methods are amenable to hacking: new model families and inference methods can be easily added. Below is a list of ideas for potential projects, though you are welcome to propose your own to the Turing team.</p> <p>If you are interested in exploring any of these projects, please reach out to the listed project mentors. You can find their contact information at <a href="https://turing.ml/stable/team">turing.ml/team</a>.</p> <p>/toc</p> <h2 id=more_real-world_bayesian_models_in_turing_julia ><a href="#more_real-world_bayesian_models_in_turing_julia">More real-world Bayesian models in Turing / Julia</a></h2> <p><strong>Mentors</strong>: Kai Xu, Tor E. Fjelde, Hong Ge</p> <p><strong>Project difficulty</strong>: Medium</p> <p><strong>Project length</strong>: 175 hrs or 350 hrs</p> <p><strong>Description</strong>: There are many real-world Bayesian models out there, and they deserve a Turing / Julia implementation.</p> <p>Examples include but not limited to </p> <ul> <li><p>Forecasting &#40;<a href="https://facebook.github.io/prophet/">Prophet</a>, <a href="https://github.com/facebook/prophet/tree/main/examples">datasets</a>&#41;</p> <li><p>Recommender system &#40;<a href="http://www.cs.utoronto.ca/~amnih/papers/pmf.pdf">probabilistic matrix factorisation</a>, <a href="https://grouplens.org/datasets/movielens/">dataset</a>&#41;</p> <li><p>Ranking &#40;<a href="https://en.wikipedia.org/wiki/TrueSkill">TrueSkill</a>, <a href="https://github.com/dotnet/mbmlbook/tree/main/src/3.&#37;20Meeting&#37;20Your&#37;20Match/Data">dataset</a>&#41;</p> <li><p>Bayesian revenue estimation &#40;<a href="https://www.smartly.io/blog/tutorial-how-we-productized-bayesian-revenue-estimation-with-stan">example</a>&#41;</p> <li><p>Political forecasting model &#40;<a href="https://github.com/sjwild/Canandian_Election_2021">example</a>&#41;</p> <li><p>Topic mining &#40;latent Dirichlet allocation and new variants&#41;</p> <li><p>Multiple Annotators/Combining Unreliable Observations &#40;Dawid and Skene, 1979&#41;</p> </ul> <p>For each model, we consider the following tasks</p> <ul> <li><p>Correctness test: correctness of the implementation can be tested by doing inference for prior samples, for which we know the ground truth latent variables.</p> <li><p>Performance benchmark: this includes &#40;i&#41; time per MCMC step and &#40;ii&#41; time per effective sample; if the model is differentiable, a further break-down of &#40;i&#41; into &#40;i.1&#41; time per forward pass and &#40;i.2&#41; time per gradient pass are needed.</p> <li><p>Real-world results: if available, the final step is to apply the model to a real-world dataset; if such an experiment has been done in the literature, consistency of inference results needs to be checked</p> </ul> <h2 id=improving_the_integration_between_turing_and_turings_mcmc_inference_packages ><a href="#improving_the_integration_between_turing_and_turings_mcmc_inference_packages">Improving the integration between Turing and Turing&#39;s MCMC inference packages</a></h2> <p><strong>Mentors</strong>: Cameron Pfiffer, Mohamed Tarek, David Widmann</p> <p><strong>Project difficulty</strong>: Easy</p> <p><strong>Project length</strong>: 175 hrs</p> <p><strong>Description</strong>: Turing.jl is based on a set of inference packages that maintained by the TuringLang group. This project is about making use of improvements in DynamicPPL to create a generic integration between Turing.jl and the AbstractMCMC.jl sampling API. The ultimate goal is to remove or substantially reduce algorithm-specific glue code inside Turing.jl. The project would also involve improving data structures for storing model parameters in DynamicPPL.</p> <h2 id=directed-graphical_model_support_for_the_abstract_probabilistic_programming_library ><a href="#directed-graphical_model_support_for_the_abstract_probabilistic_programming_library">Directed-graphical model support for the abstract probabilistic programming library</a></h2> <p><strong>Mentors</strong>: Philipp Gabler, Hong Ge</p> <p><strong>Project difficulty</strong>: Hard</p> <p><strong>Project length</strong>: 350 hrs</p> <p><strong>Description</strong>: We want to have a very light-weight representation of probabilistic models of static graphs &#40;similar to BUGS&#41;, which can serve as a representation target of other front-end DSLs or be dynamically built. The representation should consist of the model and node representations &#40;stochastic and deterministic, perhaps hyperparameters&#41; and conform to the AbstractPPL model interface, with basic functions &#40;evaluation of density, sampling, conditioning; at later stages some static analysis like extraction of Markov blankets&#41;. The model should also contain the state of the variables and implement the AbstractPPL trace interface &#40;dictionary functions, querying of variable names&#41;. The result should be able to work with existing sampling packages through the abstract interfaces.</p> <h2 id=a_modular_tape_caching_mechanism_for_reversediff ><a href="#a_modular_tape_caching_mechanism_for_reversediff">A modular tape caching mechanism for ReverseDiff</a></h2> <p><strong>Mentors</strong>: Qingliang Zhuo, Mohamed Tarek</p> <p><strong>Project difficulty</strong>: Medium</p> <p><strong>Project length</strong>: 175 hrs</p> <p><strong>Description</strong>: Tape caching often leads to significant performance improvements for gradient-based sampling algorithms &#40;e.g. HMC/NUTS&#41;. Tape caching is only possible at the complete computational level for ReverseDiff at the moment. This project is about implementing a more modular, i.e. function-as-a-caching-barrier, tape caching mechanism for ReverseDiff.jl.</p> <h2 id=benchmarking_improving_performance_of_the_juliagaussianprocesses_libraries ><a href="#benchmarking_improving_performance_of_the_juliagaussianprocesses_libraries">Benchmarking &amp; improving performance of the JuliaGaussianProcesses libraries</a></h2> <p><strong>Mentors</strong>: Theo Galy-Fajou, Will Tebbutt, ST John</p> <p><strong>Project difficulty</strong>: Medium</p> <p><strong>Project length</strong>: 350 hrs</p> <p><strong>Description</strong>: Although KernelFunctions.jl has extensive correctness testing, our performance testing is lacking. This project aims to resolve this, and resolve performance issues wherever they are found. The contributor would first need to extend our existing benchmarking coverage, and debug any obvious performance problems. The next phase of the work would be to construct end-to-end examples of KernelFunctions being used in practice, profile them to determine where performance problems lie, and fix them.</p> <h2 id=iterative_methods_for_inference_in_gaussian_processes ><a href="#iterative_methods_for_inference_in_gaussian_processes">Iterative methods for inference in Gaussian Processes</a></h2> <p><strong>Mentors</strong>: Will Tebbutt, S. T. John, Ross Viljoen</p> <p><strong>Project difficulty</strong>: Medium</p> <p><strong>Project length</strong>: 175 hrs</p> <p><strong>Description</strong>: There has recently been quite a bit of work on inference methods for GPs that use iterative methods rather than the Cholesky factorisation. They look quite promising, but no one has implemented any of these within the Julia GP ecosystem yet, but they should fit nicely within the AbstractGPs framework. If you&#39;re interested in improving the GP ecosystem in Julia, this project might be for you&#33;</p> <h2 id=approximate_inference_methods_for_non-gaussian_likelihoods_in_gaussian_processes ><a href="#approximate_inference_methods_for_non-gaussian_likelihoods_in_gaussian_processes">Approximate inference methods for non-Gaussian likelihoods in Gaussian Processes</a></h2> <p><strong>Mentors</strong>: S. T. John, Ross Viljoen, Theo Galy-Fajou</p> <p><strong>Project difficulty</strong>: Hard</p> <p><strong>Project length</strong>: 350 hrs</p> <p><strong>Description</strong>: Adding <a href="https://github.com/JuliaGaussianProcesses/JuliaGaussianProcesses.github.io/discussions/5#discussioncomment-1627101">approximate inference</a> methods for non-Gaussian likelihoods which are available in other GP packages but not yet within JuliaGPs. The project would start by determining which approximate inference method&#40;s&#41; to implement–-there&#39;s lots to do, and we&#39;re happy to work with a contributor on whichever method they are most interested in, or to suggest one if they have no strong preference.</p> <h2 id=gpu_integration_in_the_juliagps_ecosystem ><a href="#gpu_integration_in_the_juliagps_ecosystem">GPU integration in the JuliaGPs ecosystem</a></h2> <p><strong>Mentors</strong>: Ross Viljoen, Theo Galy-Fajou, Will Tebbutt</p> <p><strong>Project difficulty</strong>: Medium</p> <p><strong>Project length</strong>: 350 hrs</p> <p><strong>Description</strong>: This would involve first ensuring that common models are able to run fully on the GPU, then identifying and improving GPU-specific performance bottlenecks. This would begin by implementing a limited end-to-end example involving a GP with a standard kernel, and profiling it to debug any substantial performance bottlenecks. From there, support for a wider range of the functionality available in KernelFunctions.jl and AbstractGPs.jl can be added. Stretch goal: extension of GPU support to some functionality in ApproximateGPs.jl.</p> <h1 id=vs_code_projects ><a href="#vs_code_projects">VS Code projects</a></h1> <h2 id=vs_code_extension ><a href="#vs_code_extension">VS Code extension</a></h2> <p>We are generally looking for folks that want to help with the <a href="https://www.julia-vscode.org/">Julia VS Code extension</a>. We have a long list of open issues, and some of them amount to significant projects.</p> <p><strong>Required Skills</strong>: TypeScript, Julia, web development.</p> <p><strong>Expected Results</strong>: Depends on the specific projects we would agree on.</p> <p><strong>Mentors</strong>: <a href="https://github.com/davidanthoff">David Anthoff</a></p> <h2 id=package_installation_ui ><a href="#package_installation_ui">Package installation UI</a></h2> <p>The VSCode extension for Julia could provide a simple way to browse available packages and view what&#39;s installed on a users system. To start with, this project could simply provide a GUI that reads in package data from a <code>Project.toml</code>/<code>Manifest.toml</code> and show some UI elements to add/remove/manage those packages.</p> <p>This could also be extended by having metadata about the package, such as a readme, github stars, activity and so on &#40;somewhat similar to the VSCode-native extension explorer&#41;.</p> <p><strong>Expected Results</strong>: A UI in VSCode for package operations.</p> <p><strong>Recommended Skills</strong>: Familiarity with TypeScript and Julia development.</p> <p><strong>Mentors</strong>: <a href="https://github.com/pfitzseb">Sebastian Pfitzner</a></p> <p><em>Also take a look at <a href="https://julialang.org/jsoc/gsoc/pluto/">Pluto - VS Code integration</a>&#33;</em></p> <h1 id=web_platform_projects_summer_of_code ><a href="#web_platform_projects_summer_of_code">Web Platform Projects – Summer of Code</a></h1> <p>Julia has early support for targeting WebAssembly and running in the web browser. Please note that this is a rapidly moving area &#40;see the <a href="https://github.com/Keno/julia-wasm">project repository</a> for a more detailed overview&#41;, so if you are interested in this work, please make sure to inform yourself of the current state and talk to us to scope out an appropriate project. The below is intended as a set of possible starting points.</p> <p>Mentor for these projects is <a href="https://github.com/Keno">Keno Fischer</a> unless otherwise stated.</p> <h2 id=code_generation_improvements_and_async_abi ><a href="#code_generation_improvements_and_async_abi">Code generation improvements and async ABI</a></h2> <p>Because Julia relies on an asynchronous task runtime and WebAssembly currently lacks native support for stack management, Julia needs to explicitly manage task stacks in the wasm heap and perform a compiler transformation to use this stack instead of the native WebAssembly stack. The overhead of this transformation directly impacts the performance of Julia on the wasm platform. Additionally, since all code Julia uses &#40;including arbitrary C/C&#43;&#43; libraries&#41; must be compiled using this transformation, it needs to cover a wide variety of inputs and be coordinated with other users having similar needs &#40;e.g. the Pyodide project to run python on the web&#41;. The project would aim to improve the quality, robustness and flexibility of this transformation.</p> <p><strong>Recommended Skills</strong>: Experience with LLVM.</p> <h2 id=wasm_threading ><a href="#wasm_threading">Wasm threading</a></h2> <p>WebAssembly is in the process of standardizing <a href="https://github.com/WebAssembly/threads">threads</a>. Simultaneously, work is ongoing to introduce a new threading runtime in Julia &#40;see <a href="https://github.com/JuliaLang/julia/pull/22631">#22631</a> and replated PRs&#41;. This project would investigate enabling threading support for Julia on the WebAssembly platform, implementing runtime parallel primitives on the web assembly platform and ensuring that high level threading constructs are correctly mapped to the underlying platform. Please note that both the WebAssembly and Julia threading infrastructure is still in active development and may continue to change over the duration of the project. An informed understanding of the state of these projects is a definite prerequisite for this project.</p> <p><strong>Recommended Skills</strong>: Experience with C and multi-threaded programming.</p> <h2 id=high_performance_low-level_integration_of_js_objects ><a href="#high_performance_low-level_integration_of_js_objects">High performance, Low-level integration of js objects</a></h2> <p>WebAssembly is in the process of adding <a href="https://github.com/WebAssembly/reference-types">first class references to native objects</a> to their specification. This capability should allow very high performance integration between julia and javascript objects. Since it is not possible to store references to javascript objects in regular memory, adding this capability will require several changes to the runtime system and code generation &#40;possibly including at the LLVM level&#41; in order to properly track these references and emit them either as direct references to as indirect references to the reference table.</p> <p><strong>Recommended Skills</strong>: Experience with C.</p> <h2 id=dom_integration ><a href="#dom_integration">DOM Integration</a></h2> <p>While Julia now runs on the web platform, it is not yet a language that&#39;s suitable for first-class development of web applications. One of the biggest missing features is integration with and abstraction over more complicated javascript objects and APIs, in particular the DOM. Inspiration may be drawn from similar projects in <a href="https://github.com/koute/stdweb">Rust</a> or other languages.</p> <p><strong>Recommended Skills</strong>: Experience with writing libraries in Julia, experience with JavaScript Web APIs.</p> <h2 id=porting_existing_web-integration_packages_to_the_wasm_platform ><a href="#porting_existing_web-integration_packages_to_the_wasm_platform">Porting existing web-integration packages to the wasm platform</a></h2> <p>Several Julia libraries &#40;e.g. WebIO.jl, Escher.jl&#41; provide input and output capabilities for the web platform. Porting these libraries to run directly on the wasm platform would enable a number of existing UIs to automatically work on the web.</p> <p><strong>Recommended Skills</strong>: Experience with writing libraries in Julia.</p> <h2 id=native_dependencies_for_the_web ><a href="#native_dependencies_for_the_web">Native dependencies for the web</a></h2> <p>The Julia project uses <a href="https://github.com/JuliaPackaging/BinaryBuilder.jl">BinaryBuilder</a> to provide binaries of native dependencies of julia packages. Experimental support exists to extend this support to the wasm platform, but few packages have been ported. This project would consist of attempting to port a significant fraction of the binary dependencies of the julia ecosystem to the web platform by improving the toolchain support in BinaryBuilder or &#40;if necessary&#41;, porting upstream packages to fix assumptions not applicable on the wasm platform.</p> <p><strong>Recommended Skills</strong>: Experience with building native libraries in Unix environments.</p> <h2 id=distributed_computing_with_untrusted_parties ><a href="#distributed_computing_with_untrusted_parties">Distributed computing with untrusted parties</a></h2> <p>The Distributed computing abstractions in Julia provide convenient abstraction for implementing programs that span many communicating Julia processes on different machines. However, the existing abstractions generally assume that all communicating processes are part of the same trust domain &#40;e.g. they allow messages to execute arbitrary code on the remote&#41;. With some of the nodes potentially running in the web browser &#40;or multiple browser nodes being part of the same distributed computing cluster via WebRPC&#41;, this assumption no longer holds true and new interfaces need to be designed to support multiple trust domains without overly restricting usability.</p> <p><strong>Recommended Skills</strong>: Experience with distributed computing and writing libraries in Julia.</p> <h2 id=deployment ><a href="#deployment">Deployment</a></h2> <p>Currently supported use cases for Julia on the web platform are primarily geared towards providing interactive environments to support exploration of the full language. Of course, this leads to significantly larger binaries than would be required for using Julia as part of a production deployment. By disabling dynamic language features &#40;e.g. eval&#41; one could generate small binaries suitable for deployment. Some progress towards this exists in packages like <a href="https://github.com/JuliaLang/PackageCompiler.jl">PackageCompiler.jl</a>, though significant work remains to be done.</p> <p><strong>Recommended Skills</strong>: Interest in or experience with Julia internals.</p> </div><br><br> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script> <footer class="container-fluid footer-copy"> <div class=container > <link href="https://cdn-images.mailchimp.com/embedcode/classic-10_7.css" rel=stylesheet  type="text/css"> <style> #mc_embed_signup{ clear:left; font:14px Helvetica,Arial,sans-serif; } /* Add your own Mailchimp form style overrides in your site stylesheet or in this style block. We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */ </style> <div id=mc_embed_signup > <form action="https://julialang.us14.list-manage.com/subscribe/post?u=d78e03c1818e29eeda84ff234&amp;id=c17a203547" method=post  id=mc-embedded-subscribe-form  name=mc-embedded-subscribe-form  class=validate  target=_blank  novalidate> <div id=mc_embed_signup_scroll > <div hidden=true ><input type=hidden  name=tags  value=7245945 ></div> <div id=mce-responses  class=clear  style="display: inline-block;"> <div class=response  id=mce-error-response  style="display:none"></div> <div class=response  id=mce-success-response  style="display:none"></div> </div> <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups--> <div style="position: absolute; left: -5000px; display: inline-block;" aria-hidden=true ><input type=text  name=b_d78e03c1818e29eeda84ff234_c17a203547  tabindex=-1  value="" style="display: inline-block;"></div> <div class=clear  style="display: inline-block; display: flex; justify-content: center;"><h2 style="display: inline-block; margin-right: 15px;">Stay up to date on all things Julia!</h2><input type=email  value="" placeholder="Enter your email" name=EMAIL  class="required email" id=mce-EMAIL  style="margin-right: 15px; display: inline-block; align-self: center; line-height: 2em;"><input type=submit  value=Subscribe  name=subscribe  id=mc-embedded-subscribe  class=button  style="display: inline-block; align-self: center; margin: 0 5px 0 0;"></div> </div> </form> </div> <script type='text/javascript' src='https://s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js'></script><script type='text/javascript'>(function($) {window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='FNAME';ftypes[1]='text';fnames[2]='LNAME';ftypes[2]='text';fnames[3]='ADDRESS';ftypes[3]='address';fnames[4]='PHONE';ftypes[4]='phone';fnames[5]='BIRTHDAY';ftypes[5]='birthday';}(jQuery));var $mcj = jQuery.noConflict(true);</script> <!--End mc_embed_signup--> <div class="row footrow"> <ul> <li><a href="/project">About</a> <li><a href="/about/help">Get Help</a> <li><a href="/governance/">Governance</a> <li><a href="/research/#publications">Publications</a> <li><a href="/research/#sponsors">Sponsors</a> </ul> <ul> <li><a href="/downloads/">Downloads</a> <li><a href="/downloads/">All Releases</a> <li><a href="https://github.com/JuliaLang/julia">Source Code</a> <li><a href="/downloads/#current_stable_release">Current Stable Release</a> <li><a href="/downloads/#long_term_support_release">Longterm Support Release</a> <li><a href="https://status.julialang.org/">PkgServer Status</a> </ul> <ul> <li><a href="https://docs.julialang.org/en/v1/">Documentation</a> <li><a href="https://juliaacademy.com">JuliaAcademy</a> <li><a href="https://www.youtube.com/user/JuliaLanguage">YouTube</a> <li><a href="/learning/getting-started/">Getting Started</a> <li><a href="https://docs.julialang.org/en/v1/manual/faq/">FAQ</a> <li><a href="/learning/books">Books</a> </ul> <ul> <li><a href="/community/">Community</a> <li><a href="/community/standards/">Code of Conduct</a> <li><a href="/diversity/">Diversity</a> <li><a href="https://juliacon.org">JuliaCon</a> <li><a href="/community/#julia_user_and_developer_survey">User/Developer Survey</a> <li><a href="/shop/">Shop Merchandise</a> </ul> <ul> <li><a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">Contributing</a> <li><a href="/contribute">Contributor's Guide</a> <li><a href="https://github.com/JuliaLang/julia/issues">Issue Tracker</a> <li><a href="https://github.com/JuliaLang/julia/security/policy">Report a Security Issue</a> <li><a href="https://github.com/search?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22help+wanted%22">Help Wanted Issues</a> <li><a href="https://github.com/search?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22good+first+issue%22">Good First Issue</a> <li><a href="https://docs.julialang.org/en/v1/devdocs/reflection/">Dev Docs</a> </ul> </div> <div id=footer-bottom  class=row > <div class="col-md-10 py-2"> <p>This site is powered by <a href="https://www.netlify.com">Netlify</a>, <a href="https://franklinjl.org">Franklin.jl</a>, and the <a href="https://julialang.org">Julia Programming Language</a>. We thank <a href="https://www.fastly.com">Fastly</a> for their generous infrastructure support.</p> <p>©2021 JuliaLang.org <a href="https://github.com/JuliaLang/www.julialang.org/graphs/contributors">contributors</a>. The content on this website is made available under the <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT license</a>. </div> <div class="col-md-2 py-2"> <span class=float-sm-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a> </span> </div> </div> </div> </footer> <script src="/libs/jquery/jquery.min.js"></script> <script src="/libs/bootstrap/bootstrap.min.js"></script>