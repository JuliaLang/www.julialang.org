<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The Julia Language on </title>
    <link>https://julialang.org/</link>
    <description>Recent content in The Julia Language on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 10 Feb 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://julialang.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Google&#39;s Code-In Contest Wrap up</title>
      <link>https://julialang.org/blog/2020/02/gci-summary/</link>
      <pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2020/02/gci-summary/</guid>
      <description>Over the last couple of months, 212 young people have completed over 690 tasks using Julia as part of the Google Code-In program. You may have seen PR’s to your projects or blog posts around the internet. With this being the first year that we’ve participated in the program, we were jumping into the void. It turned out to be a lot of effort, and so we must thank our amazing set of mentors who stepped up to help and guide the students.</description>
    </item>
    
    <item>
      <title>Yao.jl - Differentiable Quantum Programming In Julia</title>
      <link>https://julialang.org/blog/2019/12/yao-differentiable-quantum-programming/</link>
      <pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/12/yao-differentiable-quantum-programming/</guid>
      <description>We introduce Yao (check our latest paper), an open-source Julia package for solving practical problems in quantum computation research. The name Yao comes from the first Chinese character for unitary (幺正).
The Logo of Yao
 Why we created Yao? To be short, we are as greedy as Julia itself. We want something that is:
Differentiable Like many other Julia blog posts (as well as the Zygote paper) have mentioned: gradients can be a better programmer than humans sometimes.</description>
    </item>
    
    <item>
      <title>为 Julia 包设计的可靠、可复现的二进制工件系统</title>
      <link>https://julialang.org/blog/2019/12/artifacts-zh_cn/</link>
      <pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/12/artifacts-zh_cn/</guid>
      <description>在过去的几个月里，我们在持续迭代和完善一个 Julia 1.3+ 中 Pkg 的设计方案，它用来处理不是 Julia 包的二进制对象。这项工作当初的动机是改善用 BinaryBuilder.jl 构建的二进制文件的安装体验，不过工件（artifacts）子系统更加通用，适用于所有的 Julia 包。
Pkg 工件 工件的大致方案描述在 Pkg.jl#1234，其文档已经写进了 Pkg.jl 的最新文档。它提供了一种把数据容器与 Julia 项目和包关联在一起的便利机制。引用工件的方式是使用它的内容散列值，或者在 Artifacts.toml 内记载的绑定到散列值的名字。Artifacts.toml 的一个例子如下所示：
[socrates] git-tree-sha1 = &amp;#34;43563e7631a7eafae1f9f8d9d332e3de44ad7239&amp;#34; lazy = true [[socrates.download]] url = &amp;#34;https://github.com/staticfloat/small_bin/raw/master/jsocrates.tar.gz&amp;#34; sha256 = &amp;#34;e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58&amp;#34; [[socrates.download]] url = &amp;#34;https://github.com/staticfloat/small_bin/raw/master/jsocrates.tar.bz2&amp;#34; sha256 = &amp;#34;13fc17b97be41763b02cbb80e9d048302cec3bd3d446c2ed6e8210bddcd3ac76&amp;#34; [[c_simple]] arch = &amp;#34;x86_64&amp;#34; git-tree-sha1 = &amp;#34;4bdf4556050cb55b67b211d4e78009aaec378cbc&amp;#34; libc = &amp;#34;musl&amp;#34; os = &amp;#34;linux&amp;#34; [[c_simple.download]] sha256 = &amp;#34;411d6befd49942826ea1e59041bddf7dbb72fb871bb03165bf4e164b13ab5130&amp;#34; url = &amp;#34;https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-linux-musl.tar.gz&amp;#34; [[c_simple]] arch = &amp;#34;x86_64&amp;#34; git-tree-sha1 = &amp;#34;51264dbc770cd38aeb15f93536c29dc38c727e4c&amp;#34; os = &amp;#34;macos&amp;#34; [[c_simple.</description>
    </item>
    
    <item>
      <title>Reliable and Reproducible Binary Artifacts for Julia Packages</title>
      <link>https://julialang.org/blog/2019/11/artifacts/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/11/artifacts/</guid>
      <description>Over the past few months, we have been iterating on and refining a design for Pkg in Julia 1.3+ to reason about binary objects that are not Julia packages. While the motivating application for this work has been improving the installation experience for binaries built with BinaryBuilder.jl, the artifacts subsystem is much more general and is widely applicable to all Julia packages.
Pkg Artifacts Artifacts, as outlined in Pkg.jl#1234 and now documented in the latest docs of Pkg.</description>
    </item>
    
    <item>
      <title>The Julia Language participates in Google&#39;s Code-In Contest</title>
      <link>https://julialang.org/blog/2019/11/google-code-in/</link>
      <pubDate>Fri, 15 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/11/google-code-in/</guid>
      <description>We are pleased to announce that The Julia Language has been accepted to participate in the Google Code-In program. This is a contest for 13-17 year olds, introducing them to the world of open source development.
The program involves lots of small, bite-sized tasks. During the contest, students will claim and then subsequently complete tasks to win prizes (and learn of course). Tasks can be in the areas of coding, design, QA, documentation or outreach.</description>
    </item>
    
    <item>
      <title>Profiling tool wins and woes.</title>
      <link>https://julialang.org/blog/2019/09/profilers/</link>
      <pubDate>Mon, 16 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/09/profilers/</guid>
      <description>Profiling tools are awesome. They let us see what actually is affecting our program performance. Profiling tools also are terrible. They lie to us and give us confusing information. They also have some surprisingly new developments: brendangregg&amp;rsquo;s often cloned flamegraphs tool was created in 2011! So here I will be investigating some ways to make our profile reports better; and looking at ways in which they commonly break, to raise awareness of those artifacts in the reports.</description>
    </item>
    
    <item>
      <title>Julia Workshop@Beijing and the Julia Localization Prize</title>
      <link>https://julialang.org/blog/2019/09/julia-workshop-beijing/</link>
      <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/09/julia-workshop-beijing/</guid>
      <description>A Julia workshop in China was hosted by JuliaCN in Beijing on Aug 24, 2019. This is the 5th Julia workshop in China hosted by JuliaCN since 2016. We thank the Julia community and our kind sponsors: Colorful Clouds, Microsoft, Swarma club, and SyncedReview. We received over 100 registrations for this event, and roughly 50 offline participants. The online video stream had 1,600 live viewers.
These videos have been uploaded to Bilibili.</description>
    </item>
    
    <item>
      <title>Julia夏季会议@Beijing &amp; 本地化奖</title>
      <link>https://julialang.org/blog/2019/09/julia-workshop-beijing-zh_cn/</link>
      <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/09/julia-workshop-beijing-zh_cn/</guid>
      <description>JuliaCN在8月24日，中国北京举办了自2016以来第五次Julia会议。我们非常感谢Julia社区对本次活动的支持， 以及彩云科技, 微软中国, 集智俱乐部, 机器之心对本次活动的大力支持。本次活动有100余人注册，实到50余人。 线上直播在线人数达1600余人。
本次活动的视频已上传至JuliaCN@B站，相关材料已上传到GitHub：JuliaCN/MeetUpMaterials。
本地化奖 Jeff Bezanson宣布了Julia本地化奖，获奖人将获得一份有Julia的三个创始人签名的奖状，并且其中四位突出的贡献者将获得1000元的奖金。获奖者如下：
 @六月初六（蔡俊杰）和 @wood （赵伟明），表彰他们对中文文档突出的贡献。他们的工作不仅仅让中文用户受益，并且通过Google翻译也帮助到了韩国等亚洲地区的其它语言用户。 @Gnimuc 表彰他对中文文档的基础设施建设和维护 @Jun （田俊）表彰他对中文社区的基础设施建设，包括中文文档和中文论坛  除了以上这些最佳贡献奖获得者，突出贡献奖获奖人如下：
新文档的贡献者: @Yoshiera, @woclass, @zhangkaihua88, @zxj5470, @davelet, @shang.zd, @Kyoko_Sakura, @cherichy, @sukanka, @ciaranchen, @lwoo1999
旧文档的贡献者: @autozimu, @GaZ3ll3, @morvinzha, @nanxstats, @wlbksy, @sunoru, @XD-DENG, @KDr2, @zhx2013, @dovahcrow, @yuyichao, @yfractal
获奖证书已寄送至获奖人，如果你没有收到获奖证书请和@Roger-luo或者@Jun 联系！
会议报告  马英博, 当微分方程遇见深度学习 刘金国, Yao.jl: 量子计算遇上机器学习 杜岳華, GeometricFlux.jl: Flux 上的幾何深度學習 Thautwarm, MLStyle.jl: 高级函数式编程特性的设计和应用 陈久宁: Images.jl: Julia中的图像处理 (GSoC 2019) 夏恋花火: Julia与仿真足球机器人5v5竞赛 Mike Innes: Zygote.</description>
    </item>
    
    <item>
      <title>Julia的版本发布流程</title>
      <link>https://julialang.org/blog/2019/09/release-process-zh-cn/</link>
      <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/09/release-process-zh-cn/</guid>
      <description>从事软件开发的行家里手们对版本发布流程与节奏如此了若指掌，以至于他们将其精髓内化（internalize）并以为人人都懂得这些“浅显的道理”。 可是事实恰好相反，外行一眼望去如同雾里看花。 所以为了整个Julia社区，乃至于其它编程语言社区，我觉得有必要将Julia的开发过程白纸黑字地写下来。 在本文中，我将阐述：
 各种不同的版本 各种版本中允许和不允许的改动 版本发布流程的各阶段 根据风险承受力决定使用哪种版本 发布流程中的各阶段与标志性事件  这些文字材料是从discourse论坛和Slack协作交流群中摘录而来。 所有资料都是现成的，我只是将其归纳在一处。 如果大家觉得这篇文章颇有益处，我们会考虑将其变成一份官方文档。 宏观上来说，Julia遵循SemVer标准制定的“语义化版本”。 但SemVer在微观上提供了许多自由度，供使用者自行解释。 这篇文章正是为填补这些微观细节所作。
补丁版本（Patch releases）  SemVer的版本号格式为主版本号.次版本号.修订号。 Julia的补丁版本增加版本号的最后位，即修订号。 比方说，从1.2.3到1.2.4标志着补丁版本的发布。
 依据SemVer，补丁版本只能包含bug修复，低风险的性能改进，和文档更新。 当然，对于什么才是bug修复，不同的人有不同的见解。 造成这一分歧的原因是有些人误将bug当feature并写出建构在其上的代码。 总体来说，我们发布补丁时会慎之又慎，并且用PkgEval1来确保尽可能少的既有代码遇到兼容性问题。 有理由相信，用户们可以高枕无忧地更新到最新的补丁版本。
 我们认为，如果不是为了修复某个bug，补丁版本也应当避免修改内部代码。 尽管通常来说在任何版本中，做出公开应用程式介面（API）以外的修改都是无可厚非的，我们仍谨慎地避免这一行为，以将不兼容的风险降到最低。
 一般来说，补丁版本大约每月发布一次，并建立在当前的几个活跃（active）版本分支（branch）上（稍后详述）。 如果当月凑不齐足够的bug修复，该月也可能被跳过。
 大约在发布补丁版本的五天前，我们会在反向移植（backport）分支上运行PkgEval。 如果一切顺利，我们会将其归并（merge）并冻结（freeze）这些版本分支，并在discourse上宣布可以开始测试了。 如果在这接下来的五天里，一切风平浪静，这些版本分支会被贴上新的版本标签（tag）。
  次要版本（Minor releases）  次要版本增加版本号的中间位，即次版本号。 比方说，从1.2.3到1.3.0标志着次要版本的发布。
 次要版本包含bug修复，新特性（feature），和一些“小改动”。 这些小改动理论上可能造成不兼容，但事实上很少引起不兼容。 更何况，我们通过PkgEval完全避免了不兼容的发生。
 次要版本也会大量地重构（refactor）内部代码。 之前提到，我们规定补丁版本只允许在修复bug的前提下小范围地重构内部代码，次要版本便顺理成章地成为我们大范围重构的工作场所。 如果你的程序依赖于我们的内部代码而不是公开的应用程式介面的话，你这下可能会遇到不兼容问题。 事实上，你之所以在补丁版本侥幸活了下来，是因为我们在补丁版本执行了比SemVer更严格的标准。 任何出于某种需要而依赖我们内部代码的用户，在升级次要版本时都应该格外小心。
 次要版本每四月发布一次，也就是每年发布三次。 每四个月，我们在discourse上宣布当前开发版本将在两周后冻结。 在冻结当天，我们为次要版本建立release-1.3分支2。 该分支会被贴上版本标签，并且不允许额外添加新增特性。
  主要版本（Major releases)  主要版本增加版本号的第一位，即主版本号。比方说，2.0.0标志着主要版本的发布。
 依据SemVer，主要版本可以大刀阔斧地改动。 不过，现实中，我们很清楚我们将如何塑造Julia的代码，并不会做出面目全非的改变。 大部分用户级别代码会在Julia 2.</description>
    </item>
    
    <item>
      <title>Julia’s Release Process</title>
      <link>https://julialang.org/blog/2019/08/release-process/</link>
      <pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/08/release-process/</guid>
      <description>People involved in the day-to-day development of a project tend to become so familiar with its rhythm and process that they internalize it and it feels like everyone must just know how each stage unfolds. Of course, from the outside looking in it&amp;rsquo;s not so obvious. So I thought it might be helpful to the broader Julia community—and maybe even for other programming language communities—to actually write down Julia&amp;rsquo;s release process, including the details of:</description>
    </item>
    
    <item>
      <title>Julia User &amp; Developer Survey 2019</title>
      <link>https://julialang.org/blog/2019/08/2019-julia-survey/</link>
      <pubDate>Tue, 06 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/08/2019-julia-survey/</guid>
      <description>We conducted the first annual Julia User &amp;amp; Developer Survey in June, and the results were presented by Viral Shah at JuliaCon on July 23.
    
Special thanks to all who participated in the survey!
1,844 Julia users and developers completed the survey from over 90 countries and fluent in more than 60 languages.
Key findings and methodology are below.
Most Popular Features / Biggest Problems</description>
    </item>
    
    <item>
      <title>Julia将支持可组合的多线程并行机制</title>
      <link>https://julialang.org/blog/2019/07/multithreading-zh-cn/</link>
      <pubDate>Tue, 30 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/07/multithreading-zh-cn/</guid>
      <description>摩尔定律带来的免费性能提升（free lunch）几近结束， 软件性能越来越依赖于利用多个处理器核心。 Julia社区一直以对计算性能的关注而出名。 为了追求性能，我们已经为多进程、分布式编程和 GPU 构建了许多功能， 但多年来，我们一直知道我们还需要一个可组合的多线程支持。 今天，我们很高兴地宣布这一方向的重要进展。 我们将发布一个全新的Julia线程接口： 一个受到Cilk，Intel Threading Building Blocks (TBB) 以及 Go等启发的 通用任务并行（general task parallelism）机制。 任务并行现在已在 v1.3.0-alpha 版本中提供，Julia 1.3.0 的早期预览版预计将在几个月内发布。 您可以在下载页面上找到具有此功能的二进制文件，或者从源代码主分支构建。
在这个例子中，程序的任何部分都可以标记为并行执行， 并将启动一个“任务”在可用线程上自动运行该代码。 动态调度程序会处理所有决策和细节。 下面是一个并行代码示例，现在您可以在 Julia 中如此编写:
import Base.Threads.@spawn function fib(n::Int) if n  当然，这是斐波那契序列的非常低效的经典树型递归实现。 但，它可以在任意数量的处理器核心上运行！ 这一行 t = @spawn fib(n - 2) 启动一个计算 fib(n - 2) 的任务， 该任务与计算 fib(n - 1) 的代码并行运行。 而 fetch(t) 将等待任务 t 完成并获取其返回值。
这一并行模型有许多奇妙的特性。我们认为它有点像垃圾回收（GC）： 使用 GC，你可以自由分配对象而无需担心何时以及如何释放对象。 而使用任务并行，您可以自由生成任务（可能多达数百万个），而无需担心它们在哪运行。
这一模型非常轻量，且不用关心底层细节。 您无需显式启动和结束线程，甚至不需要知道有多少处理器或线程（尽管仍可以按需得知）。</description>
    </item>
    
    <item>
      <title>Announcing composable multi-threaded parallelism in Julia</title>
      <link>https://julialang.org/blog/2019/07/multithreading/</link>
      <pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/07/multithreading/</guid>
      <description>Software performance depends more and more on exploiting multiple processor cores. The free lunch from Moore&amp;rsquo;s Law is still over. Well, we here in the Julia developer community have something of a reputation for caring about performance. In pursuit of it, we have already built a lot of functionality for multi-process, distributed programming and GPUs, but we&amp;rsquo;ve known for years that we would also need a good story for composable multi-threading.</description>
    </item>
    
    <item>
      <title>Hello @DiffEqBot</title>
      <link>https://julialang.org/blog/2019/06/diffeqbot/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/06/diffeqbot/</guid>
      <description>Hi! Today we all got a new member to the DiffEq family. Say hi to our own DiffEqBot - A bot which helps run benchmarks and compares with the current master of a given package. It also generates and stores the Reports generated in a repository. What&amp;rsquo;s special about this is that it is completely stateless (no databases involved at all, just juggling between repositories!) and it has no exposed public URLs.</description>
    </item>
    
    <item>
      <title>A Summer of Julia 2019</title>
      <link>https://julialang.org/blog/2019/05/jsoc19/</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/05/jsoc19/</guid>
      <description>Every summer, we welcome a large group of students working on Julia and its packages via the Google Summer of Code program. Last year, we had 22 amazing students, working on diverse topics from machine learning to graphs to differential equations, many of whom continue to be valued contributors to our ecosystem. We are incredibly grateful to Google for the amazing opportunity it provides through GSoC to both the Julia ecosystem as a whole and to the students who are selected.</description>
    </item>
    
    <item>
      <title>Beyond machine learning pipelines with MLJ</title>
      <link>https://julialang.org/blog/2019/05/beyond-ml-pipelines-with-mlj/</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/05/beyond-ml-pipelines-with-mlj/</guid>
      <description>Introduction MLJ is an open-source machine learning toolbox written in pure Julia. It provides a uniform interface for interacting with supervised and unsupervised learning models currently scattered in different Julia packages.
Building on a earlier proof-of-concept, development began in earnest at The Alan Turing Institute in December 2018. In a short time interest grew and the project is now the Institute&amp;rsquo;s most starred software repository.
After outlining MLJ&amp;rsquo;s current functionality, this post introduces MLJ learning networks, a super-charged pipelining feature for model composition.</description>
    </item>
    
    <item>
      <title>DiffEqFlux.jl – Julia 的神經微分方程套件</title>
      <link>https://julialang.org/blog/2019/04/fluxdiffeq-zh_tw/</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/04/fluxdiffeq-zh_tw/</guid>
      <description>在這篇文章中，我們將會展示在 Julia 中使用微分方程解算器（DiffEq solver）搭配神經網路有多麼簡單、有效而且穩定。
Neural Ordinary Differential Equations， 在這篇文章得到 NeurIPS 2018 的最佳論文獎的殊榮之前，其早已成為熱門話題。 這篇論文給出了許多令人讚賞的結果，他結合了兩個不相干的領域，但這只不過是個開始而已： 神經網路與微分方程簡直天生絕配。這篇部落格文章來自 Flux 套件的作者與 DifferentialEquations.jl 套件作者的合作，實作 Neural ODEs 論文, 將會解釋為什麼這個專案會誕生，以及這個專案現在和未來的走向， 也會開始描繪極致的工具會有怎樣的可能性。
Julia 中運用數值方法來解微分方程的 DifferentialEquations.jl 函式庫 的眾多優勢已經在其他文章中被詳細討論。 除了經典 Fortran 方法的眾多效能評測之外， 它包含了其他新穎的功能，像是 GPU 加速、 分散式（多節點）平行運算 以及精密的事件處理。 最近，這些 Julia 土生土長的微分方程方法已經成功地整合進 Flux 深度學習套件， 並允許在神經網路中使用整套完整測試、優化的 DiffEq 方法。 我們將會使用新套件 DiffEqFlux.jl 展示給讀者， 在神經網路中增加微分方程層有多麼簡單，並可以使用一系列微分方程方法， 包含剛性（stiff）常微分方程、隨機微分方程、延遲微分方程，以及混合（非連續）微分方程。
這是第一個完美結合完整微分方程方法及神經網路模型的套件。這個部落格文章將會說明為什麼完整微分方程 方法套組的彈性如此重要。能夠融合神經網路及 ODEs、SDEs、DAEs、DDEs、剛性方程， 以及像伴隨敏感度運算（adjoint sensitivity calculations）這樣不同的方法， 這是一個神經微分方程重大的廣義化工作，將來提供更好的工具讓研究者去探索問題領域。
（註：如果你對這個工作有興趣，同時是大學或是研究所學生， 我們有 提供 Google Summer of Code 專案。 並且 暑假過後有豐厚的津貼補助。 請加入 Julia Slack 的 #jsoc 頻道， 歡迎更進一步的細節討論。）</description>
    </item>
    
    <item>
      <title>A Julia interpreter and debugger</title>
      <link>https://julialang.org/blog/2019/03/debuggers/</link>
      <pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/03/debuggers/</guid>
      <description>The authors are pleased to announce the release of a fully-featured debugger for Julia. You can now easily debug and introspect Julia code in a variety of ways:
 Step into functions and manually walk through your code while inspecting its state
 Set breakpoints and trap errors, allowing you to discover what went wrong at the point of trouble
 Interactively update and replace existing code to rapidly fix bugs in place without restarting</description>
    </item>
    
    <item>
      <title>The Julia Project and Its Entities</title>
      <link>https://julialang.org/blog/2019/02/julia-entities/</link>
      <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/02/julia-entities/</guid>
      <description>There are a number of entities surrounding the Julia programming language. Understandably, many people are not entirely clear on what these groups are and what their relationship to each other is. It’s pretty hard to know about these things without being in the thick of it. In this blog post I’ll give an overview of these groups and how they’re related to the project.
Julia The Julia project was founded by Jeff Bezanson, Alan Edelman, Viral Shah and myself (Stefan Karpinski).</description>
    </item>
    
    <item>
      <title>GSoC 2018 - Parallel Implementations of Graph Analysis Algorithms</title>
      <link>https://julialang.org/blog/2019/02/light-graphs/</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/02/light-graphs/</guid>
      <description>This blog briefly summarises my GSoC 2018 project (Parallel Graph Development) and the results achieved. For a detailed description, please refer to my GSoC blog.
The project is spread over the LightGraphs codebase. It involved:
 Producing parallel implementations of crucial graph algorithms. Improving sequential implementation of crucial graph algorithms in LightGraphs. Implementing heuristics to obtain good solutions to crucial NP-Hard graph problems.  The benchmarks were conducted on a 64-bit linux machine using 4 cores.</description>
    </item>
    
    <item>
      <title>DiffEqFlux.jl – A Julia Library for Neural Differential Equations</title>
      <link>https://julialang.org/blog/2019/01/fluxdiffeq/</link>
      <pubDate>Fri, 18 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2019/01/fluxdiffeq/</guid>
      <description>Translations: Traditional Chinese
In this blog post we will show you how to easily, efficiently, and robustly use differential equation (DiffEq) solvers with neural networks in Julia.
The Neural Ordinary Differential Equations paper has attracted significant attention even before it was awarded one of the Best Papers of NeurIPS 2018. The paper already gives many exciting results combining these two disparate fields, but this is only the beginning: neural networks and differential equations were born to be together.</description>
    </item>
    
    <item>
      <title>Building a Language and Compiler for Machine Learning</title>
      <link>https://julialang.org/blog/2018/12/ml-language-compiler/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/12/ml-language-compiler/</guid>
      <description>Since we originally proposed the need for a first-class language, compiler and ecosystem for machine learning (ML), there have been plenty of interesting developments in the field. Not only have the tradeoffs in existing systems, such as TensorFlow and PyTorch, not been resolved, but they are clearer than ever now that both frameworks contain distinct “static graph” and “eager execution” interfaces. Meanwhile, the idea of ML models fundamentally being differentiable algorithms – often called differentiable programming – has caught on.</description>
    </item>
    
    <item>
      <title>How to get started with Julia 1.0&#39;s package manager</title>
      <link>https://julialang.org/blog/2018/09/pkgtutorial/</link>
      <pubDate>Wed, 12 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/09/pkgtutorial/</guid>
      <description>For those of you in the midst of transitioning or preparing to transition to Julia 1.0, I&amp;rsquo;ve made a short (less than 6 minutes) tutorial on the basics of the new package manager. This video includes how to interact with the package manager and how to check, install, update, and remove packages.
 For more advanced information, check out the documentation and the relevant JuliaCon 2018 talk from Kristoffer Carlson and Stefan Karpinski.</description>
    </item>
    
    <item>
      <title>A portrait of JuliaCon 2018</title>
      <link>https://julialang.org/blog/2018/09/juliacon2018/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/09/juliacon2018/</guid>
      <description>So much went well! As the venue of the Julia 1.0 release and the largest meeting of the Julia community yet, JuliaCon 2018 was remarkable in multiple ways. It brought together almost 350 attendees representing users and developers of the Julia language who hailed from Africa, Asia, Europe, North America, Australia, and South America.
With an eye to quality over quantity, we&amp;rsquo;re happy to report that our attendees were overwhelmingly pleased with the conference: Of the attendees who have responded to our post-conference feedback survey, 98.</description>
    </item>
    
    <item>
      <title>The Julia Community Prizes, 2018</title>
      <link>https://julialang.org/blog/2018/09/julia-community-prizes/</link>
      <pubDate>Tue, 04 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/09/julia-community-prizes/</guid>
      <description>The Julia Community Prizes celebrate the amazing set of scientists, developers and designers who have come together build such a strong and diverse ecosystem for numerical computing. Each of the four individuals chosen for the first award in 2018 have made immense contributions to Julia over many years, and all of them have been crucial to Julia&amp;rsquo;s success.
The prizes were announced at JuliaCon 2018 in London, and each awardee was presented with certificate of accomplishment and a cash prize of $1000.</description>
    </item>
    
    <item>
      <title>GSoC 2018 and Speech Recognition for the Flux Model Zoo: The Conclusion</title>
      <link>https://julialang.org/blog/2018/08/gsoc2018-speech-recognition/</link>
      <pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/08/gsoc2018-speech-recognition/</guid>
      <description>Here we are on the other end of Google Summer of Code 2018. It has been a challenging and educational experience, and I wouldn&amp;rsquo;t have it any other way. I am thankful to the Julia community, and especially my mentor @MikeInnes, for supporting me through this. I&amp;rsquo;ve learned a lot and become even more familiar with neural nets than I was before, and I learned how to do basic GPU programming, which will be incredibly useful for my academic career.</description>
    </item>
    
    <item>
      <title>GSoC 2018: Adding Newer Features and Speeding up Convolutions in Flux</title>
      <link>https://julialang.org/blog/2018/08/adding-newer-features-and-speeding-up-convolutions-in-flux/</link>
      <pubDate>Mon, 13 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/08/adding-newer-features-and-speeding-up-convolutions-in-flux/</guid>
      <description>Over the summer I have been working at improving the Computer Vision capabilities of Flux. My specific line of work was to add newer models to the Flux model-zoo, implement some new features and also improve the speed of the previous layers. Specifically, I achieved a 18-fold speed up for the Convolutions and around 3-fold for BatchNorm.
A Short Summary of my work during GSoC 2018 I am listing all the essential PRs I had made during this project.</description>
    </item>
    
    <item>
      <title>Union-splitting: what it is, and why you should care</title>
      <link>https://julialang.org/blog/2018/08/union-splitting/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/08/union-splitting/</guid>
      <description>Among those who follow Julia&amp;rsquo;s development closely, one of the (many) new features causing great excitement is something called &amp;ldquo;Union-splitting.&amp;rdquo; Here at JuliaCon 2018 I&amp;rsquo;ve found myself explaining this feature repeatedly, so I thought I&amp;rsquo;d write this blog post to help disseminate this important information more widely. Let me start by saying that I&amp;rsquo;m not the expert here&amp;mdash;this is a feature added by Jameson Nash and Jacob Quinn, and enhanced by optimizer improvements by Keno Fisher&amp;mdash;but I am one of the many people truly excited about how this is already changing how I write Julia code.</description>
    </item>
    
    <item>
      <title>Julia 1.0</title>
      <link>https://julialang.org/blog/2018/08/one-point-zero/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/08/one-point-zero/</guid>
      <description>Translations: Simplified Chinese, Traditional Chinese, Spanish
The much anticipated 1.0 release of Julia is the culmination of nearly a decade of work to build a language for greedy programmers. JuliaCon2018 celebrated the event with a reception where the community officially set the version to 1.0.0 together.
Julia was first publicly announced with a number of strong demands on the language:
 We want a language that’s open source, with a liberal license.</description>
    </item>
    
    <item>
      <title>Julia 1.0 (Simplified Chinese)</title>
      <link>https://julialang.org/blog/2018/08/one-point-zero-zh_cn/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/08/one-point-zero-zh_cn/</guid>
      <description>备受期待的Julia语言的1.0版本积累了富有野心的程序员们的十年心血。 在 JuliaCon2018 发布会上，Julia 社区正式将该版本设置为1.0.0。
Julia项目起初是因为这些强烈的需求而公开发起的开源项目：
 我们想要的是一个自由开源的语言，并且它同时拥有C的速度和Ruby的动态性；我们想要一个具有同像性（可以将语言的脚本本身当作数据进行处理）的语言， 它有着真正的和lisp一样的宏，但是却像Matlab一样有着显然的，类似于数学表达式的标记；我们想要一个既可以像Python一样作为通用编程语言的工具， 又可以像R那样适用于统计分析，能像Perl那样自然地处理字符串，能像Matlab那样给力地处理矩阵运算，它还要能像shell一样作为胶水将各种程序粘 合在一起；我们想要一个简单易学的语言，同时它还能让最苛刻的魔法师们（hackers）开心。我们希望它是交互式的，但我们也希望它能被编译。
 We want a language that’s open source, with a liberal license. We want the speed of C with  the dynamism of Ruby. We want a language that’s homoiconic, with true macros like Lisp,  but with obvious, familiar mathematical notation like Matlab. We want something as usable  for general programming as Python, as easy for statistics as R, as natural for string  processing as Perl, as powerful for linear algebra as Matlab, as good at gluing programs  together as the shell.</description>
    </item>
    
    <item>
      <title>Julia 1.0 (Spanish)</title>
      <link>https://julialang.org/blog/2018/08/one-point-zero-es/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/08/one-point-zero-es/</guid>
      <description>La anticipada liberación de la versión 1.0 de Julia es la culminación de casi una década de trabajo de construir un lenguaje para programadores ambiciosos. JuliaCon2018 celebró la ocasión con un evento donde la comunidad oficialmente lanzó conjuntamente la versión 1.0.0.
El primer comunicado público de Julia fue hecho con número de exigencias sobre el lenguaje:
 Queremos un lenguaje que sea de código abierto, con licencia liberal. Queremos la velocidad de C con el dinamismo de Ruby.</description>
    </item>
    
    <item>
      <title>Julia 1.0 (Traditional Chinese)</title>
      <link>https://julialang.org/blog/2018/08/one-point-zero-zh_tw/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/08/one-point-zero-zh_tw/</guid>
      <description>眾所期待的 Julia 語言 1.0 版是近十年的心血結晶。 在 JuliaCon 2018 年會上，Julia 社群歡慶並共同正式地將該版本 升級為 1.0.0。
Julia 語言 第一次公開發佈 並有不少強烈的期待：
 我們想要一個開源的語言，擁有自由的版權。我們想要 C 的速度和 Ruby 的動態。我們想要有一個語法與內在表示有一致性（homoiconic）的語言， 並且像 Lisp 一樣擁有真的 macro，但是擁有像 Matlab 一樣熟悉好懂的數學符號。我們也想要像 Python 一樣好用的泛用型程式語言， 處理統計要和 R 一樣，處理字串要和 Perl 一樣地自然，要有和 Matlab 一樣強大的線性代數功能，串接程式要如同 shell 一樣好用。 要學習的東西極致簡單，同時能讓大多數嚴苛的黑客寫起來開心。我們希望它是互動式的而且也是可編譯的。
 We want a language that’s open source, with a liberal license. We want the speed of C with  the dynamism of Ruby. We want a language that’s homoiconic, with true macros like Lisp,  but with obvious, familiar mathematical notation like Matlab.</description>
    </item>
    
    <item>
      <title>GSoC 2018: Reinforcement Learning and Generative models using Flux</title>
      <link>https://julialang.org/blog/2018/08/gsoc-final-summary/</link>
      <pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/08/gsoc-final-summary/</guid>
      <description>Hello, world!
In this post I&amp;rsquo;m going to briefly summarize about the machine learning models I have worked on during this summer for GSoC. I worked towards enriching model zoo of Flux.jl, a machine learning library written in Julia. My project covered Reinforcement Learning and computer vision models.
The project is spread over these 4 codebases 1. Flux-baselines 2. AlphaGo.jl 3. GAN models 4. DNI model
In the process, I could achieve most of my targets.</description>
    </item>
    
    <item>
      <title>Writing Iterators in Julia 0.7</title>
      <link>https://julialang.org/blog/2018/07/iterators-in-julia-0.7/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/07/iterators-in-julia-0.7/</guid>
      <description>This post originally appeared on the Invenia blog.
With the upcoming 0.7 release, Julia has simplified its iteration interface. The 0.7-beta release is available for download. This was a huge undertaking which mostly fell to the prolific Keno Fischer, who wrote an entirely new optimizer for the language to accomplish it! As the most active maintainer of the IterTools package, I decided to spend a week rewriting its iterators for the new interface.</description>
    </item>
    
    <item>
      <title>First-Class Statistical Missing Values Support in Julia 0.7</title>
      <link>https://julialang.org/blog/2018/06/missing/</link>
      <pubDate>Tue, 19 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/06/missing/</guid>
      <description>The 0.7 release of Julia will soon introduce first-class support for statistical missing values. Being essential for statistical analyses and data management, this feature is common among specialized languages, such as SQL (with the NULL value), R (NA), SAS (., &#39; &#39;, etc.) or Stata (., etc.). It is however quite rare among general-purpose languages, where Nullable or Option types generally do not allow implicit propagation of null values (they require lifting) and do not provide an efficient representation of arrays with missing values1.</description>
    </item>
    
    <item>
      <title>Extensible broadcast fusion</title>
      <link>https://julialang.org/blog/2018/05/extensible-broadcast-fusion/</link>
      <pubDate>Fri, 11 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/05/extensible-broadcast-fusion/</guid>
      <description>Julia version 0.7 brings with it an exciting new feature: the ability to customize broadcast fusion! This recently-merged change is the culmination of a long iterative design process that involved many members of the community. We have converged on a highly extensible interface that should satisfy many use-cases. In this blog post I&amp;rsquo;ll explain why this is a big deal by reviewing some of the key features and just scratch the surface of all that is possible with this new design.</description>
    </item>
    
    <item>
      <title>Tetris coming to Julia language for v1.0</title>
      <link>https://julialang.org/blog/2018/04/tetris-and-you/</link>
      <pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/04/tetris-and-you/</guid>
      <description>Good news, everyone! Starting v1.0, Tetris will be included in the standard library. This will allow you to play a round of Tetris while your code is busy running.
Until Julia v1.0 drops next Wednesday, though, you can play online at:
 JuliaTetris.com  Example footage below.
 .cs-tetris-div { text-align: center; padding-top: 4px; padding-bottom: 6px; } .cs-tetris-div a { transition: all 0.5s ease; } .cs-tetris-div a:hover { -webkit-filter: brightness(125%); opacity: 0.</description>
    </item>
    
    <item>
      <title>Some π-ography</title>
      <link>https://julialang.org/blog/2018/03/pifonts/</link>
      <pubDate>Wed, 14 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/03/pifonts/</guid>
      <description>Although we&amp;rsquo;ve known about &amp;ldquo;Archimedes&amp;rsquo; constant&amp;rdquo; for a few millennia, we&amp;rsquo;ve been referring to it as the Greek letter π only since the 1700s. Patricia Rothman suggested that the following page could contain one of the earliest uses of the Greek character to indicate the concept. It&amp;rsquo;s from a mathematics text book written by William Jones and published in 1706:
Jones used the Greek letter in various places both to indicate the number and, like some of his predecessors, to refer to the periphery or perimeter (Greek περιφέρεια) of a circle, and to label points in diagrams, as we would use P and Q today.</description>
    </item>
    
    <item>
      <title>Julia joins NumFOCUS in Google Summer of Code 2018</title>
      <link>https://julialang.org/blog/2018/02/gsoc2018-numfocus/</link>
      <pubDate>Wed, 21 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2018/02/gsoc2018-numfocus/</guid>
      <description>The Julia project has participated in summer of code events since 2014, just two years after the language made its public debut. In 2014, 2016, and 2017, we participated in Google Summer of Code, and in 2015 we held our own summer of code event. This year we&amp;rsquo;re doing things a little differently. As a NumFOCUS sponsored project, we&amp;rsquo;re excited to announce that we&amp;rsquo;re participating in Google Summer of Code 2018 under the NumFOCUS umbrella.</description>
    </item>
    
    <item>
      <title>機器學習以及程式語言(Traditional Chinese)</title>
      <link>https://julialang.org/blog/2017/12/mlpl-zh_tw/</link>
      <pubDate>Mon, 25 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/12/mlpl-zh_tw/</guid>
      <description>任何足夠複雜的機器學習系統都包含一個特別設置、不符規範、充滿 bug 又緩慢實作的程式語言半成品。1
 作者：By Mike Innes (Julia Computing), David Barber (UCL), Tim Besard (UGent), James Bradbury (Salesforce Research), Valentin Churavy (MIT), Simon Danisch (MIT), Alan Edelman (MIT), Stefan Karpinski (Julia Computing), Jon Malmaud (MIT), Jarrett Revels (MIT), Viral Shah (Julia Computing), Pontus Stenetorp (UCL) and Deniz Yuret (Koç University)，譯者:鄭景文，杜岳華，林峻頤（Iblis Lin）  作為一個設計程式語言（PL）的人，我們抱持莫大的興趣看著機器學習（ML）迅速竄升 - 而且有了它，人們用來建立更複雜的 ML 模型與框架。極致（State-of-the-art）的模型正不斷增加，有了程式的構造元素像是迴圈及遞迴，這為我們的建造工具帶來了很多有趣的議題 - 那也就是，程式語言。
然而機器學習還沒有一個可靠的語言，許多人正在努力有效地創造隱藏在 Python API 底下的新語言（像是 TensorFlow），也有其他則是再利用 Python 當作一個建模語言（像是 PyTorch）。於是我們想問 —— 一個為機器學習量身定做的新語言是否有其必要的？如果是，為什麼？還有更重要的是，一個理想中未來的機器學習語言會是長什麼樣子？</description>
    </item>
    
    <item>
      <title>机器学习与编程语言 (Simplified Chinese)</title>
      <link>https://julialang.org/blog/2017/12/mlpl-cn/</link>
      <pubDate>Wed, 20 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/12/mlpl-cn/</guid>
      <description>任何足够复杂的机器学习系统，里面都拼凑了半个不规范，处处错误，且运行缓慢的编程语言。1
 作者： Mike Innes (Julia Computing), David Barber (UCL), Tim Besard (UGent), James Bradbury (Salesforce Research), Valentin Churavy (MIT), Simon Danisch (MIT), Alan Edelman (MIT), Stefan Karpinski (Julia Computing), Jon Malmaud (MIT), Jarrett Revels (MIT), Viral Shah (Julia Computing), Pontus Stenetorp (UCL) 和 Deniz Yuret (Koç University) 译者：李治中（港中文），步凡（Duke）  机器学习（ML）已如烈火烹油般火热。身处编程语言（PL）领域，我们饶有兴趣地关注着机器学习模型的复杂度和构造这些模型所用的框架。当今最前沿的模型越来越像*程序*：里面有循环和递归这样的编程结构；这对制造机器学习模型的工具本身，即编程语言，提出了许多有趣的挑战。
虽然目前还没有一个机器学习专属的语言，但实事求是地说，已有几种新语言（比如 TensorFlow）藏身于 Python 语言接口之后；也有一些（比如 PyTorch）则直接用 Python 作为自己的建模语言。我们要问这样一个问题——需不需要专门为机器学习定制一个全新的语言？如果是，为什么？更重要地，如果将来出现一个理想的机器学习语言，它会长什么样？
儿童黑话及其它隐匿语言 TensorFlow（TF）等框架2已被公认属于编程语言，尽管它们在某些方面还有局限。这多少有些意料之外，毕竟大家 TF 编程时用的是 Python。然而琢磨一下就会发现，TF 只是让你用 Python 代码构造了一个表达式树，这个表达式树是用其内部语言表示的，之后再进行计算。
实际上，可以在任何语言上实现 TensorFlow 这种“延迟”计算的风格。如下 JavaScript 代码就用此风格写了一个 add 函数:</description>
    </item>
    
    <item>
      <title>On Machine Learning and Programming Languages</title>
      <link>https://julialang.org/blog/2017/12/mlpl/</link>
      <pubDate>Wed, 06 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/12/mlpl/</guid>
      <description>Any sufficiently complicated machine learning system contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of a programming language.1
 By Mike Innes (Julia Computing), David Barber (UCL), Tim Besard (UGent), James Bradbury (Salesforce Research), Valentin Churavy (MIT), Simon Danisch (MIT), Alan Edelman (MIT), Stefan Karpinski (Julia Computing), Jon Malmaud (MIT), Jarrett Revels (MIT), Viral Shah (Julia Computing), Pontus Stenetorp (UCL) and Deniz Yuret (Koç University)  As programming languages (PL) people, we have watched with great interest as machine learning (ML) has exploded – and with it, the complexity of ML models and the frameworks people are using to build them.</description>
    </item>
    
    <item>
      <title>GSoC 2017: Native Julia second order ODE and BVP solvers</title>
      <link>https://julialang.org/blog/2017/11/gsoc-ode/</link>
      <pubDate>Wed, 01 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/11/gsoc-ode/</guid>
      <description>My original GSoC project was about implementing native Julia solvers for solving boundary value problems (BVPs) that were determined from second order ordinary differential equations (ODEs). I started down the BVP path, built a shooting method to solve BVPs from initial value problems (IVPs), and then built the beginning of the mono-implicit Runge-Kutta (MIRK) method. Those solvers are in the BoundaryValueDiffEq.jl repository. Instead of trying to jump directly to the end point, and talk about how to do every detail in MIRK, I went to explore how those details naturally arise in second order ODEs.</description>
    </item>
    
    <item>
      <title>NeuralNetDiffEq.jl: A Neural Network solver for ODEs</title>
      <link>https://julialang.org/blog/2017/10/gsoc-neuralnetdiffeq/</link>
      <pubDate>Fri, 13 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/10/gsoc-neuralnetdiffeq/</guid>
      <description>My GSoC 2017 project was to implement a package for Julia to solve Ordinary Differential Equations using Neural Networks. The purpose of the project was to provide an additional DE solver using Neural Networks which has parallelism in time as the key advantage over other solvers which are iterative in nature. The project was based on research paper of Lagaris et al. 1997 which proposed the function approximation capabilities of neural networks (NNs) for solving differential equations.</description>
    </item>
    
    <item>
      <title>Command Interpolation For Dummies</title>
      <link>https://julialang.org/blog/2017/10/command-interpolation-for-dummies/</link>
      <pubDate>Thu, 05 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/10/command-interpolation-for-dummies/</guid>
      <description>I&amp;rsquo;ve never been a big user of the command line. One could even say I actively avoided it! Heck, I haven&amp;rsquo;t even written a program using command line arguments, since it always felt a bit like resurrecting a dinosaur - and we all know how that ends.
This carefully honed ignorance just came in handy when discussing how to improve the learning curve for Julia&amp;rsquo;s shell interface.
Turns out it was designed by people born in the command line, making it confusing to use for someone like me.</description>
    </item>
    
    <item>
      <title>GSoC 2017 Project: Hamiltonian Indirect Inference</title>
      <link>https://julialang.org/blog/2017/09/hamiltonian-indirect-inference/</link>
      <pubDate>Tue, 19 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/09/hamiltonian-indirect-inference/</guid>
      <description>Bayesian_Examples.jl This is a writeup of my project for the Google Summer of Code 2017. The associated repository contains examples of estimating various models. In addition to this repository, I have collaborated in HamiltonianABC and its branches as part of the GSOC 2017.
GSOC 2017 project: Hamiltonian Monte Carlo and pseudo-Bayesian Indirect Likelihood This summer I have had the opportunity to participate in the Google Summer of Code program. My project was in the Julia language and the main goal was to implement Indirect Inference (A.</description>
    </item>
    
    <item>
      <title>GSoC 2017: Parallelism in BioJulia</title>
      <link>https://julialang.org/blog/2017/09/bio-parallel/</link>
      <pubDate>Thu, 07 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/09/bio-parallel/</guid>
      <description>In this summer, I have worked on a project to develop tools that make BioJulia run faster. As an outcome, Automa.jl now generates more efficient code to parse text files, ConcurrentCalls.jl runs multiple tasks in parallel, and simple and efficient interfaces to various compression formats are provided in TranscodingStreams.jl.
Instruction-level parallelism Instruction-level parallelism is a technique to run multiple instructions simultaneously on a CPU core. This may sound odd but actually it is possible because CPU instructions are executed in multiple stages such as fetch, decode, execute, and so on.</description>
    </item>
    
    <item>
      <title>GSoC 2017: Efficient Discretizations of PDE Operators</title>
      <link>https://julialang.org/blog/2017/09/gsoc-derivative_operators/</link>
      <pubDate>Wed, 06 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/09/gsoc-derivative_operators/</guid>
      <description>This project is an attempt towards building a PDE solver for JuliaDiffEq using the Finite Difference Method(FDM) approach. We take up the FDM approach instead of FEM and FVM as there are many toolboxes which already exist for FEM and FVM but not for FDM. Also, there are many use cases where the geometry of the problem is simple enough to be solved by FDM methods which are much faster due to their being able to avoid the bottleneck step of matrix multiplication by using Linear transformations to mimic the effect of a matrix multiplication.</description>
    </item>
    
    <item>
      <title>GSoC 2017 Project: MCMC with flexible numbers of parameters</title>
      <link>https://julialang.org/blog/2017/09/gsoc-mcmc-with-flexible-numbers-of-parameters/</link>
      <pubDate>Sun, 03 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/09/gsoc-mcmc-with-flexible-numbers-of-parameters/</guid>
      <description>My original GSOC proposal was to implement modify Mamba.jl to enable it to fit Crosscat, a general-purpose Bayesian model which fits tabular data using row-wise Dirichlet cluster models nested inside a column-wise Dirichlet cluster. This model is in itself broadly useful, but the real reason I chose this project was to work on something even more general: improving the tools for doing MCMC on models with a mix of discrete and continuous parameters.</description>
    </item>
    
    <item>
      <title>GSoC 2017 : A Wrapper for the FEniCS Finite Element Toolbox</title>
      <link>https://julialang.org/blog/2017/09/gsoc-fenics/</link>
      <pubDate>Fri, 01 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/09/gsoc-fenics/</guid>
      <description>Introduction Throughout this Google Summer of Code project I, along with my mentors, aimed to create a Wrapper for the FEniCS Finite Element Toolbox in the Julia Language. Our work done can be found at FEniCS.jl . This would allow users to perform FEM calculations directly in Julia, utilizing our PyCall.jl wrapping functionality. We currently have wrapped the main functionality, along with providing the necessary instructions to add further components when they are deemed necessary.</description>
    </item>
    
    <item>
      <title>GSoC 2017: Documentation Browser for Juno</title>
      <link>https://julialang.org/blog/2017/08/gsoc-docs-in-juno/</link>
      <pubDate>Mon, 28 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/08/gsoc-docs-in-juno/</guid>
      <description>The aim of this GSoC project is to provide a convenient way to access documentation in the Juno IDE. Any work on this has to be on the Julia side (for getting the necessary information by introspection) and on the Atom side (for presenting said information).
Most of the work on the Julia side went into a new package, DocSeeker.jl, which implements all of the introspection necessary to get docstrings from installed packages; a small shim in Atom.</description>
    </item>
    
    <item>
      <title>GSoC 2017: Implementing iterative solvers for numerical linear algebra</title>
      <link>https://julialang.org/blog/2017/08/native-julia-implementations-of-iterative-solvers-for-numerical-linear-algebra/</link>
      <pubDate>Wed, 23 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/08/native-julia-implementations-of-iterative-solvers-for-numerical-linear-algebra/</guid>
      <description>The central part of my GSoC project is about implementing the Jacobi-Davidson method natively in Julia, available in JacobiDavidson.jl. This method computes a few approximate solutions of the eigenvalue problem $Ax = \lambda Bx$ for large and sparse matrices $A$ and $B$. As it uses iterative solvers internally, much time has gone into improving IterativeSolvers.jl in general. Lastly, as iterative solvers are typically used with preconditioners, I have implemented the incomplete LU factorization for sparse matrices as well in ILU.</description>
    </item>
    
    <item>
      <title>JuliaCon 2017 on the West Coast</title>
      <link>https://julialang.org/blog/2017/08/juliacon/</link>
      <pubDate>Tue, 15 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/08/juliacon/</guid>
      <description>It’s a year later and I’m back: this time to the West Coast for the next edition of JuliaCon. The latest edition promised more talks, workshops, and wider community attendance. As usual, the conference began with a day dedicated to workshops. The first workshop was on the DifferentialEquations ecosystem, championed by Chris Rackauckas, who spoke about his vision to make the ecosystem the scientist’s one stop shop for simulations. It certainly looked to be shaping up into a robust ecosystem.</description>
    </item>
    
    <item>
      <title>Creating domain-specific languages in Julia using macros</title>
      <link>https://julialang.org/blog/2017/08/dsl/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/08/dsl/</guid>
      <description>Since the beginning of Julia, it has been tempting to use macros to write domain-specific languages (DSLs), i.e. to extend Julia syntax to provide a simpler interface to create Julia objects with complicated behaviour. The first, and still most extensive, example is JuMP.
Since the fix for the infamous early Julia issue #265, which was incorporated in Julia 0.6, some previous methods for creating DSLs in Julia, mainly involving eval, ceased to work.</description>
    </item>
    
    <item>
      <title>Julia 0.6 Release Announcement</title>
      <link>https://julialang.org/blog/2017/06/julia-0.6-release/</link>
      <pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/06/julia-0.6-release/</guid>
      <description>The Julia community is thrilled to announce the release of version 0.6.0 of the Julia language. With a sweeping overhaul of the type system and numerous improvements to syntax and to the standard library, 0.6.0 is the most transformative release yet. A comprehensive list of changes in this release is available in the main Julia repository in the NEWS log.
The 0.6 release line is now considered the stable line of releases and is recommended for most users, as it provides both language and API stability.</description>
    </item>
    
    <item>
      <title>Julia available in Raspbian on the Raspberry Pi</title>
      <link>https://julialang.org/blog/2017/05/raspberry-pi-julia/</link>
      <pubDate>Wed, 03 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/05/raspberry-pi-julia/</guid>
      <description>Recently, Julia was accepted into the Raspbian distribution for the Raspberry Pi. If you are running the latest Raspbian, all you need to do is apt-get install julia. Most of the common packages can be installed with Pkg, and Jupyter can be installed using the usual IJulia.jl instructions.
While Julia works on all the Pi variants, we recommend using the Pi 3.
The scripts to create the julia package for Raspbian are in the julia-raspbian repo in the JuliaBerry organization on GitHub.</description>
    </item>
    
    <item>
      <title>Upgrades to the REPL in Julia 0.6</title>
      <link>https://julialang.org/blog/2017/04/repl-0.6-highlights/</link>
      <pubDate>Tue, 25 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/04/repl-0.6-highlights/</guid>
      <description>Since version 0.3, Julia has come with a command-line interface — a REPL — that is completely written in Julia (PR #6270). Among other features, the REPL provides code completion, history with reverse search, and a rich set of customizable key bindings. (See the Interacting with Julia part of the manual for the REPL documentation.) Even so, the REPL in Julia 0.6 includes quite a few new visual tweaks and features.</description>
    </item>
    
    <item>
      <title>Knowing where you are: custom array indices in Julia</title>
      <link>https://julialang.org/blog/2017/04/offset-arrays/</link>
      <pubDate>Tue, 18 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/04/offset-arrays/</guid>
      <description>Arrays are a crucial component of any programming language, particularly for a data-oriented language like Julia. Arrays store values according to their location: in Julia, given a two-dimensional array A, the expression A[1,3] returns the value stored at a location known as (1,3). If, for example, A stores Float64 numbers, the value returned by this expression will be a single Float64 number.
Julia&amp;rsquo;s arrays conventionally start numbering their axes with 1, meaning that the first element of a one-dimensional array a is a[1].</description>
    </item>
    
    <item>
      <title>Paper in SIAM Review: Julia - A Fresh Approach to Numerical Computing</title>
      <link>https://julialang.org/blog/2017/03/julia-fresh-paper/</link>
      <pubDate>Sat, 18 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/03/julia-fresh-paper/</guid>
      <description>Our paper, Julia: A Fresh Approach to Numerical Computing, was published in the prestigious SIAM Review in February 2017. While drafts of this paper have always been available on Arxiv, we are excited that the paper is finally published. We make an attempt to explain why Julia is fast while retaining ease of use and simultaneously also offer a tutorial for the reader to get a feel for the language.</description>
    </item>
    
    <item>
      <title>Some fun with π in Julia</title>
      <link>https://julialang.org/blog/2017/03/piday/</link>
      <pubDate>Tue, 14 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/03/piday/</guid>
      <description>Image courtesy of Cormullion, code here.
This post is available as a Jupyter notebook here
&amp;pi; in Julia (Simon Byrne)
Like most technical languages, Julia provides a variable constant for &amp;pi;. However Julia&amp;rsquo;s handling is a bit special.
piπ = 3.1415926535897... It can also be accessed via the unicode symbol (you can get it at the REPL or in a notebook via the TeX completion \pi followed by a tab)</description>
    </item>
    
    <item>
      <title>Technical preview: Native GPU programming with CUDAnative.jl</title>
      <link>https://julialang.org/blog/2017/03/cudanative/</link>
      <pubDate>Tue, 14 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/03/cudanative/</guid>
      <description>After 2 years of slow but steady development, we would like to announce the first preview release of native GPU programming capabilities for Julia. You can now write your CUDA kernels in Julia, albeit with some restrictions, making it possible to use Julia&amp;rsquo;s high-level language features to write high-performance GPU code.
The programming support we&amp;rsquo;re demonstrating here today consists of the low-level building blocks, sitting at the same abstraction level of CUDA C.</description>
    </item>
    
    <item>
      <title>More Dots: Syntactic Loop Fusion in Julia</title>
      <link>https://julialang.org/blog/2017/01/moredots/</link>
      <pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2017/01/moredots/</guid>
      <description>After a lengthy design process and preliminary foundations in Julia 0.5, Julia 0.6 includes new facilities for writing code in the &amp;ldquo;vectorized&amp;rdquo; style (familiar from Matlab, Numpy, R, etcetera) while avoiding the overhead that this style of programming usually imposes: multiple vectorized operations can now be &amp;ldquo;fused&amp;rdquo; into a single loop, without allocating any extraneous temporary arrays.
This is best illustrated with an example (in which we get order-of-magnitude savings in memory and time, as demonstrated below).</description>
    </item>
    
    <item>
      <title>Julia 0.5 Highlights</title>
      <link>https://julialang.org/blog/2016/10/julia-0.5-highlights/</link>
      <pubDate>Tue, 11 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/10/julia-0.5-highlights/</guid>
      <description>To follow along with the examples in this blog post and run them live, you can go to JuliaBox, create a free login, and open the &amp;ldquo;Julia 0.5 Highlights&amp;rdquo; notebook under &amp;ldquo;What&amp;rsquo;s New in 0.5&amp;rdquo;. The notebook can also be downloaded from here.
Julia 0.5 is a pivotal release. It introduces more transformative features than any release since the first official version. Moreover, several of these features set the stage for even more to come in the lead up to Julia 1.</description>
    </item>
    
    <item>
      <title>Julia 0.5 Release Announcement</title>
      <link>https://julialang.org/blog/2016/10/julia-0.5-release/</link>
      <pubDate>Mon, 10 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/10/julia-0.5-release/</guid>
      <description>After over a year of development, the Julia community is proud to announce the release of version 0.5 of the Julia language and standard library. This release contains major language refinements and numerous standard library improvements. A long list of changes is available in the NEWS log found in our main repository, with a summary reproduced below. A separate blog post detailing some of the highlights of the new release has also been posted.</description>
    </item>
    
    <item>
      <title>StructuredQueries.jl - A generic data manipulation framework</title>
      <link>https://julialang.org/blog/2016/10/structuredqueries/</link>
      <pubDate>Mon, 03 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/10/structuredqueries/</guid>
      <description>This post describes my work conducted this summer at the Julia Lab to develop StructuredQueries.jl, a generic data manipulation framework for Julia.
Our initial vision for this work was much inspired by Hadley Wickham&amp;rsquo;s dplyr R package, which provides data manipulation verbs that are generic over in-memory R tabular data structures and SQL databases, and DataFramesMeta (begun by Tom Short), which provides metaprogramming facilities for working with Julia DataFrames.</description>
    </item>
    
    <item>
      <title>A Personal Perspective On JuliaCon 2016</title>
      <link>https://julialang.org/blog/2016/09/juliacon2016/</link>
      <pubDate>Wed, 21 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/09/juliacon2016/</guid>
      <description>The gentle breeze brushed my face and the mild sunshine warmed an otherwise chilly morning. I was standing in front of a large building that can only be described as unique: a series of metal plates jutting out at odd angles, whose dull resplendence cast an instant impression. It was the Ray and Maria Stata Centre, a towering monolith and the venue for an event that people from all over the world came to attend and participate in.</description>
    </item>
    
    <item>
      <title>BioJulia 2016 - online sequence search, sequence demultiplexing, new readers and much more!</title>
      <link>https://julialang.org/blog/2016/09/biojulia2016-mid/</link>
      <pubDate>Sat, 10 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/09/biojulia2016-mid/</guid>
      <description>We are pleased to announce releasing Bio.jl 0.4, a minor release including significant functionality improvements as I promised in the previous blog post.
The following features are added since the post:
 Online sequence search algorithms. Sequence data structure for reference genomes. Data reader and writer for the .2bit file format. Data reader and writer for the SAM and BAM file formats. Sequence demultiplexing tool. Package to handle BGZF files.</description>
    </item>
    
    <item>
      <title>Graft.jl - General purpose graph analytics for Julia</title>
      <link>https://julialang.org/blog/2016/08/gsoc2016-graft/</link>
      <pubDate>Mon, 22 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/08/gsoc2016-graft/</guid>
      <description>This blog post describes my work on Graft.jl, a general purpose graph analysis package for Julia. For those unfamiliar with graph algorithms, a quick introduction might help.
Proposal My proposal, titled ParallelGraphs, was to develop a parallelized/distributed graph algorithms library. However, in the first month or so, we decided to work towards a more general framework that supports data analysis on networks (graphs with attributes defined on vertices and edges).</description>
    </item>
    
    <item>
      <title>Announcing support for complex-domain linear programs in Convex.jl</title>
      <link>https://julialang.org/blog/2016/08/announcing-support-for-complex-domain-linear-programs-in-convex.jl/</link>
      <pubDate>Wed, 17 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/08/announcing-support-for-complex-domain-linear-programs-in-convex.jl/</guid>
      <description>I am pleased to announce the support for complex-domain linear programs (LPs) in Convex.jl. As one of the Google Summer of Code students under The Julia Language, I had proposed to implement the support for complex semidefinite programming. In the first phase of project, I started by tackling the problem of complex-domain LPs where in first subphase, I had announced the support for complex coefficients during JuliaCon&amp;rsquo;16 and now I take this opportunity to announce the support for complex variables in LPs.</description>
    </item>
    
    <item>
      <title>An invitation to JuliaCon 2016</title>
      <link>https://julialang.org/blog/2016/05/juliacon-invitation/</link>
      <pubDate>Sun, 08 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/05/juliacon-invitation/</guid>
      <description>For the third year in row we are happy to invite you to JuliaCon, the annual meeting of the Julia programming language community. JuliaCon 2016 will be held at the Massachusetts Institute of Technology from June 21st to 25th and as a first, this year we will have several high-profile keynote speakers, as well as the top-notch tutorials and talks you have come to expect over the years. Please purchase your tickets before May 13th to take advantage of the early-bird pricing and we look forward to seeing you in June!</description>
    </item>
    
    <item>
      <title>BioJulia Project in 2016</title>
      <link>https://julialang.org/blog/2016/04/biojulia2016/</link>
      <pubDate>Sat, 30 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/04/biojulia2016/</guid>
      <description>I am pleased to announce that the next phase of BioJulia is starting! In the next several months, I&amp;rsquo;m going to implement many crucial features for bioinformatics that will motivate you to use Julia and BioJulia libraries in your work. But before going to the details of the project, let me briefly introduce you what the BioJulia project is. This project is supported by the Moore Foundation and the Julia project.</description>
    </item>
    
    <item>
      <title>Google Summer of Code 2016</title>
      <link>https://julialang.org/blog/2016/04/gsoc/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/04/gsoc/</guid>
      <description>We’re pleased to announce that the Julia Language is taking part in this year’s Google Summer of Code. This means that interested students will have the opportunity to spend their summers getting paid to write code on a project of their choice.
Student applications are open from March 14th – 25th on the SoC website, but there’s no reason not to get going right away! To get you started thinking about what you’d like to work on, there are a bunch of interesting projects on our ideas page.</description>
    </item>
    
    <item>
      <title>Generalizing AbstractArrays: opportunities and challenges</title>
      <link>https://julialang.org/blog/2016/03/arrays-iteration/</link>
      <pubDate>Sun, 27 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/03/arrays-iteration/</guid>
      <description>Introduction: generic algorithms with AbstractArrays Somewhat unusually, this blog post is future-looking: it mostly focuses on things that don&amp;rsquo;t yet exist. Its purpose is to lay out the background for community discussion about possible changes to the core API for AbstractArrays, and serves as background reading and reference material for a more focused &amp;ldquo;julep&amp;rdquo; (a julia enhancement proposal). Here, often I&amp;rsquo;ll use the shorthand &amp;ldquo;array&amp;rdquo; to mean AbstractArray, and use Array if I explicitly mean julia&amp;rsquo;s concrete Array type.</description>
    </item>
    
    <item>
      <title>An introduction to ParallelAccelerator.jl</title>
      <link>https://julialang.org/blog/2016/03/parallelaccelerator/</link>
      <pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/03/parallelaccelerator/</guid>
      <description>The High Performance Scripting team at Intel Labs recently released ParallelAccelerator.jl, a Julia package for high-performance, high-level array-style programming. The goal of ParallelAccelerator is to make high-level array-style programs run as efficiently as possible in Julia, with a minimum of extra effort required from the programmer. In this post, we&amp;rsquo;ll take a look at the ParallelAccelerator package and walk through some examples of how to use it to speed up some typical array-style programs in Julia.</description>
    </item>
    
    <item>
      <title>Multidimensional algorithms and iteration</title>
      <link>https://julialang.org/blog/2016/02/iteration/</link>
      <pubDate>Mon, 01 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/02/iteration/</guid>
      <description>Note: updated December 2018 for Julia 1.1
Julia makes it easy to write elegant and efficient multidimensional algorithms. The new capabilities rest on two foundations: an iterator called CartesianIndices, and sophisticated array indexing mechanisms. Before I explain, let me emphasize that developing these capabilities was a collaborative effort, with the bulk of the work done by Matt Bauman (@mbauman), Jutho Haegeman (@Jutho), and myself (@timholy).
These iterators are deceptively simple, so much so that I&amp;rsquo;ve never been entirely convinced that this blog post is necessary: once you learn a few principles, there&amp;rsquo;s almost nothing to it.</description>
    </item>
    
    <item>
      <title>Julia IDE work in Atom</title>
      <link>https://julialang.org/blog/2016/01/atom-work/</link>
      <pubDate>Thu, 07 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2016/01/atom-work/</guid>
      <description>A PL designer used to be able to design some syntax and semantics for their language, implement a compiler, and then call it a day. – Sean McDirmid
 In the few years since its initial release, the Julia language has made wonderful progress. Over four hundred contributors – and counting – have donated their time developing exciting and modern language features like channels for concurrency, a native documentation system, staged functions, compiled packages, threading, and tons more.</description>
    </item>
    
    <item>
      <title>JSoC 2015 project: DataStreams.jl</title>
      <link>https://julialang.org/blog/2015/10/datastreams/</link>
      <pubDate>Sun, 25 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2015/10/datastreams/</guid>
      <description>Data processing got ya down? Good news! The DataStreams.jl package, er, framework, has arrived!
The DataStreams processing framework provides a consistent interface for working with data, from source to sink and eventually every step in-between. It&amp;rsquo;s really about putting forth an interface (specific types and methods) to go about ingesting and transferring data sources that hopefully makes for a consistent experience for users, no matter what kind of data they&amp;rsquo;re working with.</description>
    </item>
    
    <item>
      <title>JSoC 2015 project: Automatic Differentiation in Julia with ForwardDiff.jl</title>
      <link>https://julialang.org/blog/2015/10/auto-diff-in-julia/</link>
      <pubDate>Fri, 23 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2015/10/auto-diff-in-julia/</guid>
      <description>This summer, I&amp;rsquo;ve had the good fortune to be able to participate in the first ever Julia Summer of Code (JSoC), generously sponsored by the Gordon and Betty Moore Foundation. My JSoC project was to explore the use of Julia for automatic differentiation (AD), a topic with a wide array of applications in the field of optimization.
Under the mentorship of Miles Lubin and Theodore Papamarkou, I completed a major overhaul of ForwardDiff.</description>
    </item>
    
    <item>
      <title>JSoC 2015 project: Interactive Visualizations in Julia with GLVisualize.jl</title>
      <link>https://julialang.org/blog/2015/10/glvisualize/</link>
      <pubDate>Thu, 22 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2015/10/glvisualize/</guid>
      <description>GLVisualize is an interactive visualization library that supports 2D and 3D rendering as well as building of basic GUIs. It&amp;rsquo;s written entirely in Julia and OpenGL. I&amp;rsquo;m really glad that I could continue working on this project with the support of Julia Summer of Code.
During JSoC, my main focus was on advancing GLVisualize, but also improving the surrounding infrastructure like GeometryTypes, FileIO, ImageMagick, MeshIO and FixedSizeArrays. All recorded gifs in this blog post suffer from lossy compression.</description>
    </item>
    
    <item>
      <title>JSoC 2015 project: Efficient data structures and algorithms for sequence analysis in BioJulia</title>
      <link>https://julialang.org/blog/2015/10/biojulia-sequence-analysis/</link>
      <pubDate>Wed, 21 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2015/10/biojulia-sequence-analysis/</guid>
      <description>Participant: Kenta Sato (@bicycle1885) Mentor: Daniel C. Jones (@dcjones)  Thanks to a grant from the Gordon and Betty Moore Foundation, I&amp;rsquo;ve enjoyed the Julia Summer of Code 2015 program administered by the NumFOCUS and a travel to the JuliaCon 2015 at Boston. During this program, I have created several packages about data structures and algorithms for sequence analysis, mainly targeted for bioinformatics. Even though Julia had lots of practical packages for numerical computing on floating-point numbers, it lacked efficient and compact data structures that are fundamental in bioinformatics.</description>
    </item>
    
    <item>
      <title>JSoC 2015 project: Interactive 3D Graphics in the Browser with Compose3D</title>
      <link>https://julialang.org/blog/2015/10/compose3d-threejs/</link>
      <pubDate>Tue, 20 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2015/10/compose3d-threejs/</guid>
      <description>Over the last three months, I&amp;rsquo;ve been working on Compose3D, which is an extension of the amazing Compose package to 3D. My work on Compose3D began as a project for my Computer Graphics course along with Pranav T Bhat, and by the end of the course, we had a working prototype for Compose3D with support for contexts and geometries and a very basic WebGL backend.
It has been my pleasure to have been able to continue this work under the guidance of Shashi Gowda and Simon Danisch as a part of the first ever Julia Summer of Code, generously sponsored by the Gordon and Betty Moore Foundation.</description>
    </item>
    
    <item>
      <title>JSoC 2015 project: NullableArrays.jl</title>
      <link>https://julialang.org/blog/2015/10/nullablearrays/</link>
      <pubDate>Fri, 16 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2015/10/nullablearrays/</guid>
      <description>My project under the 2015 Julia Summer of Code program has been to develop the NullableArrays package, which provides the NullableArray data type and its respective interface. I first encountered Julia earlier this year as a suggestion for which language I ought to learn as a matriculating PhD student in statistics. This summer has been an incredible opportunity for me both to develop as a young programmer and to contribute to an open-source community as full of possibility as Julia&amp;rsquo;s.</description>
    </item>
    
    <item>
      <title>Julia 0.4 Release Announcement</title>
      <link>https://julialang.org/blog/2015/10/julia-0.4-release/</link>
      <pubDate>Fri, 09 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2015/10/julia-0.4-release/</guid>
      <description>We are pleased to announce the release of Julia 0.4.0. This release contains major language refinements and numerous standard library improvements. A summary of changes is available in the NEWS log found in our main repository. We will be making regular 0.4.x bugfix releases from the release-0.4 branch of the codebase, and we recommend the 0.4.x line for users requiring a more stable Julia environment.
The Julia ecosystem continues to grow, and there are now over 700 registered packages!</description>
    </item>
    
    <item>
      <title>JuliaCon 2015 Preview - Deep Learning, 3D Printing, Parallel Computing, and so much more</title>
      <link>https://julialang.org/blog/2015/05/juliacon-preview/</link>
      <pubDate>Sat, 30 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2015/05/juliacon-preview/</guid>
      <description>JuliaCon 2015 is being held at the Massachusetts Institute of Technology from June 24th to the 28th. Get your tickets and book your hotel before June 4th to take advantage of early bird pricing.
The first ever JuliaCon was held in Chicago last year and was a great success. JuliaCon is back for 2015, this time in Cambridge, Massachusetts at MIT&amp;rsquo;s architecturally-delightful Stata Center, the home of computer science at MIT.</description>
    </item>
    
    <item>
      <title>Julia Summer of Code 2015</title>
      <link>https://julialang.org/blog/2015/05/jsoc-cfp/</link>
      <pubDate>Sat, 23 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2015/05/jsoc-cfp/</guid>
      <description>Thanks to a generous grant from the Moore Foundation, we are happy to announce the 2015 Julia Summer of Code (JSoC) administered by NumFocus. We realize that this announcement comes quite late in the summer internship process, but we are hoping to fund six projects. The duration of JSoC 2015 will be June 15-September 15. Last date for submitting applications is June 1.
Stipends will match those of the Google Summer of Code (GSoC) at $5500 for the summer plus travel support to attend this year&amp;rsquo;s JuliaCon at MIT.</description>
    </item>
    
    <item>
      <title>Julia 0.3 Release Announcement</title>
      <link>https://julialang.org/blog/2014/08/julia-0.3-release/</link>
      <pubDate>Wed, 20 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2014/08/julia-0.3-release/</guid>
      <description>We are pleased to announce the release of Julia 0.3.0. This release contains numerous improvements across the board from standard library changes to pure performance enhancements as well as an expanded ecosystem of packages as compared to the 0.2 releases. A summary of changes is available in NEWS.md found in our main repository, and binaries are now available on our main download page.
A few notable changes:
 System image caching for fast startup.</description>
    </item>
    
    <item>
      <title>JuliaCon 2014 Opening Session Presentations</title>
      <link>https://julialang.org/blog/2014/08/juliacon-opening-session/</link>
      <pubDate>Sat, 09 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2014/08/juliacon-opening-session/</guid>
      <description>Scientific Applications Session 
Tim Holy — Image Representation and Analysis Tim Holy is a Professor in the Department of Anatomy and Neurobiology at Washington University in St. Louis. He’s been involved with Julia development for over 2 years. In this presentation, Tim describes how Images.jl can be used for rapid inquiry and dissection of biomedical imaging data.
 Video: http://youtu.be/FA-1B_amwt8 Slides: https://github.com/JuliaCon/presentations/tree/master/Images GitHub: https://github.com/timholy</description>
    </item>
    
    <item>
      <title>JuliaCon 2014 Optimization Presentations</title>
      <link>https://julialang.org/blog/2014/08/juliacon-opt-session/</link>
      <pubDate>Sat, 09 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2014/08/juliacon-opt-session/</guid>
      <description>Optimization Session 
Iain Dunning / Joey Huchette — JuliaOpt - Optimization Packages for Julia Iain Dunning and Joey Huchette are both doctoral students in the Massachusetts Institute of Technology Operations Research Center, where they study constrained continuous and combinatorial numerical optimization methods and theory. In this session they present the JuliaOpt suite of optimization packages and how they interoperate. They also discuss how various Julia features enable exciting functionality in these packages.</description>
    </item>
    
    <item>
      <title>Fast Numeric Computation in Julia</title>
      <link>https://julialang.org/blog/2013/09/fast-numeric/</link>
      <pubDate>Wed, 04 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2013/09/fast-numeric/</guid>
      <description>Working on numerical problems daily, I have always dreamt of a language that provides an elegant interface while allowing me to write codes that run blazingly fast on large data sets. Julia is a language that turns this dream into a reality. With Julia, you can focus on your problem, keep your codes clean, and more importantly, write fast codes without diving into lower level languages such as C or Fortran even when performance is critical.</description>
    </item>
    
    <item>
      <title>Building GUIs with Julia, Tk, and Cairo, Part I</title>
      <link>https://julialang.org/blog/2013/05/graphical-user-interfaces-part1/</link>
      <pubDate>Thu, 23 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2013/05/graphical-user-interfaces-part1/</guid>
      <description>This is the first of two blog posts designed to walk users through the process of creating GUIs in Julia. Those following Julia development will know that plotting in Julia is still evolving, and one could therefore expect that it might be premature to build GUIs with Julia. My own recent experience has taught me that this expectation is wrong: compared with building GUIs in Matlab (my only previous GUI-writing experience), Julia already offers a number of quite compelling advantages.</description>
    </item>
    
    <item>
      <title>Building GUIs with Julia, Tk, and Cairo, Part II</title>
      <link>https://julialang.org/blog/2013/05/graphical-user-interfaces-part2/</link>
      <pubDate>Thu, 23 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2013/05/graphical-user-interfaces-part2/</guid>
      <description>Drawing, painting, and plotting In this installment, we&amp;rsquo;ll cover both low-level graphics (using Cairo) and plotting graphs inside GUIs (using Winston). Here again we&amp;rsquo;re relying on infrastructure built by many people, including Jeff Bezanson, Mike Nolta, and Keno Fisher.
Cairo The basics The display of the image is handled by Cairo, a C library for two-dimensional drawing. Julia&amp;rsquo;s Cairo wrapper isn&amp;rsquo;t currently documented, so let&amp;rsquo;s walk through a couple of basics first.</description>
    </item>
    
    <item>
      <title>Passing Julia Callback Functions to C</title>
      <link>https://julialang.org/blog/2013/05/callback/</link>
      <pubDate>Fri, 10 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2013/05/callback/</guid>
      <description>One of the great strengths of Julia is that it is so easy to call C code natively, with no special &amp;ldquo;glue&amp;rdquo; routines or overhead to marshal arguments and convert return values. For example, if you want to call GNU GSL to compute a special function like a Debye integral, it is as easy as:
debye_1(x) = ccall((:gsl_sf_debye_1,:libgsl), Cdouble, (Cdouble,), x) at which point you can compute debye_1(2), debye_1(3.7), and so on.</description>
    </item>
    
    <item>
      <title>Put This In Your Pipe</title>
      <link>https://julialang.org/blog/2013/04/put-this-in-your-pipe/</link>
      <pubDate>Mon, 08 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2013/04/put-this-in-your-pipe/</guid>
      <description>In a previous post, I talked about why &amp;ldquo;shelling out&amp;rdquo; to spawn a pipeline of external programs via an intermediate shell is a common cause of bugs, security holes, unnecessary overhead, and silent failures. But it&amp;rsquo;s so convenient! Why can&amp;rsquo;t running pipelines of external programs be convenient and safe? Well, there&amp;rsquo;s no real reason, actually. The shell itself manages to construct and execute pipelines quite well. In principle, there&amp;rsquo;s nothing stopping high-level languages from doing it at least as well as shells do – the common ones just don&amp;rsquo;t by default, instead requiring users to make the extra effort to use external programs safely and correctly.</description>
    </item>
    
    <item>
      <title>Distributed Numerical Optimization</title>
      <link>https://julialang.org/blog/2013/04/distributed-numerical-optimization/</link>
      <pubDate>Fri, 05 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2013/04/distributed-numerical-optimization/</guid>
      <description>This post walks through the parallel computing functionality of Julia to implement an asynchronous parallel version of the classical cutting-plane algorithm for convex (nonsmooth) optimization, demonstrating the complete workflow including running on both Amazon EC2 and a large multicore server. I will quickly review the cutting-plane algorithm and will be focusing primarily on parallel computation patterns, so don&amp;rsquo;t worry if you&amp;rsquo;re not familiar with the optimization side of things.</description>
    </item>
    
    <item>
      <title>Videos from the Julia tutorial at MIT</title>
      <link>https://julialang.org/blog/2013/03/julia-tutorial-mit/</link>
      <pubDate>Sat, 30 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2013/03/julia-tutorial-mit/</guid>
      <description>We held a two day Julia tutorial at MIT in January 2013, which included 10 sessions. MIT Open Courseware and MIT-X graciously provided support for recording of these lectures, so that the wider Julia community can benefit from these sessions.
Julia Lightning Round (slides) This session is a rapid introduction to julia, using a number of lightning rounds. It uses a number of short examples to demonstrate syntax and features, and gives a quick feel for the language.</description>
    </item>
    
    <item>
      <title>Efficient Aggregates in Julia</title>
      <link>https://julialang.org/blog/2013/03/efficient-aggregates/</link>
      <pubDate>Tue, 05 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2013/03/efficient-aggregates/</guid>
      <description>We recently introduced an exciting feature that has been in planning for some time: immutable aggregate types. In fact, we have been planning to do this for so long that this feature is the subject of our issue #13 on GitHub, out of more than 2400 total issues so far.
Essentially, this feature drastically reduces the overhead of user-defined types that represent small number-like values, or that wrap a small number of other objects.</description>
    </item>
    
    <item>
      <title>Design and implementation of Julia</title>
      <link>https://julialang.org/blog/2012/08/design-and-implementation-of-julia/</link>
      <pubDate>Thu, 16 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2012/08/design-and-implementation-of-julia/</guid>
      <description>We describe the design and implementation of Julia in our first paper - Julia: A Fast Dynamic Language for Technical Computing. This is work in progress and comments are appreciated.</description>
    </item>
    
    <item>
      <title>New York Open Stats Meetup</title>
      <link>https://julialang.org/blog/2012/04/nyc-open-stats-meetup-announcement/</link>
      <pubDate>Wed, 18 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2012/04/nyc-open-stats-meetup-announcement/</guid>
      <description>I&amp;rsquo;ll be giving a talk on Julia at the New York Open Statistical Programming Meetup on May 1st. After my presentation, John Myles White and Shane Conway are going to give followup demos of statistical applications using Julia. Then we&amp;rsquo;re going to hang out and grab drinks nearby. Thanks to Harlan Harris and Drew Conway for setting the whole thing up!
Announcement:
After a brief hiatus, we are very excited to announce our May meetup will feature one of the hottest new languages in statistical computing: Julia.</description>
    </item>
    
    <item>
      <title>Lang.NEXT Announcement</title>
      <link>https://julialang.org/blog/2012/03/lang-next-talk-announcement/</link>
      <pubDate>Sat, 24 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2012/03/lang-next-talk-announcement/</guid>
      <description>Jeff and I will be giving a presentation on Julia at the upcoming Lang.NEXT conference, a gathering of &amp;ldquo;programming language design experts and enthusiasts&amp;rdquo; featuring &amp;ldquo;talks, panels and discussion on leading programming language work from industry and research.&amp;rdquo; We are honored and excited to have been invited to speak at an event alongside so many programming language luminaries.
Abstract:
Julia is a dynamic language in the tradition of Lisp, Perl, Python and Ruby.</description>
    </item>
    
    <item>
      <title>Shelling Out Sucks</title>
      <link>https://julialang.org/blog/2012/03/shelling-out-sucks/</link>
      <pubDate>Sun, 11 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2012/03/shelling-out-sucks/</guid>
      <description>Spawning a pipeline of connected programs via an intermediate shell — a.k.a. &amp;ldquo;shelling out&amp;rdquo; — is a really convenient and effective way to get things done. It&amp;rsquo;s so handy that some &amp;ldquo;glue languages,&amp;rdquo; like Perl and Ruby, even have special syntax for it (backticks). However, shelling out is also a common source of bugs, security holes, unnecessary overhead, and silent failures. Here are the three reasons why shelling out is problematic:</description>
    </item>
    
    <item>
      <title>Stanford Talk Video</title>
      <link>https://julialang.org/blog/2012/03/stanford-talk-video/</link>
      <pubDate>Thu, 01 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2012/03/stanford-talk-video/</guid>
      <description>Jeff gave his previously announced, invited talk at Stanford yesterday and the video is available here. Congrats, Jeff!</description>
    </item>
    
    <item>
      <title>Stanford Talk Announcement</title>
      <link>https://julialang.org/blog/2012/02/talk-announcement/</link>
      <pubDate>Mon, 27 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2012/02/talk-announcement/</guid>
      <description>I will be speaking about Julia at the Stanford EE Computer Systems Colloquium on Wednesday, February 29 at 4:15PM PST. The title of the talk is Julia: A Fast Dynamic Language For Technical Computing.
Abstract:
 Julia is a general-purpose, high-level, dynamic language, designed from the start to take advantage of techniques for executing dynamic languages at statically-compiled language speeds. As a result the language has a more powerful type system, and generally provides better type information to the compiler.</description>
    </item>
    
    <item>
      <title>Why We Created Julia</title>
      <link>https://julialang.org/blog/2012/02/why-we-created-julia/</link>
      <pubDate>Tue, 14 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2012/02/why-we-created-julia/</guid>
      <description>In short, because we are greedy.
We are power Matlab users. Some of us are Lisp hackers. Some are Pythonistas, others Rubyists, still others Perl hackers. There are those of us who used Mathematica before we could grow facial hair. There are those who still can&amp;rsquo;t grow facial hair. We&amp;rsquo;ve generated more R plots than any sane person should. C is our desert island programming language.
We love all of these languages; they are wonderful and powerful.</description>
    </item>
    
    <item>
      <title>为什么我们要创造Julia (Simplified Chinese)</title>
      <link>https://julialang.org/blog/2012/02/why-we-created-julia-zh_cn/</link>
      <pubDate>Tue, 14 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/blog/2012/02/why-we-created-julia-zh_cn/</guid>
      <description>这是一篇重译，参考了2012年的一篇豆瓣（链接在最后）。
 简短来讲，是因为我们很贪婪。
我们之中有些是使用MATLAB的重量级用户，有些是来自Lisp的极客，还有一些是来自Python和Ruby的魔法师，甚至还有来自Perl社区的大魔法师。我们之中还有从胡子都没长齐时就开始使用Mathematica的。其中的有些人现在都没长胡子喱！我们像是疯了一样用R画了越来越多的图，而C是我们的硬核摇滚（也有大杀器之意）。
我们热爱所有这些语言，他们实在很好很强大。在我们从事的领域（科学计算，机器学习，数据挖掘，大规模线性代数计算，分布式和并行计算）中，每一种语言都对某一项工作的一项特定需求非常完美，但是却无法胜任其它需求。于是使用什么语言都需要我们去权衡。
而我们很贪婪，我们还想要更多。
我们想要的是一个自由开源的语言，并且它同时拥有C的速度和Ruby的动态性；我们想要一个具有[同像性]()（可以将语言的脚本本身当作数据进行处理）的语言，它有着真正的和lisp一样的宏，但是却像Matlab一样有着显然的，类似于数学表达式的标记；我们想要一个既可以像Python一样作为通用编程语言的工具，又可以像R那样适用于统计分析，能像Perl那样自然地处理字符串，能像Matlab那样给力地处理矩阵运算，它还要能像shell一样作为胶水将各种程序粘合在一起；我们想要一个简单易学的语言，同时它还能让最苛刻的魔法师们（hackers）开心。我们希望它是交互式的，但我们也希望它能被编译。
（我们刚刚有提它要和C一样快嘛？！）
当我们在构思这些需求的时候，我们发现它还得有Hadoop这样强大的分布式能力，却不想要Hadoop里面那些冗长Jave和XML模板，更不想被被迫在几个GB的日志文件和几百台机器里找bug。我们不想要那些令人费解的层次结构。我们想让简单的标量循环能被编译成仅用寄存器和一块CPU的干净的机器码。我们希望简单地写下A*B就能够在成千上万的机器上用成千上万地运算来计算这个庞大的矩阵乘法。
如无必要，那就不用声明类型。但当我们需要多态函数（polymorphic functions）时，我们也想要用泛型编程（generic programming）仅仅书写一次算法，就能够在无限多的类型上使用。我们想要多重派发（multiple dispatch）来为一个函数所有可能的参数选出最佳的执行方法。这些参数可能有着不同定义，不同类型，但是却有着相同功能。在拥有以上能力的同时，我们还希望这种语言简单，干净。
要求有点多，是不是？
尽管我们意识到了自己有多贪心，我们还是想要拥有这些功能。大概在两年半之前，我们开始创造这种能满足我们贪念的语言。它还没有完工——但是已经可以发布一个1.0版本了（其实等了6年才要发布）——我们创造的这个语言叫做Julia。它已经实现了我们这次乱七八糟需求的90%，而现在她需要来自更多人的乱七八糟的需求，来让她走得更远。如果你也是一位贪心不足，不可理喻，需索无度的码场二逼青年，希望你能来试试这个东东。
作者：Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman
译者：Roger
翻译自：Why we create Julia
参考自：豆瓣：为什么我们要创造Julia</description>
    </item>
    
    <item>
      <title></title>
      <link>https://julialang.org/diversity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/diversity/</guid>
      <description>Diversity As a NumFocus supported project, we abide by their Code of Conduct and Diversity Statment:
 NumFOCUS welcomes and encourages participation in our community by people of all backgrounds and identities. We are committed to promoting and sustaining a culture that values mutual respect, tolerance, and learning, and we work together as a community to help each other live out these values.
We have created this diversity statement because we believe that a diverse community is stronger, more vibrant, and produces better software and better science.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://julialang.org/jsoc/gsod/projects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsod/projects/</guid>
      <description>Julia&amp;rsquo;s Google Season of Docs Projects Below are the projects which have been proposed for Google Season of Docs.
Differential Equations DifferentialEquations.jl is a widely used Julia library for solving ordinary, stochastic, delay, any many more types of differential equations. Below are the proposed projects in this area. Technical writers may wish to do a combination of these projects. The mentor for the JuliaDiffEq projects is Chris Rackauckas.
Updated Documentation and Doc Testing DifferentialEquations.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://julialang.org/learning/code-examples/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/learning/code-examples/</guid>
      <description>Check out the benchmark page to learn more about Julia&amp;rsquo;s performance versus other languages
julia&amp;gt; function mandelbrot(a) z = 0 for i=1:50 z = z^2 + a end return z end mandelbrot (generic function with 1 method) julia&amp;gt; for y=1.0:-0.05:-1.0 for x=-2.0:0.0315:0.5 abs(mandelbrot(complex(x, y))) &amp;lt; 2 ? print(&amp;#34;*&amp;#34;) : print(&amp;#34;&amp;#34;) end println() end ** ****** ******** ****** ******** ** * *** ***************** ************************ *** **************************** ****************************** ****************************** ************************************ * ********************************** ** ***** * ********************************** *********** ************************************ ************** ************************************ *************************************************** ***************************************************** *********************************************************************** ***************************************************** *************************************************** ************** ************************************ *********** ************************************ ** ***** * ********************************** * ********************************** ************************************ ****************************** ****************************** **************************** ************************ *** *** ***************** ******** ** * ****** ******** ****** ** # From http://rosettacode.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://julialang.org/manual/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/manual/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://julialang.org/research/maw16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/maw16/</guid>
      <description>Overdeepenings are a hallmark glacial landform of broad geomorphologlogical and glaciological interest. Their formation mechanism has not yet been fully uncovered, but subglacial drainage is likely a key factor. One prominent hypothesis states that the depth of an overdeepening stabilizes at the supercooling threshold. This threshold is reached when the adverse bed slope terminating an overdeepening is sufficiently large to shut down the efficient, channelized drainage system. Classic theory puts this threshold at a ratio of bed to surface slope of − 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://julialang.org/research/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/readme/</guid>
      <description>To add a publication to the website, create a markdown file with YAML frontmatter in this directory. By convention, the file is named according to the author initials + year, e.g. _publications/ABC17.md.
The frontmatter is sort of a YAML version of bibtex (but using unicode instead of TeX).
The following fields are required: - title: the name of the paper - authors: the list of the authors. Note that this should be a YAML list, not &amp;ldquo;and&amp;rdquo; separated like bibtex - year: the year should be quoted (&amp;ldquo;YYYY&amp;rdquo;)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://julialang.org/soc/ideas-page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/soc/ideas-page/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3264 Conics in a Second</title>
      <link>https://julialang.org/research/bst19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bst19/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A Comparison of Programming Languages in Economics</title>
      <link>https://julialang.org/research/asb16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/asb16/</guid>
      <description>We solve the stochastic neoclassical growth model, the workhorse of modern macroeconomics, using C++11, Fortran 2008, Java, Julia, Python, Matlab, Mathematica, and R. We implement the same algorithm, value function iteration with grid search, in each of the languages. We report the execution times of the codes in a Mac and in a Windows computer and brieáy comment on the strengths and weaknesses of each language.</description>
    </item>
    
    <item>
      <title>A highly accurate pixel-based FRAP model based on spectral-domain numerical methods</title>
      <link>https://julialang.org/research/rlkgl19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/rlkgl19/</guid>
      <description>We introduce a new, to our knowledge, numerical model based on spectral methods for analysis of fluorescence recovery after photobleaching data. The model covers pure diffusion and diffusion and binding (reaction-diffusion) with immobile binding sites, as well as arbitrary bleach region shapes. Fitting of the model is supported using both conventional recovery-curve-based estimation and pixel-based estimation, in which all individual pixels in the data are utilized. The model explicitly accounts for multiple bleach frames, diffusion (and binding) during bleaching, and bleaching during imaging.</description>
    </item>
    
    <item>
      <title>A method to reduce the rejection rate in Monte Carlo Markov chains</title>
      <link>https://julialang.org/research/b17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/b17/</guid>
      <description>We present a method for Monte Carlo sampling on systems with discrete variables (focusing in the Ising case), introducing a prior on the candidate moves in a Metropolis–Hastings scheme which can significantly reduce the rejection rate, called the reduced-rejection-rate (RRR) method. The method employs same probability distribution for the choice of the moves as rejection-free schemes such as the method proposed by Bortz, Kalos and Lebowitz (BKL) (1975 J. Comput. Phys.</description>
    </item>
    
    <item>
      <title>A note on Julia and MPI, with code examples</title>
      <link>https://julialang.org/research/mc16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/mc16/</guid>
      <description>This note explains how MPI may be used with the Julia programming language. An example of a simple Monte Carlo study is presented, with code. The code is intended to serve as a general purpose template for more relevant applications. A second example shows how the template code may be adapted to perform a Monte Carlo study of the properties of an approximate Bayesian computing estimator of actual research interest. All of the code is available at https://github.</description>
    </item>
    
    <item>
      <title>A practical framework for infinite-dimensional linear algebra</title>
      <link>https://julialang.org/research/ot14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/ot14/</guid>
      <description>We describe a framework for solving a broad class of infinite-dimensional linear equations, consisting of almost banded operators, which can be used to represent linear ordinary differential equations with general boundary conditions. The framework contains a data structure on which row operations can be performed, allowing for the solution of linear equations by the adaptive QR approach. The algorithm achieves O(nopt) complexity, where nopt is the number of degrees of freedom required to achieve a desired accuracy, which is determined adaptively.</description>
    </item>
    
    <item>
      <title>A two-step linear programming model for energy-efficient timetables in metro railway networks</title>
      <link>https://julialang.org/research/dtp16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/dtp16/</guid>
      <description>In this paper we propose a novel two-step linear optimization model to calculate energy-efficient timetables in metro railway networks. The resultant timetable minimizes the total energy consumed by all trains and maximizes the utilization of regenerative energy produced by braking trains, subject to the constraints in the railway network. In contrast to other existing models, which are NP-hard, our model is computationally the most tractable one being a linear program. We apply our optimization model to different instances of service PES2-SFM2 of line 8 of Shanghai Metro network spanning a full service period of one day (18 h) with thousands of active trains.</description>
    </item>
    
    <item>
      <title>Accurate eigenvalue decomposition of real symmetric arrowhead matrices and applications</title>
      <link>https://julialang.org/research/jsb15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/jsb15/</guid>
      <description>We present a new algorithm for solving the eigenvalue problem for an n × n real symmetric arrowhead matrix. The algorithm computes all eigenvalues and all components of the corresponding eigenvectors with high relative accuracy in O(n^2) operations under certain circumstances. The algorithm is based on a shift-and-invert approach. Only a single element of the inverse of the shifted matrix eventually needs to be computed with double the working precision. Each eigenvalue and the corresponding eigenvector can be computed separately, which makes the algorithm adaptable for parallel computing.</description>
    </item>
    
    <item>
      <title>Adaptive methods for stochastic differential equations via natural embeddings and rejection sampling with memory</title>
      <link>https://julialang.org/research/rn17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/rn17/</guid>
      <description>Adaptive time-stepping with high-order embedded Runge-Kutta pairs and rejection sampling provides efficient approaches for solving differential equations. While many such methods exist for solving deterministic systems, little progress has been made for stochastic variants. One challenge in developing adaptive methods for stochastic differential equations (SDEs) is the construction of embedded schemes with direct error estimates. We present a new class of embedded stochastic Runge-Kutta (SRK) methods with strong order 1.5 which have a natural embedding of strong order 1.</description>
    </item>
    
    <item>
      <title>An analytic approximation of the feasible space of metabolic networks</title>
      <link>https://julialang.org/research/bmp17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bmp17/</guid>
      <description>Assuming a steady-state condition within a cell, metabolic fluxes satisfy an underdetermined linear system of stoichiometric equations. Characterizing the space of fluxes that satisfy such equations along with given bounds (and possibly additional relevant constraints) is con- sidered of utmost importance for the understanding of cellular metabolism. Extreme values for each individual flux can be computed with linear programming (as flux balance analysis), and their marginal distributions can be approximately computed with Monte Carlo sampling.</description>
    </item>
    
    <item>
      <title>An automatic deployment support for processing remote sensing data in the Cloud</title>
      <link>https://julialang.org/research/lrof18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/lrof18/</guid>
      <description>Master/Worker distributed programming model enables huge remote sensing data processing by assigning tasks to Workers in which data is stored. Cloud computing features include the deployment of Workers by using virtualized technologies such as virtual machines and containers. These features allow programmers to configure, create, and start virtual resources for instance. In order to develop remote sensing applications by taking advantage of high-level programming languages (e.g., R, Matlab, and Julia), users have to manually address Cloud resource deployment.</description>
    </item>
    
    <item>
      <title>Annealed Important Sampling for Models with Latent Variables</title>
      <link>https://julialang.org/research/tspk14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/tspk14/</guid>
      <description>This paper is concerned with Bayesian inference when the likelihood is analytically intractable but can be unbiasedly estimated. We propose an annealed importance sampling procedure for estimating expectations with respect to the posterior. The proposed algorithm is useful in cases where finding a good proposal density is challenging, and when estimates of the marginal likelihood are required. The effect of likelihood estimation is investigated, and the results provide guidelines on how to set up the precision of the likelihood estimation in order to optimally implement the procedure.</description>
    </item>
    
    <item>
      <title>Application Guidelines</title>
      <link>https://julialang.org/jsoc/guidelines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/guidelines/</guid>
      <description>Before the Application Before you apply, it&amp;rsquo;s a good idea to get in touch with the Julia community. Ask questions on Discourse or join the Julia Slack to get connected with potential mentors to help find interesting projects. The Slack channel #jsoc is dedicated to helping students get the help they need. Additionally, you should make use of these connections to start making some small contributions and progress on your project early on.</description>
    </item>
    
    <item>
      <title>Approximate Bayesian computation for estimating number concentrations of monodisperse nanoparticles in suspension by optical microscopy</title>
      <link>https://julialang.org/research/rzrb16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/rzrb16/</guid>
      <description>We present an approximate Bayesian computation scheme for estimating number concentrations of monodisperse diffusing nanoparticles in suspension by optical particle tracking microscopy. The method is based on the probability distribution of the time spent by a particle inside a detection region. We validate the method on suspensions of well-controlled reference particles. We illustrate its usefulness with an application in gene therapy, applying the method to estimate number concentrations of plasmid DNA molecules and the average number of DNA molecules complexed with liposomal drug delivery particles.</description>
    </item>
    
    <item>
      <title>ARCH-COMP18 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics</title>
      <link>https://julialang.org/research/abcfffklmrss18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/abcfffklmrss18/</guid>
      <description>This report presents the results of a friendly competition for formal verification of continuous and hybrid systems with linear continuous dynamics. The friendly competition took place as part of the workshop Applied Verification for Continuous and Hybrid Systems (ARCH) in 2018. In its second edition, 9 tools have been applied to solve six different benchmark problems in the category for linear continuous dynamics (in alphabetical order): CORA, CORA/SX, C2E2, Flow*, HyDRA, Hylaa, Hylaa-Continuous, JuliaReach, SpaceEx, and XSpeed.</description>
    </item>
    
    <item>
      <title>ARCH-COMP19 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics</title>
      <link>https://julialang.org/research/abffkrss19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/abffkrss19/</guid>
      <description>This report presents the results of a friendly competition for formal verification of continuous and hybrid systems with linear continuous dynamics. The friendly competition took place as part of the workshop Applied Verification for Continuous and Hybrid Systems (ARCH) in 2019. In its third edition, seven tools have been applied to solve six different benchmark problems in the category for linear continuous dynamics (in alphabetical order): CORA, CORA/SX, HyDRA, Hylaa, JuliaReach, SpaceEx, and XSpeed.</description>
    </item>
    
    <item>
      <title>ARCH-COMP19 Category Report: Continuous and Hybrid Systems with Nonlinear Dynamics</title>
      <link>https://julialang.org/research/iabccfgkss19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/iabccfgkss19/</guid>
      <description>We present the results of a friendly competition for formal verification of continuous and hybrid systems with nonlinear continuous dynamics. The friendly competition took place as part of the workshop Applied Verification for Continuous and Hybrid Systems (ARCH) in 2019. In this year, 6 tools Ariadne, CORA, DynIbex, Flow*, Isabelle/HOL, and JuliaReach (in alphabetic order) participated. They are applied to solve reachability analysis problems on four benchmark problems, one of them with hybrid dynamics.</description>
    </item>
    
    <item>
      <title>Array operators using multiple dispatch: a design methodology for array implementations in dynamic languages</title>
      <link>https://julialang.org/research/bckse14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bckse14/</guid>
      <description>Arrays are such a rich and fundamental data type that they tend to be built into a language, either in the compiler or in a large low-level library. Defining this functionality at the user level instead provides greater flexibility for application domains not envisioned by the language designer. Only a few languages, such as C++ and Haskell, provide the necessary power to define n-dimensional arrays, but these systems rely on compile-time abstraction, sacrificing some flexibility.</description>
    </item>
    
    <item>
      <title>Automatic Full Compilation of Julia Programs and ML Models to Cloud TPUs</title>
      <link>https://julialang.org/research/fs18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/fs18/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Autonomous Parking Using Optimization-Based Collision Avoidance</title>
      <link>https://julialang.org/research/zaaf18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/zaaf18/</guid>
      <description>We present an optimization-based approach for autonomous parking. Building on recent advances in the area of optimization-based collision avoidance (OBCA), we show that the autonomous parking problem can be formulated as a smooth non-convex optimization problem. Unfortunately, such problems are numerically challenging to solve in general and require appropriate warm-starting. To address this limitation, we propose a novel algorithm called Hierarchical OBCA (H-OBCA). The main idea is to first use a generic path planner, such as Hybrid A, to compute a coarse trajectory using a simplified vehicle model and by discretizing the state-input space.</description>
    </item>
    
    <item>
      <title>Bayesian estimation of discretely observed multi-dimensional diffusion processes using guided proposals</title>
      <link>https://julialang.org/research/ms14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/ms14/</guid>
      <description>Bayesian estimation of parameters of a diffusion based on discrete time observations poses a difficult problem due to the lack of a closed form expression for the likelihood. Data-augmentation has been proposed for obtaining draws from the posterior distribution of the parameters. Within this approach, the discrete time observations are augmented with diffusion bridges connecting these observations. This poses two challenges: (i) efficiently generating diffusion bridges; (ii) if unknown parameters appear in the diffusion coefficient, then direct implementation of data-augmentation results in an induced Markov chain which is reducible.</description>
    </item>
    
    <item>
      <title>Broyden&#39;s method for nonlinear eigenproblems</title>
      <link>https://julialang.org/research/j19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/j19/</guid>
      <description>Broyden&amp;rsquo;s method is a general method commonly used for nonlinear systems of equations when very little information is available about the problem. We develop an approach based on Broyden&amp;rsquo;s method for the structure appearing in nonlinear eigenvalue problems. Our approach is designed for problems where the evaluation of a matrix vector product is computationally expensive, essentially as expensive as solving the corresponding linear system of equations. We show how the structure of the Jacobian matrix can be incorporated into the algorithm to improve convergence.</description>
    </item>
    
    <item>
      <title>Case study of multiple trace transform implementations</title>
      <link>https://julialang.org/research/bdfp2014/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bdfp2014/</guid>
      <description>Scientific algorithms are designed and implemented in a variety of programming languages. Depending on the exact application, some languages are a better choice than others: some offer a productive environment while others focus on performance. Selecting a language is often difficult, with poor choices resulting in much higher development times.
By implementing a case study algorithm in multiple programming languages, we compare their pros and cons. As a case study, we selected the trace transform, an image processing algorithm from the widely used class of integral transforms.</description>
    </item>
    
    <item>
      <title>Cataloging the visible universe through Bayesian inference at petascale</title>
      <link>https://julialang.org/research/rpfnetal2018/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/rpfnetal2018/</guid>
      <description></description>
    </item>
    
    <item>
      <title>CauseMap: Fast inference of causality from complex time series</title>
      <link>https://julialang.org/research/mh15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/mh15/</guid>
      <description>Background: Establishing health-related causal relationships is a central pursuit in biomedical research. Yet, the interdependent non-linearity of biological systems renders causal dynamics laborious and at times impractical to disentangle. This pursuit is further impeded by the dearth of time series that are sufficiently long to observe and understand recurrent patterns of flux. However, as data generation costs plummet and technologies like wearable devices democratize data collection, we anticipate a coming surge in the availability of biomedically-relevant time series data.</description>
    </item>
    
    <item>
      <title>CellFishing.jl: an ultrafast and scalable cell search method for single-cell RNA sequencing</title>
      <link>https://julialang.org/research/gb19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/gb19/</guid>
      <description>Recent technical improvements in single-cell RNA sequencing (scRNA-seq) have enabled massively parallel profiling of transcriptomes, thereby promoting large-scale studies encompassing a wide range of cell types of multicellular organisms. With this background, we propose CellFishing.jl, a new method for searching atlas-scale datasets for similar cells and detecting noteworthy genes of query cells with high accuracy and throughput. Using multiple scRNA-seq datasets, we validate that our method demonstrates comparable accuracy to and is markedly faster than the state-of-the-art software.</description>
    </item>
    
    <item>
      <title>Certifying numerical estimates of spectral gaps</title>
      <link>https://julialang.org/research/kn18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/kn18/</guid>
      <description>We establish a lower bound on the spectral gap of the Laplace operator on special linear groups using conic optimisation. In particular, this provides a constructive (but computer assisted) proof that these groups have Kazhdan property (T). A software for such optimisation for other finitely presented groups is provided.</description>
    </item>
    
    <item>
      <title>Characterizing steady states of genome-scale metabolic networks in continuous cell cultures</title>
      <link>https://julialang.org/research/jfc17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/jfc17/</guid>
      <description>In the continuous mode of cell culture, a constant flow carrying fresh media replaces culture fluid, cells, nutrients and secreted metabolites. Here we present a model for continuous cell culture coupling intra-cellular metabolism to extracellular variables describing the state of the bioreactor, taking into account the growth capacity of the cell and the impact of toxic byproduct accumulation. We provide a method to determine the steady states of this system that is tractable for metabolic networks of arbitrary complexity.</description>
    </item>
    
    <item>
      <title>CloudArray: Easing huge image processing</title>
      <link>https://julialang.org/research/lfors17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/lfors17/</guid>
      <description>Image processing algorithms require high processing capabilities. Most of these algorithms use linear algebraic operations (BLAS), for instance, through the Combinatorial BLAS [1], and Elemental [2] programming supports. Such operations may require unavailable computer processing resources. CloudArray is funded by Microsoft Azure Research Award, Brazilian National Council for Scientific and Technological Development (CNPq), and Alagoas Research Foundation (FAPEAL).</description>
    </item>
    
    <item>
      <title>Compiler Projects – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/compiler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/compiler/</guid>
      <description>Compiler Projects – Summer of Code Thread-safety There are many remaining components that need to be updated to use thread-safe algorithms before Julia&amp;rsquo;s threading will be stable for general usage. Some basic data-structures (such as the TypeMap) are missing correct RCU and memory barriers to ensure race-free answers. The realloc operation for arrays (i.e. resize!) may be more reliable if it was implemented using RCU malloc (delaying the free until a gc-safepoint has been reached on all threads).</description>
    </item>
    
    <item>
      <title>Compositional Security Modelling</title>
      <link>https://julialang.org/research/cpw14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/cpw14/</guid>
      <description>Security managers face the challenge of formulating and implementing policies that deliver their desired system security postures — for example, their preferred balance of confidentiality, integrity, and availability — within budget (monetary and otherwise). In this paper, we describe a security modelling methodology, grounded in rigorous mathematical systems modelling and economics, that captures the managers’ policies and the behavioural choices of agents operating within the system. Models are executable, so allowing systematic experimental exploration of the system-policy co-design space, and compositional, so managing the complexity of large-scale systems.</description>
    </item>
    
    <item>
      <title>Computational high-throughput screening of fluid permeability in heterogeneous fiber materials</title>
      <link>https://julialang.org/research/rsllbhgl16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/rsllbhgl16/</guid>
      <description>We explore computational high-throughput screening as a design strategy for heterogeneous, isotropic fiber materials. Fluid permeability, a key property in the design of soft porous materials, is systematically studied using a multi-scale lattice Boltzmann framework. After characterizing microscopic permeability as a function of solid volume fraction in the microstructure, we perform high-throughput computational screening of in excess of 35 000 macrostructures consisting of a continuous bulk interrupted by spherical/elliptical domains with either lower or higher microscopic permeability (hence with two distinct microscopic solid volume fractions and therefore two distinct microscopic permeabilities) to assess which parameters determine macroscopic permeability for a fixed average solid volume fraction.</description>
    </item>
    
    <item>
      <title>Computational screening of diffusive transport in nanoplatelet-filled composites: Use of graphene to enhance polymer barrier properties</title>
      <link>https://julialang.org/research/rgkl17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/rgkl17/</guid>
      <description>Motivated by the substantial interest in various fillers to enhance the barrier properties of polymeric films, especially graphene derivatives, we perform a computational screening of obstructed diffusion to explore the design parameter space of nanoplatelet-filled composites synthesized in silico. As a model for the nanoplatelets, we use circular and elliptical nonoverlapping and impermeable flat disks, and diffusion is stochastically simulated using a random-walk model, from which the effective diffusivity is calculated.</description>
    </item>
    
    <item>
      <title>Computing Energy Eigenvalues of Anharmonic Oscillators using the Double Exponential Sinc collocation Method</title>
      <link>https://julialang.org/research/gss14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/gss14/</guid>
      <description>A quantum anharmonic oscillator is defined by the Hamiltonian H, where the potential is given by V. Using the Sinc collocation method combined with the double exponential transformation, we develop a method to efficiently compute highly accurate approximations of energy eigenvalues for anharmonic oscillators. Convergence properties of the proposed method are presented. Using the principle of minimal sensitivity, we introduce an alternate expression for the mesh size for the Sinc collocation method which improves considerably the accuracy in computing eigenvalues for potentials with multiple wells.</description>
    </item>
    
    <item>
      <title>Computing in Operations Research Using Julia</title>
      <link>https://julialang.org/research/ld13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/ld13/</guid>
      <description>The state of numerical computing is currently characterized by a divide between highly efficient yet typically cumbersome low-level languages such as C, C++, and Fortran and highly expressive yet typically slow high-level languages such as Python and MATLAB. This paper explores how Julia, a modern programming language for numerical computing which claims to bridge this divide by incorporating recent advances in language and compiler design (such as just-in-time compilation), can be used for implementing software and algorithms fundamental to the field of operations research, with a focus on mathematical optimization.</description>
    </item>
    
    <item>
      <title>Construction of quasipotentials for stochastic dynamical systems: An optimization approach</title>
      <link>https://julialang.org/research/rdb18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/rdb18/</guid>
      <description>The construction of effective and informative landscapes for stochastic dynamical systems has proven a long-standing and complex problem. In many situations, the dynamics may be described by a Langevin equation while constructing a landscape comes down to obtaining the quasipotential, a scalar function that quantifies the likelihood of reaching each point in the state space. In this work we provide a novel method for constructing such landscapes by extending a tool from control theory: the sum-of-squares method for generating Lyapunov functions.</description>
    </item>
    
    <item>
      <title>Convex Optimization in Julia</title>
      <link>https://julialang.org/research/umzhdb14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/umzhdb14/</guid>
      <description>This paper describes Convex, a convex optimization modeling framework in Julia. Convex translates problems from a user-friendly functional language into an abstract syntax tree describing the problem. This concise representation of the global structure of the problem allows Convex to infer whether the problem complies with the rules of disciplined convex programming (DCP), and to pass the problem to a suitable solver. These operations are carried out in Julia using multiple dispatch, which dramatically reduces the time required to verify DCP compliance and to parse a problem into conic form.</description>
    </item>
    
    <item>
      <title>DiffEq Projects – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/diffeq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/diffeq/</guid>
      <description>DiffEq Projects – Summer of Code Native Julia ODE, SDE, DAE, DDE, and (S)PDE Solvers The DifferentialEquations.jl ecosystem has an extensive set of state-of-the-art methods for solving differential equations. By mixing native methods and wrapped methods under the same dispatch system, DifferentialEquations.jl serves both as a system to deploy and research the most modern efficient methodologies. While most of the basic methods have been developed and optimized, many newer methods need high performance implementations and real-world tests of their efficiency claims.</description>
    </item>
    
    <item>
      <title>DifferentialEquations.jl – A Performant and Feature-Rich Ecosystem for Solving Differential Equations in Julia</title>
      <link>https://julialang.org/research/rn217/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/rn217/</guid>
      <description>DifferentialEquations.jl is a package for solving differential equations in Julia. It covers discrete equations (function maps, discrete stochastic (Gillespie/Markov) simulations), ordinary differential equations, stochastic differential equations, algebraic differential equations, delay differential equations, hybrid differential equations, jump diffusions, and (stochastic) partial differential equations. Through extensive use of multiple dispatch, metaprogramming, plot recipes, foreign function interfaces (FFI), and call-overloading, DifferentialEquations.jl offers a unified user interface to solve and analyze various forms of differential equations while not sacrificing features or performance.</description>
    </item>
    
    <item>
      <title>Distributed MCMC Inference in Dirichlet Process Mixture Models Using Julia</title>
      <link>https://julialang.org/research/dyff19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/dyff19/</guid>
      <description>Due to the increasing availability of large data sets, the need for general-purpose massively-parallel analysis tools become ever greater. In unsupervised learning, Bayesian nonparametric mixture models, exemplified by the DirichletProcess Mixture Model (DPMM), provide a principled Bayesian approach to adapt model complexity to the data. Despite their potential, however, DPMMs have yet to become a popular tool. This is partly due to the lack of friendly software tools that can handle large datasets efficiently.</description>
    </item>
    
    <item>
      <title>Distributions.jl: Definition and Modeling of Probability Distributions in the JuliaStats Ecosystem</title>
      <link>https://julialang.org/research/baablpp19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/baablpp19/</guid>
      <description>Random variables and their distributions are a central part in many areas of statistical methods. The Distributions.jl package provides Julia users and developers tools for working with probability distributions, leveraging Julia features for their intuitive and flexible manipulation, while remaining highly efficient through zero-cost abstractions.</description>
    </item>
    
    <item>
      <title>Don&#39;t Unroll Adjoint: Differentiating SSA-Form Programs</title>
      <link>https://julialang.org/research/i18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/i18/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Effective diffusivity in lattices of impermeable superballs</title>
      <link>https://julialang.org/research/r18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/r18/</guid>
      <description>We perform simulations of obstructed diffusion in periodic lattice configurations of solid, nonoverlapping, impermeable superballs to study effective diffusivity as a function of shape and solid volume fraction for simple cubic (sc), body-centered cubic (bcc), and face-centered cubic (fcc) lattices. In the simulations, point particles diffuse in the intermediate space between the solid superballs. For sc lattices, we find that for a constant solid volume fraction, the optimal effective diffusivity is obtained for a particular superball between a sphere and a cube, whereas for bcc and fcc lattices, no such optimum exists.</description>
    </item>
    
    <item>
      <title>Effective Extensible Programming: Unleashing Julia on GPUs</title>
      <link>https://julialang.org/research/bfd2017/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bfd2017/</guid>
      <description>GPUs and other accelerators are popular devices for accelerating compute-intensive, parallelizable applications. However, programming these devices is a difficult task. Writing efficient device code is challenging, and is typically done in a low-level programming language. High-level languages are rarely supported, or do not integrate with the rest of the high-level language ecosystem. To overcome this, we propose compiler infrastructure to efficiently add support for new hardware or environments to an existing programming language.</description>
    </item>
    
    <item>
      <title>Efficient Variography with Partition Variograms</title>
      <link>https://julialang.org/research/hz19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/hz19/</guid>
      <description>Directional variograms were introduced in geostatistics as a tool for revealing major directions of correlation in spatial data. However, their estimation presents some practical challenges, particularly in the case of large irregularly-sampled data sets where efficient spectral-based estimation methods are not applicable. In this work, we propose a generalization of directional variograms to general partitions of spatial data, and introduce a parallel estimation algorithm that can efficiently handle large data sets with more than 10^5 points.</description>
    </item>
    
    <item>
      <title>Experimental Multi-threading Support for the Julia Programming Language</title>
      <link>https://julialang.org/research/k14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/k14/</guid>
      <description>Julia is a young programming language that is designed for technical computing. Although Julia is dynamically typed it is very fast and usually yields C speed by utilizing a just-in-time compiler. Still, Julia has a simple syntax that is similar to Matlab, which is widely known as an easy-to-use programming environment. While Julia is very versatile and provides asynchronous programming facilities in the form of tasks (coroutines) as well as distributed multi-process parallelism, one missing feature is shared memory multi-threading.</description>
    </item>
    
    <item>
      <title>Fashionable Modelling with Flux</title>
      <link>https://julialang.org/research/isfgrjkss18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/isfgrjkss18/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Fast and Accurate Multivariate Gaussian Modeling of Protein Families: Predicting Residue Contacts and Protein-Interaction Partners</title>
      <link>https://julialang.org/research/bzfpzwp14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bzfpzwp14/</guid>
      <description>In the course of evolution, proteins show a remarkable conservation of their three-dimensional structure and their biological function, leading to strong evolutionary constraints on the sequence variability between homologous proteins. Our method aims at extracting such constraints from rapidly accumulating sequence data, and thereby at inferring protein structure and function from sequence information alone. Recently, global statistical inference methods (e.g. direct-coupling analysis, sparse inverse covariance estimation) have achieved a breakthrough towards this aim, and their predictions have been successfully implemented into tertiary and quaternary protein structure prediction methods.</description>
    </item>
    
    <item>
      <title>Fast computation of Gauss quadrature nodes and weights on the whole real line</title>
      <link>https://julialang.org/research/tto14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/tto14/</guid>
      <description>A fast and accurate algorithm for the computation of Gauss-Hermite and generalized Gauss-Hermite quadrature nodes and weights is presented. The algorithm is based on Newton&amp;rsquo;s method with carefully selected initial guesses for the nodes and a fast evaluation scheme for the associated orthogonal polynomial. In the Gauss-Hermite case the initial guesses and evaluation scheme rely on explicit asymptotic formulas. For generalized Gauss-Hermite, the initial guesses are furnished by sampling a certain equilibrium measure and the associated polynomial evaluated via a Riemann-Hilbert reformulation.</description>
    </item>
    
    <item>
      <title>Forward stable computation of roots of real polynomials with only real distinct roots</title>
      <link>https://julialang.org/research/js15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/js15/</guid>
      <description>As showed in (Fiedler, 1990), any polynomial can be expressed as a characteristic polynomial of a complex symmetric arrowhead matrix. This expression is not unique. If the polynomial is real with only real distinct roots, the matrix can be chosen real. By using accurate forward stable algorithm for computing eigenvalues of real symmetric arrowhead matrices from (Jakovcevic Stor, Slapnicar, Barlow, 2015), we derive a forward stable algorithm for computation of roots of such polynomials in O(n2) operations.</description>
    </item>
    
    <item>
      <title>Forward stable eigenvalue decomposition of rank-one modifications of diagonal matrices</title>
      <link>https://julialang.org/research/jsb15a/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/jsb15a/</guid>
      <description>We present a new algorithm for solving an eigenvalue problem for a real symmetric matrix which is a rank-one modification of a diagonal matrix. The algorithm computes each eigenvalue and all components of the corresponding eigenvector with high relative accuracy in O(n) operations. The algorithm is based on a shift-and-invert approach. Only a single element of the inverse of the shifted matrix eventually needs to be computed with double the working precision.</description>
    </item>
    
    <item>
      <title>Functional regression-based fluid permeability prediction in monodisperse sphere packings from isotropic two-point correlation functions</title>
      <link>https://julialang.org/research/rsl17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/rsl17/</guid>
      <description>We study fluid permeability in random sphere packings consisting of impermeable monodisperse hard spheres. Several different pseudo-potential models are used to obtain varying degrees of microstructural heterogeneity. Systematically varying solid volume fraction and degree of heterogeneity, virtual screening of more than 10,000 material structures is performed, simulating fluid flow using a lattice Boltzmann framework and computing the permeability. We develop a well-performing functional regression model for permeability prediction based on using isotropic two-point correlation functions as microstructural descriptors.</description>
    </item>
    
    <item>
      <title>General Projects – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/general/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/general/</guid>
      <description>General Projects – Summer of Code Improving test coverage Code coverage reports very good coverage of all of the Julia Stdlib packages, but it&amp;rsquo;s not complete. Additionally, the coverage tools themselves (&amp;ndash;track-coverage and https://github.com/JuliaCI/Coverage.jl) could be further enhanced, such as to give better accuracy of statement coverage, or more precision. A successful project may combine a bit of both building code and finding faults in others&amp;rsquo; code.
Another related side-project might be to explore adding Type information to the coverage reports.</description>
    </item>
    
    <item>
      <title>Generalized Low Rank Models</title>
      <link>https://julialang.org/research/uhzb14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/uhzb14/</guid>
      <description>Principal components analysis (PCA) is a well-known technique for approximating a data set represented by a matrix by a low rank matrix. Here, we extend the idea of PCA to handle arbitrary data sets consisting of numerical, Boolean, categorical, ordinal, and other data types. This framework encompasses many well known techniques in data analysis, such as nonnegative matrix factorization, matrix completion, sparse and robust PCA, k-means, k-SVD, and maximum margin matrix factorization.</description>
    </item>
    
    <item>
      <title>GeoStats.jl -- High-performance geostatistics in Julia</title>
      <link>https://julialang.org/research/h18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/h18/</guid>
      <description>GeoStats.jl is an extensible framework for high-performance geostatistics in Julia, as well as a formal specification of statistical problems in the spatial setting. It provides highly optimized solvers for estimation and (conditional) simulation of variables defined over general spatial domains (e.g. regular grid, point collection), and can utilize high-performance hardware for parallel execution such as GPUs and computer clusters.</description>
    </item>
    
    <item>
      <title>Getting Started with Julia</title>
      <link>https://julialang.org/learning/getting-started/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/learning/getting-started/</guid>
      <description>Getting Started with Julia What is Julia? Welcome to the Julia language project! We’re excited that you’re interested in learning Julia and contributing to our project and community. Julia is a new programming language. It is also a general purpose language, which means that you can find a way to build basically any software in it that you could with another language. However, no programming language is the best tool for every problem.</description>
    </item>
    
    <item>
      <title>Graphic Projects – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/graphics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/graphics/</guid>
      <description>Graphic Projects – Summer of Code Makie Improve Documentation + add Examples Makie is a new plotting library in need of tests and documentation.
One needs to go through all sections of the current documentation, make sure they are understandable and add examples to the documentation where necessary. Depending on how much time is left, there are endless opportunities to create impressive and creative plotting examples for the example database.</description>
    </item>
    
    <item>
      <title>High-level GPU programming in Julia</title>
      <link>https://julialang.org/research/bvd2016/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bvd2016/</guid>
      <description>GPUs are popular devices for accelerating scientific calculations. However, as GPU code is usually written in low-level languages, it breaks the abstractions of high-level languages popular with scientific programmers. To overcome this, we present a framework for CUDA GPU programming in the high-level Julia programming language. This framework compiles Julia source code for GPU execution, and takes care of the necessary low-level interactions using modern code generation techniques to avoid run-time overhead.</description>
    </item>
    
    <item>
      <title>HomotopyContinuation.jl: A package for Homotopy Continuation in Julia</title>
      <link>https://julialang.org/research/bt18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bt18/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Hopf bifurcation in a nonlocal nonlinear transport equation stemming from stochastic neural dynamics</title>
      <link>https://julialang.org/research/dv17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/dv17/</guid>
      <description>In this work, we provide three different numerical evidences for the occurrence of a Hopf bifurcation in a recently derived [De Masi et al., J. Stat. Phys. 158, 866–902 (2015) and Fournier and Löcherbach, Ann. Inst. H. Poincaré Probab. Stat. 52, 1844–1876 (2016)] mean field limit of a stochastic network of excitatory spiking neurons. The mean field limit is a challenging nonlocal nonlinear transport equation with boundary conditions. The first evidence relies on the computation of the spectrum of the linearized equation.</description>
    </item>
    
    <item>
      <title>HPC Projects – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/hpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/hpc/</guid>
      <description>HPC Projects – Summer of Code Julia is emerging as a serious tool for technical computing and is ideally suited for the ever-growing needs of big data analytics. This set of proposed projects addresses specific areas for improvement in analytics algorithms and distributed data management.
Simple persistent distributed storage This project proposes to implement a very simple persistent storage mechanism for Julia variables so that data can be saved to and loaded from disk with a consistent interface that is agnostic of the underlying storage layer.</description>
    </item>
    
    <item>
      <title>Introduction to the equilibrium Green&#39;s functions: condensed matter examples with numerical implementations</title>
      <link>https://julialang.org/research/opv16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/opv16/</guid>
      <description>The Green&amp;rsquo;s function method has applications in several fields in Physics, from classical differential equations to quantum many-body problems. In the quantum context, Green&amp;rsquo;s functions are correlation functions, from which it is possible to extract information from the system under study, such as the density of states, relaxation times and response functions. Despite its power and versatility, it is known as a laborious and sometimes cumbersome method. Here we introduce the equilibrium Green&amp;rsquo;s functions and the equation-of-motion technique, exemplifying the method in discrete lattices of non-interacting electrons.</description>
    </item>
    
    <item>
      <title>Is High Temporal Resolution Achievable for Paediatric Cardiac Acquisitions during Several Heart Beats? Illustration with Cardiac Phase Contrast Cine-MRI</title>
      <link>https://julialang.org/research/bomhfv15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bomhfv15/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Julia and the numerical homogenization of PDEs</title>
      <link>https://julialang.org/research/ht14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/ht14/</guid>
      <description>We discuss the advantages of using Julia for solving multiscale problems involving partial differential equations (PDEs). Multiscale problems are problems where the coefficients of a PDE oscillate rapidly on a microscopic length scale, but solutions are sought on a much larger, macroscopic domain. Solving multiscale problems requires both a theoretic result, i.e., a homogenization result yielding effective coefficients, as well as numerical solutions of the PDE at the microscopic and the macroscopic length scales.</description>
    </item>
    
    <item>
      <title>Julia Downloads (nightly binaries)</title>
      <link>https://julialang.org/downloads/nightlies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/downloads/nightlies/</guid>
      <description>Nightly builds  These are bleeding-edge binaries of the latest version of Julia under development, which you can use to get a preview of the latest work. The nightly builds are for developer previews and not intended for normal use. You can expect many packages not to work with this version. Most users are advised to use the latest official release version of Julia.    Windows Self-Extracting Archive (.</description>
    </item>
    
    <item>
      <title>Julia Downloads (Old releases)</title>
      <link>https://julialang.org/downloads/oldreleases/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/downloads/oldreleases/</guid>
      <description>Older Unmaintained Releases  Old releases are available should you need to use them to run Julia code written for those releases. Note that these are not actively developed nor maintained anymore. v1.2.0 (Aug 20, 2019)    Windows (.exe) [help] 32-bit  64-bit     macOS 10.8+ (.dmg) [help]  64-bit     Generic Linux Binaries for x86 [help] 32-bit (GPG)  64-bit (GPG)     Generic Linux Binaries for ARM [help] 32-bit (ARMv7-a hard float) (GPG)  64-bit (AArch64) (GPG)     Generic FreeBSD Binaries for x86 [help]  64-bit (GPG)     Source  Tarball (GPG)  Tarball with dependencies (GPG)  GitHub     v1.</description>
    </item>
    
    <item>
      <title>Julia subtyping: a Rational Reconstruction</title>
      <link>https://julialang.org/research/zbpcbv2018/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/zbpcbv2018/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Julia&#39;s Summer of Code projects</title>
      <link>https://julialang.org/jsoc/archive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/archive/</guid>
      <description>Summer of Code Archives Julia has greatly benefited from the Google Summer of Code. In the last 6 years, over 70+ students have contributed to Julia and various Julia packages. Many of these students have become regular Julia contributors well beyond their summer projects. Take a look at the Ideas Page and contribute your ideas.
GSoC 2019 In 2019, we recieved an even larger number of very high quality applications but could only fufill 15 slots through GSoC.</description>
    </item>
    
    <item>
      <title>Julia: A Fast Dynamic Language for Technical Computing</title>
      <link>https://julialang.org/research/bkse12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bkse12/</guid>
      <description>Dynamic languages have become popular for scientific computing. They are generally considered highly productive, but lacking in performance. This paper presents Julia, a new dynamic language for technical computing, designed for performance from the beginning by adapting and extending modern programming language techniques. A design based on generic functions and a rich type system simultaneously enables an expressive programming model and successful type inference, leading to good performance for a wide range of programs.</description>
    </item>
    
    <item>
      <title>Julia: A Fresh Approach to Numerical Computing</title>
      <link>https://julialang.org/research/beks17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/beks17/</guid>
      <description>Bridging cultures that have often been distant, Julia combines expertise from the diverse fields of computer science and computational science to create a new approach to numerical computing. Julia is designed to be easy and fast and questions notions generally held to be “laws of nature&amp;rdquo; by practitioners of numerical computing: (1) High-level dynamic programs have to be slow; (2) One must prototype in one language and then rewrite in another language for speed or deployment; (3) There are parts of a system appropriate for the programmer, and other parts that are best left untouched as they have been built by the experts.</description>
    </item>
    
    <item>
      <title>Julia: Dynamism and Performance Reconciled by Design</title>
      <link>https://julialang.org/research/bccksvz2018/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bccksvz2018/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JuliaFEM - open source solver for both industrial and academia usage</title>
      <link>https://julialang.org/research/tf2017/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/tf2017/</guid>
      <description>The JuliaFEM software library is a framework that allows for the distributed processing of large Finite Element Models across clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines, each offering local computation and storage. The basic design principle is: Everything is non-linear. All physics models are non-linear from which the linearizations are made as special cases. This is work in progress.</description>
    </item>
    
    <item>
      <title>JuliaGraphs – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/graphs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/graphs/</guid>
      <description>JuliaGraphs – Summer of Code Thank you for your interest in supporting JuliaGraphs in the upcoming Summer of Code!
The JuliaGraphs ecosystem offers a set of abstractions and algorithms for various aspects of graph modeling and analysis. LightGraphs.jl is the central package defining the types and essential algorithms.
{% include toc.html %}
Mentorship Inquiries: Drop by #graphs on Slack or file a new issue on Github.
Prerequisites Prospective candidates should be familiar with most of the following concepts: - graph algorithms - Julia programming and idiomatic code - LightGraphs.</description>
    </item>
    
    <item>
      <title>JuliaImages Projects – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/images/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/images/</guid>
      <description>JuliaImages Projects – Summer of Code JuliaImages (see the documentation) is a framework in Julia for multidimensional arrays, image processing, and computer vision (CV). It has an active development community and offers many features that unify CV and biomedical 3D/4D image processing, support big data, and promote interactive exploration.
Often the best ideas are the ones that candidate SoC students come up with on their own. We are happy to discuss such ideas and help you refine your proposal.</description>
    </item>
    
    <item>
      <title>JuliaReach: a Toolbox for Set-Based Reachability</title>
      <link>https://julialang.org/research/bffps19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bffps19/</guid>
      <description>We present JuliaReach, a toolbox for set-based reachability analysis of dynamical systems. JuliaReach consists of two main packages: Reachability, containing implementations of reachability algorithms for continuous and hybrid systems, and LazySets, a standalone library that implements state-of-the-art algorithms for calculus with convex sets. The library offers both concrete and lazy set representations, where the latter stands for the ability to delay set computations until they are needed. The choice of the programming language Julia and the accompanying documentation of our toolbox allow researchers to easily translate set-based algorithms from mathematics to software in a platform-independent way, while achieving runtime performance that is comparable to statically compiled languages.</description>
    </item>
    
    <item>
      <title>JuMP: A Modeling Language for Mathematical Optimization</title>
      <link>https://julialang.org/research/dhl2017/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/dhl2017/</guid>
      <description>JuMP is an open-source modeling language that allows users to express a wide range of optimization problems (linear, mixed-integer, quadratic, conic-quadratic, semidefinite, and nonlinear) in a high-level, algebraic syntax. JuMP takes advantage of advanced features of the Julia programming language to offer unique functionality while achieving performance on par with commercial modeling tools for standard tasks. In this work we will provide benchmarks, present the novel aspects of the implementation, and discuss how JuMP can be extended to new problem classes and composed with state-of-the-art tools for visualization and interactivity.</description>
    </item>
    
    <item>
      <title>Kpax3: Bayesian bi-clustering of large sequence datasets</title>
      <link>https://julialang.org/research/pc18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/pc18/</guid>
      <description>Motivation: Estimation of the hidden population structure is an important step in many genetic studies. Often the aim is also to identify which sequence locations are the most discriminative between groups of samples for a given data partition. Automated discovery of interesting patterns that are present in the data can help to generate new biological hypotheses. Results: We introduce Kpax3, a Bayesian method for bi-clustering multiple sequence alignments. Influence of individual sites will be determined in a supervised manner by using informative prior distributions for the model parameters.</description>
    </item>
    
    <item>
      <title>Live Network Simulation in Julia: Design and Implementation of LiveSim.jl</title>
      <link>https://julialang.org/research/pk18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/pk18/</guid>
      <description>An architecture for interactive, notebook-based ns-3 simulations in the cloud is proposed. A prototype implementation of an example study for IEEE 802.11p inter-channel interference is developed as a test-case, using direct integration of ns-3 components with Jupyter via Julia&amp;rsquo;s C++ support. This shows that flexible animations with advanced visualization of live ns-3 simulation results can be setup quickly. Although the system appears complex, the benefits of ns-3 as fast and flexible discrete event simulator complement Julia&amp;rsquo;s scalability in numerical computing and Jupyter&amp;rsquo;s versatility on the Web and provide supporting evidence of LiveSim as a promising direction for multi-modal, reproducible network research.</description>
    </item>
    
    <item>
      <title>Massively parallel approximate Bayesian computation for estimating nanoparticle diffusion coefficients, sizes and concentrations using confocal laser scanning microscopy</title>
      <link>https://julialang.org/research/rb18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/rb18/</guid>
      <description>We implement a massively parallel population Monte Carlo approximate Bayesian computation (PMC‐ABC) method for estimating diffusion coefficients, sizes and concentrations of diffusing nanoparticles in liquid suspension using confocal laser scanning microscopy and particle tracking. The method is based on the joint probability distribution of diffusion coefficients and the time spent by a particle inside a detection region where particles are tracked. We present freely available central processing unit (CPU) and graphics processing unit (GPU) versions of the analysis software, and we apply the method to characterize mono‐ and bidisperse samples of fluorescent polystyrene beads.</description>
    </item>
    
    <item>
      <title>Matrix Depot: An Extensible Test Matrix Collection for Julia</title>
      <link>https://julialang.org/research/zh15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/zh15/</guid>
      <description>Matrix Depot is a Julia software package that provides easy access to a large and diverse collection of test matrices. Its novelty is threefold. First, it is extensible by the user, and so can be adapted to include the user’s own test problems. In doing so it facilitates experimentation and makes it easier to carry out reproducible research. Second, it amalgamates in a single framework three different types of matrix collections, comprising parametrized test matrices, regularization test problems, and real-life sparse matrix data.</description>
    </item>
    
    <item>
      <title>Mean-Independent Noise Control of Cell Fates via Intermediate States</title>
      <link>https://julialang.org/research/rn18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/rn18/</guid>
      <description>Stochasticity affects accurate signal detection and robust generation of correct cell fates. Although many known regulatory mechanisms may reduce fluctuations in signals, most simultaneously influence their mean dynamics, leading to unfaithful cell fates. Through analysis and computation, we demonstrate that a reversible signaling mechanism acting through intermediate states can reduce noise while maintaining the mean. This mean-independent noise control (MINC) mechanism is investigated in the context of an intracellular binding protein that regulates retinoic acid (RA) signaling during zebrafish hindbrain development.</description>
    </item>
    
    <item>
      <title>Microenvironmental cooperation promotes early spread and bistability of a Warburg-like phenotype</title>
      <link>https://julialang.org/research/jfc17a/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/jfc17a/</guid>
      <description>We introduce an in silico model for the initial spread of an aberrant phenotype with Warburg-like overflow metabolism within a healthy homeostatic tissue in contact with a nutrient reservoir (the blood), aimed at characterizing the role of the microenvironment for aberrant growth. Accounting for cellular metabolic activity, competition for nutrients, spatial diffusion and their feedbacks on aberrant replication and death rates, we obtain a phase portrait where distinct asymptotic whole-tissue states are found upon varying the tissue-blood turnover rate and the level of blood-borne primary nutrient.</description>
    </item>
    
    <item>
      <title>MIToS.jl: mutual information tools for protein sequence analysis in the Julia language</title>
      <link>https://julialang.org/research/zanm17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/zanm17/</guid>
      <description>Motivation: MIToS is an environment for mutual information analysis and a framework for protein multiple sequence alignments (MSAs) and protein structures (PDB) management in Julia language. It integrates sequence and structural information through SIFTS, making Pfam MSAs analysis straightforward. MIToS streamlines the implementation of any measure calculated from residue contingency tables and its optimization and testing in terms of protein contact prediction. As an example, we implemented and tested a BLOSUM62-based pseudo-count strategy in mutual information analysis.</description>
    </item>
    
    <item>
      <title>Modeling of RAFT Polymerization Processes Using an Efficient Monte Carlo Algorithm in Julia</title>
      <link>https://julialang.org/research/ep16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/ep16/</guid>
      <description>A kinetic Monte Carlo model of a reversible addition–fragmentation chain transfer (RAFT) process is presented. The algorithm has been developed and implemented in Julia for the three main RAFT theories under current discussion (slow fragmentation, intermediate radical termination, and intermediate radical termination with oligomers). Julia is a modern programming language designed to achieve high performance in numerical and scientific computing. Thanks to a careful optimization of the code, it is possible to simulate a RAFT reaction scheme in short computing times for any of the three theories.</description>
    </item>
    
    <item>
      <title>Molecular structure, configurational entropy and viscosity of silicate melts: Link through the Adam and Gibbs theory of viscous flow</title>
      <link>https://julialang.org/research/clldnr17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/clldnr17/</guid>
      <description>The Adam and Gibbs theory depicts the viscous flow of silicate melts as governed by the cooperative re-arrangement of molecular sub-systems. Considering that such subsystems involve the silicate Qn units (n = number of bridging oxygens), this study presents a model that links the Qn unit fractions to the melt configurational entropy at the glass transition temperature Tg, Sconf(Tg), and finally, to its viscosity η. With 13 adjustable parameters, the model reproduces η and Tg of melts in the Na2O-K2O-SiO2 system (60 ≤ [SiO2] ≤ 100 mol%) with 1σ standard deviations of 0.</description>
    </item>
    
    <item>
      <title>Monte Carlo Methods and Zero Variance Principle</title>
      <link>https://julialang.org/research/pmg15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/pmg15/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Morphodynamic Analysis and Statistical Synthesis of Geomorphic Data. Application to a Flume Experiment</title>
      <link>https://julialang.org/research/hbc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/hbc/</guid>
      <description>Many Earth‐surface processes are studied using field, experimental, or numerical modeling datasets that represent a small subset of possible outcomes observed in nature. Based on these data, deterministic models can be built that describe the average evolution of a system. However, these models commonly cannot account for the complex variability of many processes or present a quantitative statement of uncertainty. To assess such uncertainty, stochastic models are needed that can mimic spatial as well as temporal variability.</description>
    </item>
    
    <item>
      <title>Natural Frequency Calculations with JuliaFEM</title>
      <link>https://julialang.org/research/mr2017/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/mr2017/</guid>
      <description>This article presents a simple natural frequency analysis performed with JuliaFEM - an open-source finite element method program. The results are compared with the analysis results pruduced with a commercial software. The comparison shows that the calculation results between the two programs do not differ significantly.</description>
    </item>
    
    <item>
      <title>Nemo/Hecke: Computer Algebra and Number Theory Packages for the Julia Programming Language</title>
      <link>https://julialang.org/research/fhhj17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/fhhj17/</guid>
      <description>We introduce two new packages, Nemo and Hecke, written in the Julia programming language for computer algebra and number theory. We demonstrate that high performance generic algorithms can be implemented in Julia, without the need to resort to a low-level C implementation. For specialised algorithms, we use Julia&amp;rsquo;s efficient native C interface to wrap existing C/C++ libraries such as Flint, Arb, Antic and Singular. We give examples of how to use Hecke and Nemo and discuss some algorithms that we have implemented to provide high performance basic arithmetic.</description>
    </item>
    
    <item>
      <title>Novel algebras for advanced analytics in Julia</title>
      <link>https://julialang.org/research/sekbk13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/sekbk13/</guid>
      <description>A linear algebraic approach to graph algorithms that exploits the sparse adjacency matrix representation of graphs can provide a variety of benefits. These benefits include syntactic simplicity, easier implementation, and higher performance. One way to employ linear algebra techniques for graph algorithms is to use a broader definition of matrix and vector multiplication. We demonstrate through the use of the Julia language system how easy it is to explore semirings using linear algebraic methodologies.</description>
    </item>
    
    <item>
      <title>Numerical Projects – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/numerics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/numerics/</guid>
      <description>Numerical Projects – Summer of Code For all of these projects, potential mentors are Steven Johnson.
Numerical Linear Algebra PETSc integration for scalable technical computing PETSc is a widely used framework of data structures and computational routines suitable for massively scaling scientific computations. Many of these algorithms are also ideally suited for big data applications such as computing principal components of very large sparse matrices and solving complicated forecasting models with distributed methods for solving partial differential equations.</description>
    </item>
    
    <item>
      <title>On the use of conformal maps for the acceleration of convergence of the trapezoidal rule and Sinc numerical methods</title>
      <link>https://julialang.org/research/so14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/so14/</guid>
      <description>We investigate the use of conformal maps for the acceleration of convergence of the trapezoidal rule and Sinc numerical methods. The conformal map is a polynomial adjustment to the sinh map, and allows the treatment of a finite number of singularities in the complex plane. In the case where locations are unknown, the so-called Sinc-Padé approximants are used to provide approximate results. This adaptive method is shown to have almost the same convergence properties.</description>
    </item>
    
    <item>
      <title>Online Learning of Nonparametric Mixture Models via Sequential Variational Approximation</title>
      <link>https://julialang.org/research/l13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/l13/</guid>
      <description>Reliance on computationally expensive algorithms for inference has been limiting the use of Bayesian nonparametric models in large scale applications. To tackle this problem, we propose a Bayesian learning algorithm for DP mixture models. Instead of following the conventional paradigm &amp;ndash; random initialization plus iterative update, we take an progressive approach. Starting with a given prior, our method recursively transforms it into an approximate posterior through sequential variational approximation. In this process, new components will be incorporated on the fly when needed.</description>
    </item>
    
    <item>
      <title>Optim: A mathematical optimization package for Julia</title>
      <link>https://julialang.org/research/pkmanr18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/pkmanr18/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Parallel algebraic modeling for stochastic optimization</title>
      <link>https://julialang.org/research/hlp14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/hlp14/</guid>
      <description>We present scalable algebraic modeling software, StochJuMP, for stochastic optimization as applied to power grid economic dispatch. It enables the user to express the problem in a high-level algebraic format with minimal boilerplate. StochJuMP allows efficient parallel model instantiation across nodes and efficient data localization. Computational results are presented showing that the model construction is efficient, requiring less than one percent of solve time. StochJuMP is configured with the parallel interior-point solver PIPS-IPM but is sufficiently generic to allow straight forward adaptation to other solvers.</description>
    </item>
    
    <item>
      <title>Parallel Evaluation of a DSP Algorithm Using Julia</title>
      <link>https://julialang.org/research/pk16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/pk16/</guid>
      <description>Rapid pace of innovation in industrial research labs requires fast algorithm evaluation cycles. The use of multi-core hardware and distributed clusters is essential to achieve reasonable turnaround times for high-load simulations. Julia’s support for these as well as its pervasive multiple dispatch make it very attractive for high-performance technical computing.
Our experiments in speeding up a Digital Signal Processing (DSP) Intellectual Property (IP) model simulation for a Wireless LAN (WLAN) product confirm this.</description>
    </item>
    
    <item>
      <title>Parallel Prefix Polymorphism Permits Parallelization, Presentation &amp; Proof</title>
      <link>https://julialang.org/research/ce14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/ce14/</guid>
      <description>Polymorphism in programming languages enables code reuse. Here, we show that polymorphism has broad applicability far beyond computations for technical computing: parallelism in distributed computing, presentation of visualizations of runtime data flow, and proofs for formal verification of correctness. The ability to reuse a single codebase for all these purposes provides new ways to understand and verify parallel programs.</description>
    </item>
    
    <item>
      <title>Parallelizing Julia with a Non-Invasive DSL</title>
      <link>https://julialang.org/research/alktvs17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/alktvs17/</guid>
      <description>Computational scientists often prototype software using productivity languages that offer high-level programming abstractions. When higher performance is needed, they are obliged to rewrite their code in a lower-level efficiency language. Different solutions have been proposed to address this trade-off between productivity and efficiency. One promising approach is to create embedded domain-specific languages that sacrifice generality for productivity and performance, but practical experience with DSLs points to some road blocks preventing widespread adoption.</description>
    </item>
    
    <item>
      <title>Parallelle abstracties voor het programmeren van GPU&#39;s in Julia (Parallel abstractions for programming GPUs in Julia)</title>
      <link>https://julialang.org/research/v14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/v14/</guid>
      <description>This master&amp;rsquo;s thesis explores the possibility to provide access to the computing power of a GPU from the high-level programming language Julia. An important requirement here is to keep the programmer&amp;rsquo;s productivity at the same high level as if he would use Julia without a GPU. Indeed, very specialized and detailed technical knowledge is needed in order to program a GPU, making it complex and time-consuming. In many modern scientific domains quite a lot of brute computing power is required, but often these domains lack the technical expertise to use GPUs in an efficient manner.</description>
    </item>
    
    <item>
      <title>Platform specific instructions</title>
      <link>https://julialang.org/downloads/platform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/downloads/platform/</guid>
      <description>Platform Specific Instructions for Official Binaries All official Julia binaries produce portable installations. Once installed, the directory in which Julia was installed can be moved to a different location on the same computer, or even to a different computer.
Windows Julia is available for Windows 7 and later, both 32 bit and 64 bit.
 Download the Windows julia.exe installer for your platform. 32-bit julia works on both x86 and x86_64.</description>
    </item>
    
    <item>
      <title>POMDPs.jl: A Framework for Sequential Decision Making under Uncertainty</title>
      <link>https://julialang.org/research/esbwgk17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/esbwgk17/</guid>
      <description>POMDPs.jl is an open-source framework for solving Markov decision processes (MDPs) and partially observable MDPs (POMDPs). POMDPs.jl allows users to specify sequential decision making problems with minimal effort without sacrificing the expressive nature of POMDPs, making this framework viable for both educational and research purposes. It is written in the Julia language to allow flexible prototyping and large-scale computation that leverages the high-performance nature of the language. The associated JuliaPOMDP community also provides a number of state-of-the-art MDP and POMDP solvers and a rich library of support tools to help with implementing new solvers and evaluating the solution results.</description>
    </item>
    
    <item>
      <title>Practically surreal: Surreal arithmetic in Julia</title>
      <link>https://julialang.org/research/r19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/r19/</guid>
      <description>This paper presents an implementation of arithmetic on Conway’s surreal numbers. It also provides tools for visualising complicated surreals in the form of graph visualisations, and illustrates their use through several examples, and a small contribution to the theory of surreals.</description>
    </item>
    
    <item>
      <title>Predicting Protein Dynamics and Allostery Using Multi-Protein Atomic Distance Constraints</title>
      <link>https://julialang.org/research/gfs17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/gfs17/</guid>
      <description>The related concepts of protein dynamics, conformational ensembles and allostery are often difficult to study with molecular dynamics (MD) due to the timescales involved. We present ExProSE (Exploration of Protein Structural Ensembles), a distance geometry-based method that generates an ensemble of protein structures from two input structures. ExProSE provides a unified framework for the exploration of protein structure and dynamics in a fast and accessible way. Using a dataset of apo/holo pairs it is shown that existing coarse-grained methods often cannot span large conformational changes.</description>
    </item>
    
    <item>
      <title>Reach Set Approximation through Decomposition with Low-dimensional Sets and High-dimensional Matrices</title>
      <link>https://julialang.org/research/bffvps18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bffvps18/</guid>
      <description>Approximating the set of reachable states of a dynamical system is an algorithmic yet mathematically rigorous way to reason about its safety. Although progress has been made in the development of efficient algorithms for affine dynamical systems, available algorithms still lack scalability to ensure their wide adoption in the industrial setting. While modern linear algebra packages are efficient for matrices with tens of thousands of dimensions, set-based image computations are limited to a few hundred.</description>
    </item>
    
    <item>
      <title>Reachability analysis of linear hybrid systems via block decomposition</title>
      <link>https://julialang.org/research/bffps19b/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bffps19b/</guid>
      <description>Reachability analysis aims at identifying states reachable by a system within a given time horizon. This task is known to be computationally hard for hybrid systems. One of the main challenges is the handling of discrete transitions, including computation of intersections with invariants and guards. In this paper, we address this problem by proposing a state-space decomposition approach for linear hybrid systems. This approach allows us to perform most operations in low-dimensional state space, which can lead to significant performance improvements.</description>
    </item>
    
    <item>
      <title>Recompression of Hadamard Products of Tensors in Tucker Format</title>
      <link>https://julialang.org/research/dklp17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/dklp17/</guid>
      <description>The Hadamard product features prominently in tensor-based algorithms in scientific computing and data analysis. Due to its tendency to significantly increase ranks, the Hadamard product can represent a major computational obstacle in algorithms based on low-rank tensor representations. It is therefore of interest to develop recompression techniques that mitigate the effects of this rank increase. In this work, we investigate such techniques for the case of the Tucker format, which is well suited for tensors of low order and small to moderate multilinear ranks.</description>
    </item>
    
    <item>
      <title>RHEOS.jl -- A Julia Package for Rheology Data Analysis</title>
      <link>https://julialang.org/research/kbk19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/kbk19/</guid>
      <description></description>
    </item>
    
    <item>
      <title>RNA editing generates cellular subsets with diverse sequence within populations</title>
      <link>https://julialang.org/research/hpoepp16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/hpoepp16/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Sampling unitary invariant ensembles</title>
      <link>https://julialang.org/research/ont14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/ont14/</guid>
      <description>We develop an algorithm for sampling from the unitary invariant random matrix ensembles. The algorithm is based on the representation of their eigenvalues as a determinantal point process whose kernel is given in terms of orthogonal polynomials. Using this algorithm, statistics beyond those known through analysis are calculable through Monte Carlo simulation. Unexpected phenomena are observed in the simulations.</description>
    </item>
    
    <item>
      <title>Scientific Projects – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/science/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/science/</guid>
      <description>Scientific Projects – Summer of Code Quantum Computation: Simualation of Noisy Circuits Noisy Intermediate-Scale Quantum (NISQ) technology will be available in the near future. However, it would be much more convenient if we could test our algorithm with noise and simulate our quantum algorithm on noisy circuits to explore their stability, efficiency. To assist the research of NISQ, enhance the quantum circuit simulator in Julia Yao.jl with noisy circuit simulation would be quite useful.</description>
    </item>
    
    <item>
      <title>Second-Order Switching Time Optimization for Switched Dynamical Systems</title>
      <link>https://julialang.org/research/sog16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/sog16/</guid>
      <description>Switching time optimization arises in finite-horizon optimal control for switched systems where, given a sequence of continuous dynamics, one minimizes a cost function with respect to the switching times. We propose an efficient method for computing the optimal switching times for switched linear and nonlinear systems. A novel second-order optimization algorithm is introduced where, at each iteration, the dynamics are linearized over an underlying time grid to compute the cost function, the gradient and the Hessian efficiently.</description>
    </item>
    
    <item>
      <title>Self-induced temperature gradients in Brownian dynamics</title>
      <link>https://julialang.org/research/jdmj2017/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/jdmj2017/</guid>
      <description>Brownian systems often surmount energy barriers by absorbing and emitting heat to and from their local environment. Usually, the temperature gradients created by this heat exchange are assumed to dissipate instantaneously. Here we relax this assumption to consider the case where Brownian dynamics on a time- independent potential can lead to self-induced temperature gradients. In the same way that externally imposed temperature gradients can cause directed motion, these self-induced gradients affect the dynamics of the Brownian system.</description>
    </item>
    
    <item>
      <title>Seven More Languages in Seven Weeks: Languages That Are Shaping the Future</title>
      <link>https://julialang.org/research/tddm14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/tddm14/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Shape-dependent effective diffusivity in packings of hard cubes and cuboids compared with spheres and ellipsoids</title>
      <link>https://julialang.org/research/r17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/r17/</guid>
      <description>We performed computational screening of effective diffusivity in different configurations of cubes and cuboids compared with spheres and ellipsoids. In total, more than 1500 structures are generated and screened for effective diffusivity. We studied simple cubic and face-centered cubic lattices of spheres and cubes, random configurations of cubes and spheres as a function of volume fraction and polydispersity, and finally random configurations of ellipsoids and cuboids as a function of shape.</description>
    </item>
    
    <item>
      <title>Simultaneous identification of specifically interacting paralogs and interprotein contacts by direct coupling analysis</title>
      <link>https://julialang.org/research/gbzwp16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/gbzwp16/</guid>
      <description>Understanding protein−protein interactions is central to our understanding of almost all complex biological processes. Computational tools exploiting rapidly growing genomic databases to characterize protein−protein interactions are urgently needed. Such methods should connect multiple scales from evolutionary conserved interactions between families of homologous proteins, over the identification of specifically interacting proteins in the case of multiple paralogs inside a species, down to the prediction of residues being in physical contact across interaction interfaces.</description>
    </item>
    
    <item>
      <title>Statistical Deviations from the Theoretical only-SBU Model to Estimate MCU rates in SRAMs</title>
      <link>https://julialang.org/research/fjf17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/fjf17/</guid>
      <description>This paper addresses a well-known problem that occurs when memories are exposed to radiation: the determination if a bit flip is isolated or if it belongs to a multiple event. As it is unusual to know the physical layout of the memory, this paper proposes to evaluate the statistical properties of the sets of corrupted addresses and to compare the results with a mathematical prediction model where all of the events are single bit upsets.</description>
    </item>
    
    <item>
      <title>Stochastic Collapsed Variational Bayesian Inference for Latent Dirichlet Allocation</title>
      <link>https://julialang.org/research/fbdsw13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/fbdsw13/</guid>
      <description>There has been an explosion in the amount of digital text information available in recent years, leading to challenges of scale for traditional inference algorithms for topic models. Recent advances in stochastic variational inference algorithms for latent Dirichlet allocation (LDA) have made it feasible to learn topic models on very large-scale corpora, but these methods do not currently take full advantage of the collapsed representation of the model. We propose a stochastic algorithm for collapsed variational Bayesian inference for LDA, which is simpler and more efficient than the state of the art method.</description>
    </item>
    
    <item>
      <title>Stochastic differential equations and continuous time signal processing – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/kalmanbucy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/kalmanbucy/</guid>
      <description>Stochastic differential equations and continuous time signal processing – Summer of Code Filtering and smoothing large non-linear continuous time systems The student implements a state of the art smoother for large continuous-time systems. The system&amp;rsquo;s dynamics can be described as an ordinary differential equation with locally additive Gaussian random fluctuations. Thus the system is modeled as a high-dimensional stochastic ordinary differential equation.
Given a series of measurements observed over time, containing statistical noise and other inaccuracies, a filter produces an estimate of the unknown state of the system that led to the current observation taking previous observations into account.</description>
    </item>
    
    <item>
      <title>Stochastic Simulation by Image Quilting of Process-based Geological Models</title>
      <link>https://julialang.org/research/hsbc17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/hsbc17/</guid>
      <description>Process-based modeling offers a way to represent realistic geological heterogeneity in subsurface models. The main limitation lies in conditioning such models to data. Multiple-point geostatistics can use these process-based models as training images and address the data conditioning problem. In this work, we further develop image quilting as a method for 3D stochastic simulation capable of mimicking the realism of process-based geological models with minimal modeling effort (i.e. parameter tuning) and at the same time condition them to a variety of data.</description>
    </item>
    
    <item>
      <title>Symbolic Manipulation of Flows of Nonlinear Evolution Equations, with Application in the Analysis of Split-Step Time Integrators</title>
      <link>https://julialang.org/research/ahk16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/ahk16/</guid>
      <description>We describe a package realized in the Julia programming language which performs symbolic manipulations applied to nonlinear evolution equations, their flows, and commutators of such objects. This tool was employed to perform contrived computations arising in the analysis of the local error of operator splitting methods. It enabled the proof of the convergence of the basic method and of the asymptotical correctness of a defect-based error estimator. The performance of our package is illustrated on several examples.</description>
    </item>
    
    <item>
      <title>Tabular Data – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/tables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/tables/</guid>
      <description>Tabular Data – Summer of Code Parquet.jl enhancements and JuliaDB Apache Parquet is a binary data format for tabular data. It has features for compression and memory-mapping of datasets on disk. A decent implementation of Parquet in Julia is likely to be highly performant. It will be useful as a standard format for distributing tabular data in a binary format. JuliaDB (submodule MemPool) currently requires a binary format for efficient storage and data transfer, but right now resorts to a custom but fast implementation.</description>
    </item>
    
    <item>
      <title>TaylorSeries.jl: Taylor expansions in one and several variables in Julia</title>
      <link>https://julialang.org/research/bs19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bs19/</guid>
      <description></description>
    </item>
    
    <item>
      <title>The automatic solution of partial differential equations using a global spectral method</title>
      <link>https://julialang.org/research/to14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/to14/</guid>
      <description>A spectral method for solving linear partial differential equations (PDEs) with variable coefficients and general boundary conditions defined on rectangular domains is described, based on separable representations of partial differential operators and the one-dimensional ultraspherical spectral method. If a partial differential operator is of splitting rank 2, such as the operator associated with Poisson or Helmholtz, the corresponding PDE is solved via a generalized Sylvester matrix equation, and a bivariate polynomial approximation of the solution of degree (n_x,n_y) is computed in O(n_x n_y)^{3&amp;frasl;2} operations.</description>
    </item>
    
    <item>
      <title>Thermodynamic Property and Fluid Modeling with Modern Programming Language Constructs</title>
      <link>https://julialang.org/research/oezl19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/oezl19/</guid>
      <description>Modelica is used extensively to model thermo-fluid pipe networks. Experience shows that Modelica models in this domain have limitations due to missing functional expressiveness of the Modelica language. In this paper, a prototype is described that demonstrates how thermodynamic property and thermo-fluid pipe component modeling could be considerably enhanced via modern language constructs available in Julia. This prototype is based on the Modia modelling and simulation prototype and relies on features of the Julia programming language.</description>
    </item>
    
    <item>
      <title>Tooling Projects – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/tooling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/tooling/</guid>
      <description>Tooling Projects – Summer of Code IDE Tooling Juno is open to general project ideas (from here or not); feel free to get in contact via the forum to discuss!
Progress Meter Improvements Right now Juno&amp;rsquo;s progress metre works well but is fairly basic. In particular, it could be improved by:
 Automatically reducing its own overhead, to avoid slowing down tight loops significantly, Supporting cancellation so that long-running computations can be safely interrupted, Supporting nested loops like for i = 1:10, j = 1:10, and having a real fallback in the console, rather than simply falling through.</description>
    </item>
    
    <item>
      <title>Turing Projects – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/turing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/turing/</guid>
      <description>Turing Projects – Summer of Code Turing is a universal probabilistic programming language embedded in Julia. Turing allows the user to write models in standard Julia syntax, and provide a wide range of sampling-based inference methods for solving problems across probabilistic machine learning, Bayesian statistics and data science etc. Since Turing is implemented in pure Julia code, its compiler and inference methods are amendable for hacking: new model families and inference methods can be easily added.</description>
    </item>
    
    <item>
      <title>Unreasonable effectiveness of learning neural networks: From accessible states and robust ensembles to basic algorithmic schemes</title>
      <link>https://julialang.org/research/bbcilsz16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/bbcilsz16/</guid>
      <description>In artificial neural networks, learning from data is a computationally demanding task in which a large number of connection weights are iteratively tuned through stochastic-gradient-based heuristic processes over a cost function. It is not well understood how learning occurs in these systems, in particular how they avoid getting trapped in configurations with poor computational performance. Here, we study the difficult case of networks with discrete weights, where the optimization landscape is very rough even for simple architectures, and provide theoretical and numerical evidence of the existence of rare—but extremely dense and accessible—regions of configurations in the network weight space.</description>
    </item>
    
    <item>
      <title>Variational Quantum Eigensolver with Fewer Qubits</title>
      <link>https://julialang.org/research/lzww19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/lzww19/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Web Platform Projects – Summer of Code</title>
      <link>https://julialang.org/jsoc/gsoc/wasm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/jsoc/gsoc/wasm/</guid>
      <description>Web Platform Projects – Summer of Code Julia has early support for targeting WebAssembly and running in the web browser. Please note that this is a rapidly moving area (see the project repository for a more detailed overview), so if you are interested in this work, please make sure to inform yourself of the current state and talk to us to scope out an appropriate project. The below is intended as a set of possible starting points.</description>
    </item>
    
    <item>
      <title>Yao.jl: Extensible, Efficient Framework for Quantum Algorithm Design</title>
      <link>https://julialang.org/research/llwz19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/llwz19/</guid>
      <description></description>
    </item>
    
    <item>
      <title>技術計算のための新言語Julia (Julia: a new language for technical computing)</title>
      <link>https://julialang.org/research/hn14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://julialang.org/research/hn14/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>