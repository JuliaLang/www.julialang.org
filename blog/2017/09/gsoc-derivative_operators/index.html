<!doctype html> <html lang=en > <meta charset=utf-8 > <meta name=viewport  content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv=x-ua-compatible  content="ie=edge"> <meta name=author  content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al."> <meta name=description  content="The official website for the Julia Language. Julia is a language that is fast, dynamic, easy to use, and open source. Click here to learn more."> <meta name=robots  content="max-image-preview:large"> <meta name="twitter:site:id" content=1237720952 > <meta name=google-site-verification  content=9VDSjBtchQj6PQYIVwugTPY7pVCfLYgvkXiRHjc_Bzw  /> <link rel=stylesheet  href="/libs/bootstrap/bootstrap.min.css"> <link rel=stylesheet  href="/css/app.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/fonts.css"> <link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel=stylesheet > <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel=stylesheet > <script async defer src="/libs/buttons.js"></script> <!-- --> <script type="application/javascript"> var doNotTrack = false; if (!doNotTrack) { window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-28835595-1', 'auto'); ga('send', 'pageview'); } </script> <script async src='https://www.google-analytics.com/analytics.js'></script> <link rel=icon  href="/assets/infra/julia.ico"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <title>GSoC 2017: Efficient Discretizations of PDE Operators</title> <style> .container ul li p {margin-bottom: 0;} </style> <style> .main { font-family: Georgia; } .main pre { margin-left: auto; margin-right: auto; } .main { width: 100%; font-size: 100%; } .main code { font-size: 90%; } .main pre code { font-size: 90%; } @media (min-width: 940px) { .main { width: 800px; } .container.blog-title { width: 800px;} } </style> <meta property="og:title" content="GSoC 2017: Efficient Discretizations of PDE Operators"> <meta property="og:description" content=" GSoC 2017: Efficient Discretizations of PDE Operators | This project is an attempt towards building a PDE solver for JuliaDiffEq using the Finite Difference Method (https://en.wikipedia.org/wiki/Finite_difference_method)(FDM) approach. We take up the FDM approach instead of FEM (https://en.wikipedia.org/wiki/Finite_element_method) and FVM (https://en.w... "> <meta property="og:image" content="/assets/images/julia-open-graph.png"> <div class="container py-3 py-lg-0"> <nav class="navbar navbar-expand-lg navbar-light bg-light" id=main-menu > <a class=navbar-brand  href="/"> <img src="/assets/infra/logo.svg" alt="JuliaLang Logo"> </a> <button class="navbar-toggler ml-auto hidden-sm-up float-xs-left" type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mx-auto"> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/downloads/">Download</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="https://docs.julialang.org">Documentation</a> <li class="nav-item active flex-md-fill text-md-center"> <a class=nav-link  href="/blog/">Blog</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/community/">Community</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/learning/">Learn</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/research/">Research</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/jsoc/">JSoC</a> </ul> <span class=navbar-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a> </span> </div> </nav> </div> <br><br> <div class="container blog-title"> <h1>GSoC 2017: Efficient Discretizations of PDE Operators <a type="application/rss+xml" href="https://julialang.org/feed.xml"> <i class="fa fa-rss-square rss-icon"></i> </a> </h1> <h3> <span style="font-weight: lighter;"> 6 September 2017 </span> | <span style="font-weight: bold;"></span> <span style="font-weight: bold;">Shivin Srivastava, Christopher Rackauckas </span> </h3> </div> <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/blog/2017/09/gsoc-derivative_operators.md" title="Edit this page on GitHub" class=edit-float > </a> <div class="container main"><p>This project is an attempt towards building a PDE solver for JuliaDiffEq using the <a href="https://en.wikipedia.org/wiki/Finite_difference_method">Finite Difference Method</a>&#40;FDM&#41; approach. We take up the FDM approach instead of <a href="https://en.wikipedia.org/wiki/Finite_element_method">FEM</a> and <a href="https://en.wikipedia.org/wiki/Finite_volume_method">FVM</a> as there are many toolboxes which already exist for FEM and FVM but not for FDM. Also, there are many use cases where the geometry of the problem is simple enough to be solved by FDM methods which are much faster due to their being able to avoid the bottleneck step of matrix multiplication by using Linear transformations to mimic the effect of a matrix multiplication. Since matrix multiplication basically transforms a vector element to a weighted sum of the neighbouring elements, this can be easily acheived using a special function which acts on the vector in optimal \(\mathcal{O}(n)\) time.</p> <p>The result is a new package called <a href="https://github.com/SciML/DiffEqOperators.jl">DiffEqOperators.jl</a> which creates efficient discretizations of partial differential operators thereby converting PDEs to ODEs which can be solved efficiently by existing ODE solvers. The <code>DerivativeOperator</code> is based on central differencing schemes of approximating derivatives at a point whereas the <code>UpwindOperators</code> are based on one-sided differencing schemes where the solution is typically a wave moving in a particular direction. The package also supports a variety of boundary conditions like <a href="https://en.wikipedia.org/wiki/Dirichlet_boundary_condition">Dirichlet</a>, <a href="https://en.wikipedia.org/wiki/Neumann_boundary_condition">Neumann</a>, <a href="https://en.wikipedia.org/wiki/Periodic_boundary_conditions">Periodic</a> and the <a href="https://en.wikipedia.org/wiki/Robin_boundary_condition">Robin</a> <a href="https://en.wikipedia.org/wiki/Boundary_value_problem">boundary condition</a>.</p> <div class=franklin-toc ><ol><li><a href="#motivation">Motivation</a><li><a href="#solving_the_heat_equation_using_diffeqoperators">Solving the Heat equation using DiffEqOperators</a><li><a href="#where_do_central_derivatives_fail">Where do central derivatives fail?</a><li><a href="#future_work">Future Work</a><li><a href="#acknowledgments">Acknowledgments</a></ol></div> <h2 id=motivation ><a href="#motivation">Motivation</a></h2> <p>The general idea of finite difference methods is to generate finite difference weights corresponding to a differential operator allowing a certain level of approximation. The time and space variable are divided to form a grid where \(h = \Delta x = \frac{1}{N+1}\) and \(x_i = ih\) for \(i = 0, 1,...,N+1\) and \(k = \Delta t = \frac{T}{M+1}\) and \(t_j = jk\) for \(j = 0, 1,...,M+1\). <br/> The discrete unknowns are scalars \(u_i^j\) for the above values of i and j, and it is hoped that \(u_i^j\) will be an approximation of \(u(x_i, t_j)\). The right-hand side of the equation is discretized by setting \(f_i^j = f(x_i, t_j)\). We also use the notation</p> \[ U^{j} = \begin{pmatrix} u_1^j\\ u_2^j \\ \vdots \\ u_N^j \end{pmatrix} \] <p>to denote the vector of approximate values on the space grid at time \(t_j\).</p> \[\frac{\partial u}{\partial t}(x_i,t_j) \approx \frac{u(x_i,t_{j+1}) - u(x_i,t_j)}{k}\] <p>and for the second space derivative, by combining a forward and a backward differential quotient, we obtain the central approximation</p> \[ \frac{\partial^2u }{\partial x^2}(x_i,t_j) \approx \frac{\frac{u(x_{i+1},t_j) - u(x_i,t_j)}{h} - \frac{u(x_i,t_j) - u(x_{i-1},t_j)}{h}}{h} = \frac{u(x_{i-1},t_j) - 2u(x_i,t_j) + u(x_{i+1}, t_j)} {h^2} \] <p>So the weights corresponding to the second order partial derivative are \([1, -2, 1]\). The finite difference method mimics these approximations by replacing the exact values of the solution at the grid points by the discrete unknowns.</p> <p>In this particular case, we end up with the following scheme:</p> \[ \left\{\begin{matrix} \frac{u_j^{j+1} - u_i^j}{k} - \frac{u_{i-1}^j - 2u_i^j + u_{i+1}^j}{h^2} = f_i^j \quad\textit{ for }\quad i = 1,...,N,j = 1,...,M \\ u_i^0 = u_0(x_i) \quad\textit{ for }\quad i = 1,...,N\\ u_0^j = u_{N+1}^j = 0 \quad\textit{ for }\quad j = 1,...,M+1\\ \end{matrix}\right. \] <p>This is the stencil rewritten as a recurrence. Writing it out in vector form, we get:- \(\frac{U^{j+1} - U^j}{k} + A_h U^j = F^j \quad\textit{ for }\quad j = 1,...,M\)</p> <p>When we want to apply this operator on the vector \(U\), the weight vector turns into a matrix called the transformation matrix \(A_h\)</p> \[ A_h = \begin{pmatrix} 2 & -1 & 0 & \cdots & 0\\ -1 & 2 & -1 & \cdots & 0\\ \vdots & \ddots & \ddots & \ddots & \vdots \\ 0 & \cdots & -1 & 2 & -1 \\ 0 & \cdots & 0 & -1 & 2 \\ \end{pmatrix} \quad\textit{such that }\quad \frac{\partial^2U^j}{\partial x^2} \approx A_h*U^j \] <p>But matrix multiplication is costly, therefore it would be preferable to have the linear operator of the double partial differential instead of the transformation matrix. It would look something like:-</p> <p>function double_partial&#40;x,dx&#41; for i in 2:length&#40;dx&#41;-1 dx&#91;i&#93; &#61; -1*x&#91;i-1&#93; &#43; 2*x&#91;i&#93; &#43; -1*x&#91;i&#43;1&#93; end dx&#91;1&#93; &#61; 2*x&#91;1&#93; &#43; -1*x&#91;2&#93; dx&#91;end&#93; &#61; -1*x&#91;end-1&#93; &#43; 2*x&#91;end&#93; end</p> <p>This function acts on the vector in an optimal \(\mathcal{O}(n)\) time as compared to the inefficient \(\mathcal{O}(n^2)\) time taken by matrix multiplication while still avoiding the overheads of sparse matrices.</p> <p>So to convert the PDE into an ODE, we discritize the equation in space but not in time. Then this ODE can be solved efficiently by the existing solvers. Our semi-linear heat equation also known as the reaction-diffusion equation transforms to the following ODE. \(u_i' = A_{h}u_i + f(t,u_i)\) Where \(A\) is a linear operator and not the transformation matrix. Thus we will have to make the ODE solvers of <strong>DifferentialEquations.jl</strong> compatible with linear operators also.</p> <p>Since it is tedious to compute the Taylor coefficients by hand, Fornberg gave an <a href="https://www.scribd.com/document/436149037/MathComp-88-FD-formulas-pdf">algorithm</a> to compute them efficiently for any derivative and approximation order. These stencils can efficiently compute derivatives at any point by taking appropriately weighted sums of neighboring points. For example, \([-1, 2, -1]\) is the second order stencil for calculating the 2nd derivative at a point.</p> <p>In <strong>DiffEqOperators.jl</strong> we can easily extract stencils of any derivative and approximation order from an operator. For eg.</p> <pre><code class=language-julia ># Define A as a DerivativeOperator of 4th order and of 2nd order of accuracy

julia&gt; A &#61; DerivativeOperator&#123;Float64&#125;&#40;4,2,1.0,10,:Dirichlet0,:Dirichlet0&#41;
julia&gt; A.stencil_coefs
7-element SVector&#123;7,Float64&#125;:
  -0.166667
   2.0     
  -6.5     
   9.33333
  -6.5     
   2.0     
  -0.166667</code></pre> <p>If we want to apply the operator as a matrix multiplication &#40;sparse or dense&#41; we can easily do so by extracting the <em>matrix of transformation</em> of the linear operator which looks like:-</p> <pre><code class=language-julia >julia&gt; full&#40;A&#41;
10×10 Array&#123;Float64,2&#125;:
 9.33333   -6.5        2.0       …   0.0        0.0        0.0     
-6.5        9.33333   -6.5           0.0        0.0        0.0     
 2.0       -6.5        9.33333       0.0        0.0        0.0     
-0.166667   2.0       -6.5           0.0        0.0        0.0     
 0.0       -0.166667   2.0          -0.166667   0.0        0.0     
 0.0        0.0       -0.166667  …   2.0       -0.166667   0.0     
 0.0        0.0        0.0          -6.5        2.0       -0.166667
 0.0        0.0        0.0           9.33333   -6.5        2.0     
 0.0        0.0        0.0          -6.5        9.33333   -6.5     
 0.0        0.0        0.0           2.0       -6.5        9.33333

julia&gt; sparse&#40;A&#41;
 10×10 SparseMatrixCSC&#123;Float64,Int64&#125; with 58 stored entries:
 &#91;1 ,  1&#93;  &#61;  9.33333
 &#91;2 ,  1&#93;  &#61;  -6.5
 &#91;3 ,  1&#93;  &#61;  2.0
 &#91;4 ,  1&#93;  &#61;  -0.166667
 &#91;1 ,  2&#93;  &#61;  -6.5
 &#91;2 ,  2&#93;  &#61;  9.33333
 &#91;3 ,  2&#93;  &#61;  -6.5
 ⋮
 &#91;7 ,  9&#93;  &#61;  2.0
 &#91;8 ,  9&#93;  &#61;  -6.5
 &#91;9 ,  9&#93;  &#61;  9.33333
 &#91;10,  9&#93;  &#61;  -6.5
 &#91;7 , 10&#93;  &#61;  -0.166667
 &#91;8 , 10&#93;  &#61;  2.0
 &#91;9 , 10&#93;  &#61;  -6.5
 &#91;10, 10&#93;  &#61;  9.33333</code></pre> <p>Stencil multiplications are <strong>embarrassingly parallel</strong> and this have been taken cared of <strong>DiffEqOperators.jl</strong>.</p> <h2 id=solving_the_heat_equation_using_diffeqoperators ><a href="#solving_the_heat_equation_using_diffeqoperators">Solving the Heat equation using DiffEqOperators</a></h2> <p>Now let us solve the solve the famous heat equation using the explicit discretization on a 2D <code>space x time</code> grid. The heat equation is:-</p> \[\frac{\partial u}{\partial t} - \frac{\partial^2 u}{\partial x^2} = 0\] <p>For this example we consider a Dirichlet boundary condition with the initial distribution being parabolic. Since we have fixed the value at boundaries &#40;in this case equal&#41;, after a long time we expect the 1D rod to be heated in a linear manner.</p> <pre><code class=language-julia >julia&gt; using DiffEqOperators, DifferentialEquations, Plots
julia&gt; x &#61; -pi : 2pi/511 : pi;
julia&gt; u0 &#61; -&#40;x - 0.5&#41;.^2 &#43; 1/12;
julia&gt; A &#61; DerivativeOperator&#123;Float64&#125;&#40;2,2,2pi/511,512,:Dirichlet,:Dirichlet;BC&#61;&#40;u0&#91;1&#93;,u0&#91;end&#93;&#41;&#41;;</code></pre> <p>This is the code to set-up the problem. First we define the domain which is just a plane line divided up into <code>512</code> segments. Then we define the initial condition, which is a parabolic function of the x-coordinate.</p> <p>Finally we initialize the <code>DerivativeOperator</code> of 2nd derivative order and 2nd approximation order. We tell the grid step value, total length of the domain and the boundary conditions at both the ends. Notice that since we are applying the Dirichlet boundary condition here, we need to tell the value at boundaries which is given in the form of a tuple as the last parameter.</p> <p>Now solving equation as an ODE we have:-</p> <pre><code class=language-julia >julia&gt; prob1 &#61; ODEProblem&#40;A, u0, &#40;0.,10.&#41;&#41;;
julia&gt; sol1 &#61; solve&#40;prob1, dense&#61;false, tstops&#61;0:0.01:10&#41;;
# try to plot the solution at different time points using
julia&gt; plot&#40;x, &#91;sol1&#40;i&#41; for i in 0:1:10&#93;&#41;</code></pre> <p><img src="/assets/blog/2017-09-06-gsoc-derivative_operators/heat_eqn_D1.png" alt="Heat Equation" /></p> <p>Notice how the heat distribution &#39;flattens&#39; out with time as expected and finally tends to increase linearly from left to right end.</p> <h2 id=where_do_central_derivatives_fail ><a href="#where_do_central_derivatives_fail">Where do central derivatives fail?</a></h2> <p>Not all PDEs can be solved with central derivatives, for example the <strong>KdV wave equation</strong>. After a few iterations of the ODE solver the wave begins to split ie. it becomes unstable very quickly.</p> <p><img src="/assets/blog/2017-09-06-gsoc-derivative_operators/kdv_derivative.png" alt="KdV using central derivatives" /></p> <p>For these very cases the <a href="https://en.wikipedia.org/wiki/Upwind_scheme">upwind scheme</a> has been devised. It denote a class of numerical discretization methods for solving hyperbolic PDEs. They attempt to discretize hyperbolic PDEs by using differencing biased in the direction determined by the sign of the characteristic speeds. For example the 1D linear advection equation</p> \[ \frac{\partial u}{\partial t} + a\frac{\partial u}{\partial x}=0 \] <p>describes a wave propagating along the x-axis with a velocity \(a\). If \(a\) is positive, the traveling wave solution of the equation above propagates towards the right, the left side is then called the upwind side and the right side is called the the downwind side. If the finite difference scheme for the spatial derivative, \(\frac{\partial u}{\partial x}\) contains more points in the upwind side, the scheme is called <strong>upwind scheme</strong>. Considering a case of 2nd upwind scheme, define</p> \[ a^{+} = max(a,0)\] \[a^{-} = min(a,0)\] \[u_x^- = \frac{3u_i^n-4u_{i-1}^n+u_{i-2}^n}{2\Delta x}\] \[u_x^+ = \frac{-u_{i+2}^n+4u_{i+1}^n-3u_{i}^n}{2\Delta x} \] <p>The general solution can then be written as follows:- \(u_i^{n+1} = u_i^n - \Delta t[a^{+}u_x^{-} + a^{-}u_x^{+}]\)</p> <p>The solution of the <strong>KdV equation</strong> using upwind operator looks better.</p> <p><img src="/assets/blog/2017-09-06-gsoc-derivative_operators/kdv_upwind.png" alt="KdV solved using Upwind operators" /></p> <h2 id=future_work ><a href="#future_work">Future Work</a></h2> <p>Although vanilla <code>DerivativeOperators</code> and the <code>UpwindOperators</code> form the major part of DiffEqOperators there is still a lot to be done. A major functionality which is half implemented is application of DiffEqOperators on high dimensional spaces. Currently we support mixed and normal derivatives on 2D spaces only. There are open <a href="https://github.com/SciML/DiffEqOperators.jl/issues/20">issues</a> and implementation <a href="https://github.com/SciML/DiffEqOperators.jl/issues/21">ideas</a> on the issues page.</p> <p>We are also working on the Robin boundary conditions for <code>DerivativeOperators</code> which are currently not as accurate as they <a href="https://gist.github.com/shivin9/124ed1e5ea96792fc8666e0caf32715c">should</a> be.</p> <p>Another avenue for work is the lazy implementations of <code>expm</code> and <code>expmv</code> for <code>DerivativeOperators</code>. </p> <h2 id=acknowledgments ><a href="#acknowledgments">Acknowledgments</a></h2> <p>I would like to thank my mentors Christopher Rackauckas and <a href="https://github.com/dextorious">@dextorious</a> for their immense support before and throughout the project.</p> </div><br><br> <script src="/libs/katex/katex.min.js"></script> <script src="/libs/katex/auto-render.min.js"></script> <script>renderMathInElement(document.body)</script> <script src="/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script> <footer class="container-fluid footer-copy"> <div class=container > <div class="row footrow"> <ul> <li><a href="/project">About</a> <li><a href="/about/help">Get Help</a> <li><a href="/blog/2019/02/julia-entities/">Governance</a> <li><a href="/research/#publications">Publications</a> <li><a href="/research/#sponsors">Sponsors</a> </ul> <ul> <li><a href="/downloads/">Downloads</a> <li><a href="/downloads/">All Releases</a> <li><a href="https://github.com/JuliaLang/julia">Source Code</a> <li><a href="/downloads/#current_stable_release">Current Stable Release</a> <li><a href="/downloads/#long_term_support_release">Longterm Support Release</a> <li><a href="https://status.julialang.org/">PkgServer Status</a> </ul> <ul> <li><a href="https://docs.julialang.org/en/v1/">Documentation</a> <li><a href="https://juliaacademy.com">JuliaAcademy</a> <li><a href="https://www.youtube.com/user/JuliaLanguage">YouTube</a> <li><a href="/learning/getting-started/">Getting Started</a> <li><a href="https://docs.julialang.org/en/v1/manual/faq/">FAQ</a> <li><a href="/learning/books">Books</a> </ul> <ul> <li><a href="/community/">Community</a> <li><a href="/community/standards/">Code of Conduct</a> <li><a href="/diversity/">Diversity</a> <li><a href="https://juliacon.org">JuliaCon</a> <li><a href="/community/#julia_user_and_developer_survey">User/Developer Survey</a> <li><a href="/shop/">Shop Merchandise</a> </ul> <ul> <li><a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">Contributing</a> <li><a href="https://github.com/JuliaLang/julia/issues">Issue Tracker</a> <li><a href="https://github.com/JuliaLang/julia/security/policy">Report a Security Issue</a> <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22help+wanted%22">Help Wanted Issues</a> <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22good+first+issue%22+">Good First Issue</a> <li><a href="https://docs.julialang.org/en/v1/devdocs/reflection/">Dev Docs</a> </ul> </div> <div id=footer-bottom  class=row > <div class="col-md-10 py-2"> <p>Built with <a href="https://franklinjl.org">Franklin.jl</a> and the <a href="https://julialang.org">Julia Programming Language</a>. We thank <a href="https://www.fastly.com">Fastly</a> for their generous infrastructure support.</p> <p>©2020 JuliaLang.org <a href="https://github.com/JuliaLang/www.julialang.org/graphs/contributors">contributors</a>. The content on this website is made available under the <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT license</a>. </div> <div class="col-md-2 py-2"> <span class=float-sm-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a> </span> </div> </div> </div> </footer> <script src="/libs/jquery/jquery.min.js"></script> <script src="/libs/bootstrap/bootstrap.min.js"></script>