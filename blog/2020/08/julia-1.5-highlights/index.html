<!doctype html> <html lang=en > <meta charset=utf-8 > <meta name=viewport  content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv=x-ua-compatible  content="ie=edge"> <meta name=author  content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al."> <meta name=description  content="The official website for the Julia Language. Julia is a language that is fast, dynamic, easy to use, and open source. Click here to learn more."> <meta name=robots  content="max-image-preview:large"> <meta name="twitter:site:id" content=1237720952 > <meta name=google-site-verification  content=9VDSjBtchQj6PQYIVwugTPY7pVCfLYgvkXiRHjc_Bzw  /> <link rel=stylesheet  href="/libs/bootstrap/bootstrap.min.css"> <link rel=stylesheet  href="/css/app.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/fonts.css"> <link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel=stylesheet > <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel=stylesheet > <script async defer src="/libs/buttons.js"></script> <!-- --> <script type="application/javascript"> var doNotTrack = false; if (!doNotTrack) { window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-28835595-1', 'auto'); ga('send', 'pageview'); } </script> <script async src='https://www.google-analytics.com/analytics.js'></script> <link rel=icon  href="/assets/infra/julia.ico"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <title>Julia 1.5 Highlights</title> <style> .container ul li p {margin-bottom: 0;} </style> <style> .main { font-family: Georgia; } .main pre { margin-left: auto; margin-right: auto; } .main { width: 100%; font-size: 100%; } .main code { font-size: 90%; } .main pre code { font-size: 90%; } @media (min-width: 940px) { .main { width: 800px; } .container.blog-title { width: 800px;} } </style> <meta property="og:title" content="Julia 1.5 Highlights"> <meta property="og:description" content="Julia version 1.5 has been released, featuring many performance improvements and new capabilities."> <meta property="og:image" content="/assets/images/julia-open-graph.png"> <div class="container py-3 py-lg-0"> <nav class="navbar navbar-expand-lg navbar-light bg-light" id=main-menu > <a class=navbar-brand  href="/"> <img src="/assets/infra/logo.svg" alt="JuliaLang Logo"> </a> <button class="navbar-toggler ml-auto hidden-sm-up float-xs-left" type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mx-auto"> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/downloads/">Download</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="https://docs.julialang.org">Documentation</a> <li class="nav-item active flex-md-fill text-md-center"> <a class=nav-link  href="/blog/">Blog</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/community/">Community</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/learning/">Learn</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/research/">Research</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/jsoc/">JSoC</a> </ul> <span class=navbar-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a> </span> </div> </nav> </div> <br><br> <div class="container blog-title"> <h1>Julia 1.5 Highlights <a type="application/rss+xml" href="https://julialang.org/feed.xml"> <i class="fa fa-rss-square rss-icon"></i> </a> </h1> <h3> <span style="font-weight: lighter;"> 3 August 2020 </span> | <span style="font-weight: bold;"></span> <span style="font-weight: bold;">Jeff Bezanson & Stefan Karpinski </span> </h3> </div> <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/blog/2020/08/julia-1.5-highlights.md" title="Edit this page on GitHub" class=edit-float > </a> <div class="container main"><p><a href="https://discourse.julialang.org/t/julia-v1-5-0-has-been-released/44169">Julia version 1.5 has been released</a>. Releases are timed and hence not planned around specific features, but this time we seem to have gotten lucky: quite a few major developments came together to make 1.5 particularly exciting. Let&#39;s walk through some highlights.</p> <div class=franklin-toc ><ol><li><a href="#struct_layout_and_allocation_optimizations">Struct layout and allocation optimizations</a><li><a href="#multithreading_api_stabilization_improvements">Multithreading API stabilization &amp; improvements</a><li><a href="#per-module_optimization_levels">Per-module optimization levels</a><li><a href="#other_latency_improvements">Other latency improvements</a><li><a href="#implicit_keyword_argument_values">Implicit keyword argument values</a><li><a href="#the_return_of_soft_scope_in_the_repl">The return of &quot;soft scope&quot; in the REPL</a><li><a href="#new_ccall_macro">New <code>@ccall</code> macro</a><li><a href="#faster_random_numbers">Faster random numbers</a><li><a href="#automated_rr-based_bug_reports">Automated rr-based bug reports</a><li><a href="#pkg_protocol_now_the_default">Pkg Protocol now the default</a><li><a href="#conclusion">Conclusion</a></ol></div> <h2 id=struct_layout_and_allocation_optimizations ><a href="#struct_layout_and_allocation_optimizations">Struct layout and allocation optimizations</a></h2> <p>This release brings a major, long-desired optimization that can significantly reduce heap allocations in some workloads. To understand it, it helps to know a bit about Julia’s object model. Julia has both mutable and immutable kinds of objects. New record &#40;composite&#41; types declared with <code>struct</code> are immutable, whereas if you want a mutable record, you have to use <code>mutable struct</code> to declare the new type. The language automatically picks memory layouts and calling conventions for each type, generally trying to be compatible with C/C&#43;&#43;. In general, a mutable object must exist in a single location on the heap, so mutable objects will be stored and passed by reference &#40;unless the compiler can prove that it won’t matter&#41;. Immutable objects, on the other hand, give the compiler much greater flexibility. For example, an immutable struct containing two values could be passed to a function by reference just like a mutable struct with the same fields, but it can also be passed just by passing those two values in registers—because there’s no memory location that needs to be kept in sync with the values since regardless of where they came from, they cannot be modified.</p> <p>Prior to this release, layout optimizations for immutable objects had a significant limitation: if an immutable object pointed to a heap-allocated, mutable object, it would itself need to be heap-allocated. That was an artifact of how the garbage collector and code generator worked: it was simpler for there to be a one-to-one correspondence between object fields and GC roots. For 1.5, Jameson Nash did a <a href="https://github.com/JuliaLang/julia/pull/33886">redesign</a> to fix this, allowing the compiler to track multiple roots inside object fields.</p> <p>As a result of this work, arbitrary immutable objects—regardless of whether they have fields that reference mutable objects or not—can now be stack allocated, passed and returned by value, and stored inline in arrays and other objects. In short, immutable structs that refer to mutable values are now just as efficient as immutable structs that only refer to other immutable objects. &#40;There are some size-based limits to which structs can be stack allocated, but they are unlikely to be exceeded in practice.&#41;</p> <p>This is a big deal because many important abstractions can only be implemented by wrapping mutable objects in structs. The classic example in Julia is array &quot;views&quot; &#40;the <code>SubArray</code> type&#41;, which wrap mutable arrays together with some metadata about how to translate indices into the view into indices into the original array. The purpose of a view is to be able to pass part of an array to a function without copying it. However, if the view object itself needs to be heap allocated, we find ourselves in the unfortunate situation where using views to eliminate allocation itself causes allocation: in previous Julia versions, you had to choose between copying array slices or using views but having to allocate view objects. Even though view objects are small and relatively cheap to allocate, any amount of allocation can inhibit optimizations and trigger garbage collection, both of which can be painful in performance-critical code. Eliminating this allocation has been sufficiently important for some users that the <a href="https://github.com/JuliaArrays/UnsafeArrays.jl">UnsafeArrays</a> package exists solely to allow creating views without allocating.</p> <p>In 1.5 this difficult choice goes away: using views no longer forces allocation. This means that <code>UnsafeArrays</code> is no longer necessary in the vast majority of cases. Needless to say, removing the need for elaborate performance workarounds is always one of the highest aspirations of a compiler developer. To see this in action, here is a simple function for summing n x n neighborhoods of a matrix:</p> <pre><code class=language-julia >function sum_neighborhoods&#40;A, n::Int&#41;
    return &#91; sum&#40;@view A&#91;i:i&#43;n-1, j:j&#43;n-1&#93;&#41; for i &#61; 1:n:size&#40;A,1&#41;, j &#61; 1:n:size&#40;A,2&#41; &#93;
end</code></pre> <p>Note this uses the <code>@view</code> macro to create an in-place view of each n x n region. We can use the BenchmarkTools package to check its resource usage. Here are the results in Julia v1.4:</p> <pre><code class=language-julia >julia&gt; using BenchmarkTools

julia&gt; x &#61; rand&#40;1000, 1000&#41;;

julia&gt; @benchmark sum_neighborhoods&#40;&#36;x, 2&#41;
BenchmarkTools.Trial:
  memory estimate:  17.17 MiB
  allocs estimate:  250004
  --------------
  minimum time:     4.510 ms &#40;0.00&#37; GC&#41;
  median time:      5.320 ms &#40;0.00&#37; GC&#41;
  mean time:        5.411 ms &#40;5.25&#37; GC&#41;
  maximum time:     11.100 ms &#40;11.41&#37; GC&#41;
  --------------
  samples:          923
  evals/sample:     1</code></pre> <p>Here are the results in v1.5:</p> <pre><code class=language-julia >julia&gt; @benchmark sum_neighborhoods&#40;&#36;x, 2&#41;
BenchmarkTools.Trial:
  memory estimate:  1.91 MiB
  allocs estimate:  2
  --------------
  minimum time:     3.479 ms &#40;0.00&#37; GC&#41;
  median time:      4.007 ms &#40;0.00&#37; GC&#41;
  mean time:        4.297 ms &#40;2.03&#37; GC&#41;
  maximum time:     8.191 ms &#40;29.20&#37; GC&#41;
  --------------
  samples:          1164
  evals/sample:     1</code></pre> <p>The speedup is actually not that large, which is a testament to the fact that Julia&#39;s allocator is very efficient, but note the difference in allocations: 250004 on 1.4 versus 2 on 1.5. The difference is all those view objects which don&#39;t need to heap allocated anymore.</p> <p>We would like to thank <a href="https://www.relational.ai/">RelationalAI</a> for sponsoring this work.</p> <h2 id=multithreading_api_stabilization_improvements ><a href="#multithreading_api_stabilization_improvements">Multithreading API stabilization &amp; improvements</a></h2> <p>Improving support for parallelism is a major focus of ongoing work. Threading was introduced as an experimental feature way back in v0.5, and since then nearly every release has increased thread safety and added new features. In particular, 1.3 was a major milestone release for threading because it <a href="https://julialang.org/blog/2019/07/multithreading/">introduced</a> the <code>@spawn</code> construct &#40;along with all the supporting infrastructure&#41; for composable multithreading, a la Go’s &quot;goroutines&quot;, but with a focus on high-performance computing.</p> <p>Many Julia programmers are using threads at this point, and major performance wins like multithreaded <a href="https://github.com/JuliaData/CSV.jl">CSV parsing</a> have emerged. As a result we felt the &quot;experimental&quot; label was no longer really appropriate, and in this release we are marking most of the thread API as stable. We explicitly documented the remaining limitations and the parts of the API that may still change. Here is a brief overview of thread-related work that has gone into this release:</p> <ul> <li><p>Improved thread-safety of some top level expressions: type definitions, global assignments, modules</p> <li><p>Made <code>@sync</code> thread-safe</p> <li><p>Made the SuiteSparse bindings thread-safe</p> <li><p>Improvements to task switch performance</p> <li><p>New <code>@threads :static</code> syntax to request the current default threaded loop schedule, allowing us to change the default schedule in the future</p> <li><p>The <code>-t</code> command line option for specifying the number of threads to use</p> <li><p>A <code>lock&#61;false</code> option to <code>open</code> for faster single-thread access to files</p> </ul> <p>We&#39;re very much looking forward to more performance wins in the ecosystem as developers start taking advantage of the stability of the threading API.</p> <h2 id=per-module_optimization_levels ><a href="#per-module_optimization_levels">Per-module optimization levels</a></h2> <p>Being a greedy language, we often try to have things both ways. That isn&#39;t always easy, and the trade-off between compilation time and run-time performance has been a particular source of frustration. To provide a good initial user experience, the default optimization level we use is <code>-O2</code>, which is roughly similar to the <code>-O2</code> option in <code>gcc</code> or <code>clang</code>. That&#39;s great for compute kernels and benchmarks, but not all code is performance-critical, and Julia users are loading more and larger packages for plotting and other &quot;non-inner-loop&quot; support tasks all the time. To help reduce compilation delays for such packages, it is now possible to provide an optimization level hint in each module. For example, Plots.jl specifies <code>@optlevel 1</code>, indicating that it wants to use the <code>-O1</code> optimization level, rather than the default <code>-O2</code>. This cuts the time-to-first-plot by about a third.</p> <h2 id=other_latency_improvements ><a href="#other_latency_improvements">Other latency improvements</a></h2> <p>In addition to <code>@optlevel</code>, we have been chipping away at other compiler performance issues — sometimes big improvements come just one or two percent at a time. Browsing through <a href="https://github.com/JuliaLang/julia/pulls?q&#61;is&#37;3Apr&#43;label&#37;3Alatency">the &quot;latency&quot; label</a> on github gives some idea of what is involved. The net effect of this work is that, moving from version 1.4 to 1.5, the time to load the Plots.jl package &#40;<code>using Plots</code>&#41; goes from 9.8 seconds to 6.1 seconds &#40;38&#37; faster&#41;, and the time to generate the first plot goes from 11.7 seconds to 7.8 seconds &#40;33&#37; faster&#41;. Your mileage may vary of course — performance is always highly dependent on the system hardware and configuration. But in general, this release improves compiler latency by a considerable margin over 1.4, which was already snappier than earlier releases.</p> <h2 id=implicit_keyword_argument_values ><a href="#implicit_keyword_argument_values">Implicit keyword argument values</a></h2> <p>When passing a keyword argument, or constructing a named tuple, it&#39;s quite common for the value to be held in a variable with the same name as the argument or field name. For example, if you are printing colored text and have the color to use in a variable called <code>color</code>, you need to write <code>printstyled&#40;&quot;text&quot;, color&#61;color&#41;</code>. Typing the same words twice all the time can get tedious, especially when delegating several keyword arguments to another function. This release adds a convenient shorthand that has already become popular in several other languages &#40;such as TypeScript&#41;:</p> <ul> <li><p><code>printstyled&#40;&quot;text&quot;; color&#41;</code> is an abbreviation for</p> <li><p><code>printstyled&#40;&quot;text&quot;; color &#61; color&#41;</code>.</p> </ul> <p>Note the semicolon before the <code>color</code> argument: this is necessary for Julia to distinguish this shorthand syntax from passing <code>color</code> as a second positional argument. A similar shorthand works for named tuples:</p> <ul> <li><p><code>&#40;; name, value, type&#41;</code> is shorthand for</p> <li><p><code>&#40;name &#61; name, value &#61; value, type &#61; type&#41;</code>.</p> </ul> <p>These shorthands also work when the value being passed is a field in a structure with the same name as the keyword argument &#40;or anything else that uses <code>object.field</code> syntax&#41;:</p> <ul> <li><p><code>printstyled&#40;&quot;text&quot;; opts.color&#41;</code> is shorthand for</p> <li><p><code>printstyled&#40;&quot;text&quot;; color &#61; opts.color&#41;</code>.</p> </ul> <p>Although this change doesn&#39;t allow programmers to <em>do</em> anything they couldn&#39;t do before, it makes writing code that works with keyword arguments and named tuples a lot more pleasant, concise and readable.</p> <h2 id=the_return_of_soft_scope_in_the_repl ><a href="#the_return_of_soft_scope_in_the_repl">The return of &quot;soft scope&quot; in the REPL</a></h2> <p>Variable scope is a surprisingly rich source of design conundrums in programming languages. For the most part, dividing a program into many nested scopes is a great thing: it aids in local reasoning about what code means, it enables optimizations, and it prevents changes in one section of code from accidentally breaking distant, unrelated code. All good features for &quot;programming in the large&quot;. But for quick, experimental programming it is tedious to worry about the lifetime of every variable, and in particular, the safe default of making things local rather than global can sometimes be confusing and inconvenient when working interactively.</p> <p>In 0.x versions of Julia, we did some clever &quot;guessing&quot; about when users wanted a variable to be local or global. The basic rule was that inside of a loop but outside of any function body—in a so-called &quot;soft scope&quot;—when the user assigned to a variable, if there was already a global by that name, it was assigned, but if there wasn&#39;t a global by that name, then the assignment would create a new variable local to the loop. This was a really effective heuristic and approximates what happens inside of function bodies as closely as possible in global scope. However, there were some issues: some people found it confusing and inconsistent, and it made it impossible to statically determine the meaning of code since whether a global by a given name exists or not cannot be statically determined in a dynamic language like Julia. So for the 1.0 release of Julia, we simplified the rules: no more guessing what the user meant: if you assign to a variable in a local scope &#40;function or loop&#41; and there&#39;s no local by that name, then that assignment creates a new local variable. Period. End of story, dead simple rule.</p> <p>Despite the &quot;on paper&quot; simplicity of the 1.0 scope rule, many people found it unintuitive and annoying. Consider the following example:</p> <pre><code class=language-julia >s &#61; 0
for i &#61; 1:10
    s &#61; s &#43; i
end
println&#40;s&#41;</code></pre> <p>One would naively guess that this prints the number <code>55</code>, and prior to Julia 1.0 that&#39;s exactly what it did. But in 1.0, we consistently made <code>for</code> loops introduce new local scopes, which means that this code would throw an undefined variable error because <code>s</code> is deemed to be local to the loop: since there is no pre-existing local <code>s</code> &#40;only a global <code>s</code>&#41; and <code>s</code> is assigned in the loop, it is local and the first iteration of the loop tries to access an undefined local <code>s</code>.</p> <p>In a long top-level script where you may not realize you are overwriting a global variable used in a different part of the file, this default assumption of localness can be better &#40;indeed, many bugs were uncovered when we changed the behavior for 1.0&#41;, but for interactive use, this is decidedly unfriendly. It is also a pain when using the REPL to debug: code that works in a function body doesn&#39;t work the same way in the REPL without extra <code>global</code> annotations.</p> <p>This was enough of an issue—especially for new users—that the developers of <a href="https://github.com/JuliaLang/IJulia.jl">IJulia</a> took matters into their own hands and added code to rewrite inputs in a way that restores the old pre-1.0 scope behavior. Having the commonly-used Jupyter front-end behave differently than the default REPL is not a good situation, so we had to do something.</p> <p>After a lengthy discussion and several designs considered and prototyped, we settled on the following solution in v1.5:</p> <ul> <li><p>Make the REPL behave like IJulia, and Julia versions 0.6 or earlier.</p> <li><p>Keep the 1.0 behavior in files, to avoid breaking anybody&#39;s code.</p> <li><p>Print a warning if code in a file would behave differently than in the REPL, requesting an explicit <code>local</code> or <code>global</code> declaration to disambiguate the variable in the loop.</p> </ul> <p>We feel this is the best that can be done without making breaking changes. Arguably, it&#39;s the best that can be done even allowing breaking changes, without radically changing the way scopes or variable declarations work. It has several desirable properties:</p> <ul> <li><p>Code works as expected by new users in the REPL and in notebooks.</p> <li><p>You can cut and paste code between function bodies and the REPL for debugging.</p> <li><p>In files, where accidentally clobbering a global by assigning to it inside of a local scope is a real problem, you get a clear warning, prompting you to clarify whether the clobbering is intentional.</p> </ul> <p>This change fixes a common stumbling block for new Julia users and an annoyance for regular users who like to use the REPL for debugging, while not sacrificing the suitability of the language for reliable programming at scale.</p> <h2 id=new_ccall_macro ><a href="#new_ccall_macro">New <code>@ccall</code> macro</a></h2> <p>Julia has long had a capable and widely-used interface for calling C functions. While the functionality is fine, some greedy programmers &#40;our favorite kind&#41; pointed out that the syntax is less than beautiful: a C call does not look much like an ordinary function call. For example, a call to <code>strlen</code> looks like this:</p> <pre><code class=language-julia >ccall&#40;:strlen, Csize_t, &#40;Cstring,&#41;, &quot;hello&quot;&#41;</code></pre>
<p>For 1.5, Aaron Christianson <a href="https://github.com/JuliaLang/julia/pull/32748">implemented</a> a macro providing nicer syntax:</p>
<pre><code class=language-julia >@ccall strlen&#40;&quot;hello&quot;::Cstring&#41;::Csize_t</code></pre>
<p>Ah — now it looks like a call to <code>strlen</code>, with types specified using natural Julian syntax.</p>
<h2 id=faster_random_numbers ><a href="#faster_random_numbers">Faster random numbers</a></h2>
<p>Julia excels at simulations, so random numbers are important to a lot of users of the language. For this release <a href="https://github.com/rfourquet">Rafael Fourquet</a>, one of the primary architects of the <code>Random</code> standard library and a prolific contributor in general, implemented some impressive algorithmic improvements for some popular cases. The first is a major improvement when generating normally-distributed double-precision floats. Calling <code>randn&#40;1000&#41;</code> is nearly twice as fast in Julia 1.5 compared with Julia 1.4. Generating random booleans also got <strong>much</strong> faster: <code>rand&#40;Bool, 1000&#41;</code> is nearly 6x faster. Finally, sampling from discrete collections has also gotten faster: <code>rand&#40;1:100, 1000&#41;</code> got 25&#37; faster.</p>
<h2 id=automated_rr-based_bug_reports ><a href="#automated_rr-based_bug_reports">Automated rr-based bug reports</a></h2>
<p>There is a new command-line option <code>--bug-report&#61;rr</code> which makes it trivially easy to record and upload <a href="https://rr-project.org/">rr</a> traces to aid in fixing bugs. This feature is described in detail in <a href="https://julialang.org/blog/2020/05/rr">a separate blog post</a>.</p>
<h2 id=pkg_protocol_now_the_default ><a href="#pkg_protocol_now_the_default">Pkg Protocol now the default</a></h2>
<p>Julia ships with a built-in package manager called <code>Pkg</code>. In the past, <code>Pkg</code> has downloaded packages directly from GitHub, GitLab, BitBucket, or wherever else they happen to be hosted. While this was a great way to bootstrap a package ecosystem, it has a number of disadvantages:</p>
<ul>
<li><p><em>Vanishing resources:</em> if the repo for a package goes away because the maintainer deletes it, makes it private, or its hosting service goes down, then nobody can install that package anymore. We want to insulate Julia users from getting &quot;<a href="https://en.wikipedia.org/wiki/Npm_&#40;software&#41;#Notable_breakages">left-padded</a>&quot;.</p>

<li><p><em>Lack of insight:</em> the Julia project has no idea what packages are installed a lot or a little. GitHub et al. have this information but doesn&#39;t share it with us. It would be really beneficial to the community to know what packages get used the most.</p>

<li><p><em>Coupling with Git/GitHub:</em> if you&#39;re installing packages from git hosting services, that ties the package manager to that hosting service&#39;s API and/or the git protocol. There&#39;s nothing inherently requiring Julia packages to be developed with git or served by git hosting services.</p>

<li><p><em>Firewall problems:</em> A lot of organizations with firewalls block git and/or ssh. It&#39;s not uncommon to block access to code hosting services since IT may need control over what software people use. Having a single server as the sole point-of-contact for installing Julia packages and using a standard protocol like HTTPS would alleviate firewall problems considerably. Even better if it was trivial to set up a caching proxy server inside the firewall.</p>

<li><p><em>Performance:</em> while downloading packages from GitHub may work great in North America, it&#39;s not so fast in the rest of the world. We&#39;ve heard of Pkg operations taking tens of minutes for users in China and Australia. We want Julia users <em>everywhere</em> to have a great experience installing packages.</p>

</ul>
<p>A new way of getting packages was introduced in Julia 1.4, known as &quot;<a href="https://github.com/JuliaLang/Pkg.jl/issues/1377">the Pkg protocol</a>&quot;, which solves all of these issues. Instead of downloading packages from wherever they happen to be hosted, the Pkg client connects to a &quot;Pkg server&quot; using a simple HTTPS protocol to download new versions of package registries, package tarballs and artifacts—everything that&#39;s needed to install and use packages. This protocol was introduced in 1.4 but not used by default: we wanted to have time to test it out, make sure it was working well, and build out the required server infrastructure. In 1.5, we&#39;ve flipped the switch, making the Pkg protocol the default way that Julia gets packages. Now by default everything is downloaded from <a href="https://pkg.julialang.org">https://pkg.julialang.org</a> &#40;it&#39;s not a website, as the very basic landing page tells you&#41;, which is served by a dozen pkg servers around the world, ensuring that everyone everywhere has a great experience installing and updating Julia packages.</p>
<h2 id=conclusion ><a href="#conclusion">Conclusion</a></h2>
<p>Please enjoy the release, and as always <a href="https://github.com/JuliaLang/julia/issues">let us know</a> if you encounter any problems or have any suggestions. We hope to be back in about four months to report on even more progress in version 1.6&#33;</p>
</div><br><br>


    
    
        <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    

    <footer class="container-fluid footer-copy">
  <div class=container >
    <div class="row footrow">
      <ul>
        <li><a href="/project">About</a>
        <li><a href="/about/help">Get Help</a>
        <li><a href="/blog/2019/02/julia-entities/">Governance</a>
        <li><a href="/research/#publications">Publications</a>
        <li><a href="/research/#sponsors">Sponsors</a>
      </ul>
      <ul>
        <li><a href="/downloads/">Downloads</a>
        <li><a href="/downloads/">All Releases</a>
        <li><a href="https://github.com/JuliaLang/julia">Source Code</a>
        <li><a href="/downloads/#current_stable_release">Current Stable Release</a>
        <li><a href="/downloads/#long_term_support_release">Longterm Support Release</a>
        <li><a href="https://status.julialang.org/">PkgServer Status</a>
      </ul>
      <ul>
        <li><a href="https://docs.julialang.org/en/v1/">Documentation</a>
        <li><a href="https://juliaacademy.com">JuliaAcademy</a>
        <li><a href="https://www.youtube.com/user/JuliaLanguage">YouTube</a>
        <li><a href="/learning/getting-started/">Getting Started</a>
        <li><a href="https://docs.julialang.org/en/v1/manual/faq/">FAQ</a>
        <li><a href="/learning/books">Books</a>
      </ul>
      <ul>
        <li><a href="/community/">Community</a>
        <li><a href="/community/standards/">Code of Conduct</a>
        <li><a href="/diversity/">Diversity</a>
        <li><a href="https://juliacon.org">JuliaCon</a>
        <li><a href="/community/#julia_user_and_developer_survey">User/Developer Survey</a>
        <li><a href="/shop/">Shop Merchandise</a>
      </ul>
      <ul>
        <li><a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">Contributing</a>
        <li><a href="https://github.com/JuliaLang/julia/issues">Issue Tracker</a>
        <li><a href="https://github.com/JuliaLang/julia/security/policy">Report a Security Issue</a>
        <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22help+wanted%22">Help Wanted Issues</a>
        <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22good+first+issue%22+">Good First Issue</a>
        <li><a href="https://docs.julialang.org/en/v1/devdocs/reflection/">Dev Docs</a>
      </ul>
    </div>
    <div id=footer-bottom  class=row >
      <div class="col-md-10 py-2">
        <p>Built with <a href="https://franklinjl.org">Franklin.jl</a> and the <a href="https://julialang.org">Julia Programming Language</a>. We thank <a href="https://www.fastly.com">Fastly</a> for their generous infrastructure support.</p>
        <p>©2020 JuliaLang.org <a href="https://github.com/JuliaLang/www.julialang.org/graphs/contributors">contributors</a>. The content on this website is made available under the <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT license</a>.
      </div>
      <div class="col-md-2 py-2">
        <span class=float-sm-right >
          <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a>
        </span>
      </div>
    </div>
  </div>
</footer>

<script src="/libs/jquery/jquery.min.js"></script>
<script src="/libs/bootstrap/bootstrap.min.js"></script>