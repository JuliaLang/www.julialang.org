---
layout: post
title: Declare primitive type in Julia
author: 鄭景文(Peter Cheng), 杜岳華
---

Julia provide some APIs for you to declare your own primitive types in Julia. However, when you open [the official docs about primitive type](https://docs.julialang.org/en/v1/manual/types/#Primitive-Types-1), you still don't know how to make your new primitive types work in your code. Therefore, here is a simple tutorial that tell you how to do so.


## Introduction

If you want define a primitve type, first, you have to declare it with the name and the number of bits it take with the `primitive type` keyword. 

    primitive type «name» «bits» end
    primitive type «name» <: «supertype» «bits» end

Currently, Julia only support sizes that are multiples of 8 bits. So like the `Bool` only take 1 bit, you still need to declare it as 8 bits. For example:

```julia
    primitive type Bool <: Integer 8 end
```

Up to here, we have almost everything from the docs. Next, we are going to show how 
to use our own primitive type with a simple example.


## The problem

After declaring our new primitive type, that's say we do the following:

```julia
    primitive type A 72 end
```

But soon you will find that you don't know how to create a instance of `A` because Julia don't have a default constructor for a new primitive type. And if you think further, you will notice that there seems to be no methods for you to manipulate those instances. You can't even do bitwise addition becuase `+` donsn't work on our new primitive type.

Then what can we do? Well, Julia do have functions for you to do those stuff, but most of those function are functions that generated by Julia's C++ source code or from the LLVM. So, before we started, we will take a first look at those functions lying under `Core.Intrinsics`.


## Core.Intrinsics

As we mentioned above, most of the function we need are lying under `Core.Intrinsics`. We will introduce some function we need. If you are familiar with LLVM Intrinsics, you will feel more at ease with these functions. (we will not include the floating-point part) 

1.  Type construction
    
    1.  `Core.Intrinsics.bitcase(type, value)`
    
        `bitcase` told the LLVM to make a new same sized value of a primitive type instance `value`         and mark it as type `type`. The type of `value` must have the same bitsize as `type`.
    
    2.  `Core.Intrinsics.trunc_int(type, value)`
    
        `trunc_int` will truncate `value` to the bitsize of `type` and mark it as type `type`. The bitsize of `value` shoud be larger than `type`.
    
    3.  `Core.Intrinsics.sext_int(type, value)`
    
        `sext_int` do the sign extension on `value` and mark it as type `type`.        The bitsize of `value` shoud be smaller than `type`.
    
    4.  `Core.Intrinsics.zext_int(type, value)`
    
        `zext_int` do the zero extension on `value` and mark it as type `type`.
    The bitsize of `value` shoud be smaller than `type`.

2.  Arithmetic operation
    1.  `Core.Intrinsics.add_int(value1, value2)`
    
        compute `value1 + value2`, as two integer addition.
    
    2.  `Core.Intrinsics.sub_int(value1, value2)`
    
        compute `value1 - value2`, as two integer subtraction.
    
    3.  `Core.Intrinsics.mul_int(value1, value2)`
    
        compute `value1 * value2`, as two integer multiplication.
    
see [Core.Intrinsics Reference](#reference) for more functions. 

Now we have the basic function we need, we will start to define our own methds.


## Define methods

All the basic methods of our new primitve type should use those functions. For defining our own constructor, we need to construct from some built-in primitive 
type. 

For example: 

```julia
import Base: +
primitive type A 72 end
```

Here is the constructor for `A`. extend a `Int64` to 72 bit with 0 and mark as type `A`.

```julia
A(x::Int64) = Core.Intrinsics.zext_int(A, x)
```

We can also accept and truncate a `Int128` to 72 bit and mark as type `A`.

```julia
A(x::Int128) = Core.Intrinsics.trunc_int(A, x)
```

`Base.+` is overloaded for defining addition on type `A`.

```julia
+(x::A, y::A) = Core.Intrinsics.add_int(x, y)
```

Consequently, the usage of primitive type `A` could be looked like this:

```julia
a1 = A(3) #create instance of A
a2 = A(12345678901234567890)

a1 + a2 # add the value of a1 and a2
```


## Q&A

Q. What's the benefit of using a custom type? Why not just define a wrapper type of type alias of a built-in primitive type?
A. 
First, if you want to dispatch on the type, than type alias might not work since it is actually the same type as the origin. 

Second, a wrapper type will cause some performance drop owing to the unwrapping process and the compiler might not be able to optimise the code. compare the result of `@code_llvm a1 + a2` on the above example and a wrapper type.

Last but not the least, You can define a custom bitsize for your primitive type and allow LLVM to do the magic.

Q. Where can I find more information?
A. you can take a look at the [LLVM reference](https://llvm.org/docs/LangRef.html) for the LLVM Intrinsics and the [Julia c++ source code for Intrinsics](https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/src/intrinsics.cpp#L853-L1241) and [header file](https://github.com/JuliaLang/julia/blob/v1.1.0/src/intrinsics.h) for function arguments, more detail at the [codegen](https://github.com/JuliaLang/julia/blob/v1.1.0/src/codegen.cpp) and [ccall](https://github.com/JuliaLang/julia/blob/v1.1.0/src/ccall.cpp), and Julia code example in [Julia's test](https://github.com/JuliaLang/julia/blob/v1.1.0/test/intrinsics.jl) and the [defination of built-in primitive type](https://github.com/JuliaLang/julia/blob/v1.1.0/base/boot.jl).


## Bitboard example

[bitboard](https://en.wikipedia.org/wiki/Bitboard) is a way of store and compute board game state in binary expression, for exampe we want to store a 4x4 board for a [2048 game](https://en.wikipedia.org/wiki/2048_(video_game)) we can do like this:

```julia
using Core.Intrinsics
using Base.Printf: @printf
import Base: show

abstract type AbstractBoard end
primitive type BitBoard64 <: AbstractBoard 64 end
primitive type BitBoard128 <: AbstractBoard 128 end

const BitBoard = BitBoard64

function Base.show(io::IO, t::AbstractBoard)
    println(io,"+------------------------+")
    for i in 0:3
        @printf "|%6d%6d%6d%6d|\n" (t(i,0), t(i,1), t(i,2), t(i,3))...
    end
    println(io,"+------------------------+")
end

BitBoard64() = bitcast(BitBoard64, 0)
BitBoard64(x::Int) = bitcast(BitBoard64, x)
BitBoard64(x::UInt) = bitcast(BitBoard64, x)

BitBoard128() = zext_int(BitBoard128, 0)
BitBoard128(x::Int) = zext_int(BitBoard128, x)
BitBoard128(x::UInt) = zext_int(BitBoard128, x)
BitBoard128(x::UInt128) = bitcast(BitBoard128, x)
BitBoard128(x::Int128) = bitcast(BitBoard128, x)

(b::BitBoard64)(i::Int) = bitcast(Int, lshr_int(b, 4 * (15 - i))) & Int(0xf)
(b::BitBoard64)(i::Int, j::Int) = b(4i + j)

(b::BitBoard128)(i::Int) = trunc_int(Int, lshr_int(b, 8 * (15 - i))) & Int(0xff)
(b::BitBoard128)(i::Int, j::Int) = b(4i + j)

function Base.transpose(x::BitBoard64)
    t = and_int(xor_int(x, lshr_int(x, 12)), BitBoard64(0x0000f0f00000f0f0))
    x = xor_int(x, xor_int(t, shl_int(t, 12)))
    t = and_int(xor_int(x, lshr_int(x, 24)), BitBoard64(0x00000000ff00ff00))
    x = xor_int(x, xor_int(t, shl_int(t, 24)))
    x
end

function reflect_vertical(x::BitBoard64)
    t = and_int(xor_int(x, lshr_int(x, 32)), BitBoard64(0x00000000ffffffff))
    x = xor_int(x, xor_int(t, shl_int(t, 32)))
    t = and_int(xor_int(x, lshr_int(x, 16)), BitBoard64(0x0000ffff0000ffff))
    x = xor_int(x, xor_int(t, shl_int(t, 16)))
    x
end

function reflect_horizontal(x::BitBoard64)
    t = and_int(xor_int(x, lshr_int(x, 8)), BitBoard64(0x00ff00ff00ff00ff))
    x = xor_int(x, xor_int(t, shl_int(t, 8)))
    t = and_int(xor_int(x, lshr_int(x, 4)), BitBoard64(0x0f0f0f0f0f0f0f0f))
    x = xor_int(x, xor_int(t, shl_int(t, 4)))
    x
end

function Base.transpose(x::BitBoard128)
    t = and_int(xor_int(x, lshr_int(x, 24)), BitBoard128(0x00000000ff00ff0000000000ff00ff00))
    x = xor_int(x, xor_int(t, shl_int(t, 24)))
    t = and_int(xor_int(x, lshr_int(x, 48)), BitBoard128(0x0000000000000000ffff0000ffff0000))
    x = xor_int(x, xor_int(t, shl_int(t, 48)))
    x
end


function reflect_vertical(x::BitBoard128)
    t = and_int(xor_int(x, lshr_int(x, 64)), BitBoard128(0x0000000000000000ffffffffffffffff))
    x = xor_int(x, xor_int(t, shl_int(t, 64)))
    t = and_int(xor_int(x, lshr_int(x, 32)), BitBoard128(0x00000000ffffffff00000000ffffffff))
    x = xor_int(x, xor_int(t, shl_int(t, 32)))
    x
end

function reflect_horizontal(x::BitBoard128)
    t = and_int(xor_int(x, lshr_int(x, 16)), BitBoard128(0x0000ffff0000ffff0000ffff0000ffff))
    x = xor_int(x, xor_int(t, shl_int(t, 16)))
    t = and_int(xor_int(x, lshr_int(x, 8)), BitBoard128(0x00ff00ff00ff00ff00ff00ff00ff00ff))
    x = xor_int(x, xor_int(t, shl_int(t, 8)))
    x
end

function rotate_right(b::AbstractBoard)
    b = transpose(b)
    b = reflect_horizontal(b)
    b
end

function rotate_left(b::AbstractBoard)
    b = transpose(b)
    b = reflect_vertical(b)
    b
end

GetRow(t::BitBoard128, r::Int)::UInt32 = and_int(trunc_int(UInt32, lshr_int(t, 32 * (3 - r))), 0xffffffff)
GetRow(t::BitBoard64, r::Int)::UInt16 = and_int(trunc_int(UInt16, lshr_int(t, 16 * (3 - r))), 0xffff)

function empty(b::AbstractBoard)::Vector{Int}
    a = Vector{Int}()
    for i in 0:15
        if b(i) == 0
            push!(a, i)
        end
    end
    return a
end
```


<a id="reference"></a>

## Core.Intrinsics Reference

reference for some basic function under the `Core.Intrinsics`.
1.  Type construction
    
    1.  `Core.Intrinsics.bitcase(type, value)`
    
        `bitcase` told the LLVM to make a new same sized value of a primitive type instance `value`         and mark it as type `type`. The type of `value` must have the same bitsize as `type`.
    
    2.  `Core.Intrinsics.trunc_int(type, value)`
    
        `trunc_int` will truncate `value` to the bitsize of `type` and mark it as type `type`.        The bitsize of `value` shoud be larger than `type`.
    
    3.  `Core.Intrinsics.sext_int(type, value)`
    
        `sext_int` do the sign extension on `value` and mark it as type `type`.        The bitsize of `value` shoud be smaller than `type`.
    
    4.  `Core.Intrinsics.zext_int(type, value)`
    
        `zext_int` do the zero extension on `value` and mark it as type `type`.
    The bitsize of `value` shoud be smaller than `type`.

2.  Arithmetic operation
    1.  `Core.Intrinsics.neg_int(value)`
    
        the negative value of `value`.
    
    2.  `Core.Intrinsics.add_int(value1, value2)`
    
        compute `value1 + value2`.
    
    3.  `Core.Intrinsics.sub_int(value1, value2)`
    
        compute `value1 - value2`.
    
    4.  `Core.Intrinsics.mul_int(value1, value2)`
    
        compute `value1 * value2`.
    
    5.  `Core.Intrinsics.sdiv_int(value1, value2)`
    
        compute the signed integer quotient.
    
    6.  `Core.Intrinsics.udiv_int(value1, value2)`
    
        compute the unsigned integer quotient.
    
    7.  `Core.Intrinsics.srem_int(value1, value2)`
    
        compute the remainder from the signed division.
    
    8.  `Core.Intrinsics.urem_int(value1, value2)`
    
        compute the remainder from the unsigned division.
    
    9.  `Core.Intrinsics.checked_*_int(value1, value2)`
    
        compute some operation with overflow check. return a tuple of a value and a bool that indicate the result has overflow or not.

3.  Logical operation
    1.  `Core.Intrinsics.bswap_int(value)`
    
        swap the high byte and low byte of `value`.
    
    2.  `Core.Intrinsics.not_int(value)`
    
        the binary not operation.
    
    3.  `Core.Intrinsics.eq_int(value1, value2)`
    
        compute `value1 == value2`.
    
    4.  `Core.Intrinsics.ne_int(value1, value2)`
    
        compute `value1 != value2`.
    
    5.  `Core.Intrinsics.slt_int(value1, value2)`
    
        compute sign less than.
    
    6.  `Core.Intrinsics.ult_int(value1, value2)`
    
        compute unsign less than.
    
    7.  `Core.Intrinsics.sle_int(value1, value2)`
    
        compute sign less and equal.
    
    8.  `Core.Intrinsics.ule_int(value1, value2)`
    
        compute unsign less and equal.
    
    9.  `Core.Intrinsics.and_int(value1, value2)`
    
        compute binary and operation.
    
    10. `Core.Intrinsics.or_int(value1, value2)`
    
        compute binary or operation.
    
    11. `Core.Intrinsics.xor_int(value1, value2)`
    
        compute binary xor operation.
    
    12. `Core.Intrinsics.shl_int(value)`
    
        compute binary shift left.
    
    13. `Core.Intrinsics.lshr_int(value)`
    
        compute logical shift right.
    
    14. `Core.Intrinsics.ashr_int(value)`
    
        compute arithmetic shift right.
    
    15. `Core.Intrinsics.ctpop_int(value)`
    
        count the 1's in `value`.
    
    16. `Core.Intrinsics.ctlz_int(value)`
    
        count the leading 0's in `value`.
    
    17. `Core.Intrinsics.cttz_int(value)`
    
        count the trailing 0's in `value`.
    
    18. `Core.Intrinsics.flipsign_int(value1, value2)`
    
        compute `value2 >= 0 ? value1 : -value1`.

