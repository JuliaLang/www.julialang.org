@def title = "This Month in Julia World (December) 2025)"
@def authors = "Stefan Krastanov"
@def published = "1 January 2026"
@def rss_pubdate = Date(2026, 1, 1)
@def rss = """Community Newsletter for December 2025"""

A monthly newsletter, mostly on julia internals, digestible for casual observers. A biased, incomplete, editorialized list of what a clique of us found interesting this month, with contributions from the community.

If you want to receive the newsletter as an email, subscribe to the [Community--Newsletter category on Discourse](https://discourse.julialang.org/c/community/news/66).

For recent news on Julia and interesting conversations with community members, check out the [JuliaDispatch](https://juliadispatch.fm/) podcast (on many platforms, including [youtube](https://www.youtube.com/@JuliaDispatch/) and [spotify](https://open.spotify.com/show/6Y1zWtFhjqPLsFQWRvZmws)). Highlights from the newsletter get discussed (with more context) during some episodes.

Current status: Julia release is 1.12.4, Julia LTS is 1.10.10. The feature freeze for 1.13 has passed and we are already at 1.13-alpha2. The dev branch is at 1.14-dev

"Internals" Fora and Core Repos (Slack/Zulip/Discourse/Github):
- [Revise.jl 3.13 has been released](https://discourse.julialang.org/t/ann-revise-jl-v3-13-struct-revision-support/134818), finally allowing automatic struct- and constant redefinition. This has been one of the most requested features for Revise, as it eliminates the need to restart Julia when changing type definitions during interactive development. It follows up on recent work (discussed in previous newsletters) that made redefinition of structs possible (by tracking and invalidating them similarly to how method invalidation happens). Now Revise.jl makes sure that the redefinition happens on the fly in the background (without requiring the user to manually trigger a re-evaluation), which is particularly useful if you are modifying an already loaded library.
- Kristoffer Carlsson has [created a script to find Core.Box](https://github.com/JuliaLang/julia/pull/60478) instances, and made a series of PRs to fix the [inference issues caused by such instances](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured) in Base and stdlibs [[1](https://github.com/JuliaLang/julia/pull/60490), [2](https://github.com/JuliaLang/julia/pull/60514), [3](https://github.com/JuliaLang/julia/pull/60515), [4](https://github.com/JuliaLang/Pkg.jl/pull/4582), [5](https://github.com/JuliaLang/StyledStrings.jl/pull/130), [6](https://github.com/JuliaLang/Downloads.jl/pull/285), [7](https://github.com/JuliaIO/Tar.jl/pull/189), [8](https://github.com/JuliaLang/julia/pull/60547)]. You [can also use this script](https://github.com/JuliaLang/julia/issues/60479) to improve your own packages. Core.Box-related issues happen when Julia wraps inside a function (a closure) a reference to an object that might be modified outside of the function (e.g. a global object). Thus, the function can not be compiled to inferred efficient machine code, because the type of the object can change at any time.
- A [prototype was PR'd to Base](https://github.com/JuliaLang/julia/pull/60344) which allows users to give early feedback to [a proposal for `match` statements in Julia](https://gist.github.com/Keno/e08874a423e0f1df4d11a798c7ed147c). And a new syntax for [declared exceptions](https://gist.github.com/Keno/7d1fb27a003afba6de50686ccfbb6610). Declared exceptions have been discussed previously as [chain-of-custody error handling](https://github.com/JuliaLang/julia/issues/7026). Both match statements and declared exceptions are highly experimental, and it's not certain in what final form they will land in Julia, if ever. Match statements would provide a more ergonomic way to handle pattern matching compared to nested if-elseif chains, while declared exceptions aim to make error handling more explicit and trackable through the call chain. If you like match statements, check out Moshi.jl.
- Julia now has [asymmetric memory fences](https://github.com/JuliaLang/julia/pull/60311), which split a [full memory fence](https://docs.julialang.org/en/v1/base/multi-threading/#Base.Threads.atomic_fence) into a cheap compiler-only fence (`Threads.atomic_fence_light`) and a rare but expensive global fence (`Threads.atomic_fence_heavy`) that enforces hardware ordering across all CPUs. Using the light fence instead of a full fence may speed up hot code in multithreaded scenarios, where applicable. The asymmetric design allows most threads to pay only a compiler-level cost while occasional heavy operations ensure proper memory visibility across all processors.
- Work continues on [an architecture for robust cancellation](https://github.com/JuliaLang/julia/pull/60281) in Julia. The proposal introduces explicit cancellation tokens and better scheduler integration, aiming to make Ctrl-C more reliable and give library authors a standard way to cancel long-running tasks without corrupting internal state. Unlike interpreted languages like Python/Ruby that have implicit safe points for interruption, compiled languages like Julia need buy-in from library developers to mark locations where cancellation can be safely handled.
- Keno is prototyping syntax for [labeled break syntax](https://github.com/JuliaLang/julia/pull/60481), i.e. breaking from a named loop. This improves ergonomics with complex control flow out of nested loops. The [PR also proposes `for-then` and `while-then` constructs](https://github.com/JuliaLang/julia/pull/60367) that execute code after a loop completes normally (but not when broken out of), similar to Python's `for-else`.
- A recent PR may soon bring [StringViews to Base Julia](https://github.com/JuliaLang/julia/pull/60526). StringViews provide a lightweight way to reference portions of strings without copying, similar to how array views work. This has been a feature of the external StringViews.jl package and its inclusion in Base would make it more widely available for performance-critical string processing.
- Unsigned integers in Julia are shown in hexadecimal, which frequently has been [a topic of discussion](https://github.com/JuliaLang/julia/issues/30167). [A new PR](https://github.com/JuliaLang/julia/pull/60267) optionally allows them to be shown in decimal.
- Timothy is working on a deep, but backwards compatible overhaul of StyledStrings and `AnnotatedString` [[1](https://github.com/JuliaLang/julia/pull/60527), [2](https://github.com/JuliaLang/StyledStrings.jl/pull/131)], which is intended to solve some of the pain points of StyledStrings, such as poor inference. See [the thread on Discourse](https://discourse.julialang.org/t/prospective-changes-to-annotatedstring-and-styledstrings/134847). StyledStrings enables rich text formatting in Julia's REPL and other text interfaces, but the current implementation has some performance and usability issues that this overhaul addresses.
- Julia's own CI now has a [timing tracking page](https://juliaci.github.io/julia-ci-timing/) with breakdowns by job and workers and trend analysis. There's a badge link to it at the top of the Julia README. This transparency helps identify performance regressions in the CI pipeline itself and understand where testing time is spent.
- Mutually recursive types have been [a requested feature in Julia since the early days](https://github.com/JuliaLang/julia/issues/269), and several implementations have been attempted [[1](https://github.com/JuliaLang/julia/pull/32581), [2](https://github.com/JuliaLang/julia/pull/32658)]. A [third attempt](https://github.com/JuliaLang/julia/pull/60569) is now underway. Mutually recursive types occur when two or more types reference each other, which is common in data structures like trees and graphs but has been challenging to express cleanly in Julia.
- Claire has introduced [a new compiler frontend API](https://github.com/JuliaLang/julia/pull/60529) for `include_string()`, `eval()`, and other compiler frontend functions. This work introduces a `TopLevelCodeIterator` interface and `AbstractCompilerFrontend` type, paving the way for using JuliaSyntax and JuliaLowering throughout the compilation pipeline while maintaining backwards compatibility. The abstraction allows different syntax versions to coexist cleanly and brings Julia closer to having its entire frontend implemented in pure Julia rather than flisp. Most importantly, this will provide an unbreakable chain of provenance for compiled code, leading to much better error messages referencing the human-readable code where the error originated, especially inside nasty macros or for advanced dev tools that inspect LLVM or machine code.
- Julia is getting initial support for [LLVM 21](https://github.com/JuliaLang/julia/pull/60356), keeping pace with the latest LLVM releases. Regular LLVM updates bring performance improvements and new optimization capabilities to Julia's code generation.
- A PR [improves how keyword arguments interact with positional dispatch](https://github.com/JuliaLang/julia/pull/60499). Previously, calling `f(100, y=1)` could dispatch to a different method than `f(100)` even if both methods matched the same positional signature, which was counterintuitive. This change makes keyword calls respect positional method dispatch first, then handle keywords.
- Test macros in Base.Test are becoming more consistent, with [support for `broken=`, `skip=`, and `context=` keywords](https://github.com/JuliaLang/julia/pull/60543) being added to `@test_throws`, `@test_warn`, `@test_nowarn`, `@test_logs`, and `@test_deprecated`. Previously only `@test` supported these helpful testing utilities.
- [Syntax versioning behavior in scripts and the REPL](https://github.com/JuliaLang/julia/pull/60400) is being formalized. This work defines how Julia should handle different syntax versions when code is evaluated in different contexts, important for maintaining compatibility as the language evolves.
- [A low-level compiler optimization for setjmp](https://github.com/JuliaLang/julia/pull/60320) is being explored using LLVM's `preserve_none` calling convention. This is deep compiler work that could improve exception handling performance.
- [JuliaSyntax received a performance optimization](https://github.com/JuliaLang/julia/pull/60403) by forcing specialization on a key parsing function. This particular change is fairly in the weeds, but it is very small and well-explained, so pedagogically it is a good example from which to learn about Julia compiler specialization heuristics.

Ecosystem Fora, Maintenance, and Colab Promises (Slack/Zulip/Discourse/Github):

- [SymbolicIntegration.jl](https://discourse.julialang.org/t/ann-symbolicintegration-jl-indefinite-integration-with-symbolics-jl-symbols/134777) enables symbolic integration using Symbolics.jl, implementing both the Risch algorithm and a rule-based method with over 3,000 integration rules translated from Mathematica's Rubi collection. The developer substantially improved pattern matching performance in SymbolicUtils, reducing compilation time from 14 minutes to approximately 12 seconds. This package represents a significant achievement in bringing comprehensive symbolic integration capabilities to Julia.
- [BorrowChecker.jl](https://github.com/MilesCranmer/BorrowChecker.jl/pull/34) has experimental SSA-form IR borrow checking that no longer requires annotations. Working on nightly Julia, it can detect aliasing issues at compile time, catching errors where mutable operations occur on aliased data—similar to Rust's borrow checker but adapted to Julia's dynamic nature.
- Stefan Karpinski has been working on [HyperLogLogOverRSA.jl](https://github.com/StefanKarpinski/HyperLogLogOverRSA.jl), a Julia implementation demonstrating the HyperLogLog Over RSA protocol. This combines RSA cryptography with HyperLogLog cardinality estimation to enable secure counting of distinct elements in a dataset while maintaining privacy. The protocol allows clients to generate encoded values that decode to HyperLogLog estimates, enabling useful analytics while preserving data privacy. Full technical specifications are [available on HackMD](https://hackmd.io/@HLLoverRSA).
- A helpful [article on world age for beginners](https://discourse.julialang.org/t/world-age-for-beginners-one-way-to-compile-a-dynamic-language/134402) explains Julia's world age mechanism—how Julia achieves performance despite being dynamic by allowing the compiler to make assumptions about global constants and method definitions, with the world age counter tracking when these assumptions change and code needs recompilation.
- [Flexible Julia](https://discourse.julialang.org/t/new-julia-for-jetbrains-ides-flexible-julia/134658) is a newly launched JetBrains plugin providing Julia language support across all JetBrains IDEs. It's a ground-up new implementation with code completion, syntax highlighting, runtime support with REPL access, inline documentation, and upcoming debugging capabilities. The plugin uses a tiered pricing model with discounts for open source, students, nonprofits, and startups.
- JuliaHealth won a [NumFOCUS Small Development Grant](https://numfocus.org/programs/small-development-grants). They will be using the funds for [several improvements across the JuliaHealth ecosystem](https://github.com/numfocus/small-development-grant-proposals/issues/59). JuliaHealth will also be parceling out some of the funds through limited bounties. Feel free to reach out to @TheCedarPrince with questions here or on the Julia Slack.
- [JuliaHealth is looking for reviewers](https://github.com/JuliaCon/proceedings-review/issues/193#issue-3731067441) for their JuliaCon Proceedings extended abstract paper about their emerging ecosystem.
- A [discussion has emerged](https://discourse.julialang.org/t/adopt-the-sciml-style-guide-for-julia-base-and-standard-library/134845) about potentially adopting the SciML Style Guide for Julia Base and standard library documentation. The conversation focuses on standardizing docstring formats with structured sections like Arguments, Keywords, Returns, and Throws. Community consensus appears to lean toward adoption as Julia has matured enough to benefit from standardized guidelines without being overly prescriptive.
- [Mongoose.jl v0.2](https://discourse.julialang.org/t/ann-mongoose-jl-v0-2-x-a-fast-lightweight-http-server/134699) is a lightweight HTTP server library emphasizing performance and simplicity with just one dependency. The new version adds multi-instance capability (multiple servers on different ports) and multi-threading support. Benchmarks show it outperforms HTTP.jl and Oxygen.jl by 2-4x, though it trails leading Rust frameworks. Future plans include WebSocket support.
- [DocumenterTypst.jl](https://discourse.julialang.org/t/ann-documentertypst-jl-fast-pdf-generation-for-documenter-jl-via-typst/134772) is a new backend for Documenter.jl that generates PDFs using Typst instead of LaTeX. It achieves 10x faster PDF generation than LaTeX, completing the entire Julia documentation (2000+ pages) in under 60 seconds with zero setup required. The package includes automatic PDF compression reducing file sizes by 65% or more.
- [PkgTemplatesShikiPlugin.jl](https://discourse.julialang.org/t/ann-pkgtemplatesshikiplugin-jl-add-shikistyle-syntax-highlighting-presenting-at-julialang-japan-2025-dec-13/134487) integrates Shiki syntax highlighting into new Julia packages created with PkgTemplates, providing VS Code-quality highlighting in documentation. It uses Shiki's TextMate grammars rather than regex-based highlight.js, offering superior highlighting quality with multi-line background coloring and better code structure visualization.
- [Desmos.jl](https://discourse.julialang.org/t/ann-desmos-jl/134734) bridges Julia with Desmos, the web-based graphing calculator, allowing programmatic graph generation from Julia with results displayed in VS Code, Pluto.jl, and Jupyter notebooks. The `@desmos` macro handles syntax differences between Julia and Desmos, supporting everything from basic plotting to advanced features like curve fitting and parametric equations.
- [Breakout.jl](https://discourse.julialang.org/t/ann-breakout-jl-a-simple-breakout-clone-for-fun-and-reinforcement-learning-on-internal-game-state/134872) provides a Julia-based Breakout game designed for reinforcement learning research with CommonRLInterface compatibility. It offers multiple state representations (2D minimal, 5D brickless, 89D full, or 160×210 pixel-based) and requires no Python dependencies or GPU for training on internal game state.
- A [curated list of GitHub Actions](https://discourse.julialang.org/t/a-curated-list-of-gh-actions-that-improve-the-quality-of-your-package/134466) for Julia package quality has sparked discussion, with the conversation highlighting BestieTemplate.jl as an emerging solution that can be applied to existing packages and reapplied to acquire updates. This represents a shift toward a unified, updateable approach to package quality standards.
- A developer shared [reflections on building a large Julia codebase](https://discourse.julialang.org/t/reflections-on-developer-experience-after-building-a-large-julia-codebase/134732), documenting experience rewriting an 80k-line Python simulator in Julia. While praising Julia's 100x performance improvement and excellent differential equation solvers, they noted challenges with refactoring, type parameter explosion causing long compilation times, and the benefits of stricter interfaces and optional static typing for large codebases.
- [Lit.jl](https://discourse.julialang.org/t/ann-lit-jl-a-simple-data-centric-web-app-framework-for-julia/134855) is a Streamlit-inspired web application framework that enables building interactive applications purely in Julia without requiring HTML, CSS, or JavaScript knowledge. It targets scientists, researchers, and data practitioners who want accessible application development for dashboards and exploratory analysis. Currently limited to Linux x86_64 platforms.
- [NearestNeighbors.jl celebrates its 10-year anniversary](https://discourse.julialang.org/t/nearestneighbors-jl-10-year-anniversary-recent-updates-and-developments/134518) with a summary of recent updates including periodic boundary conditions, self-queries (finding neighbor relationships within a single tree), parallel tree building (5x speedup with 10 threads), a tree traversal API compatible with AbstractTrees.jl, unit support via Unitful.jl, and numerous performance enhancements. A v1.0 release is planned.
- [CasualPlots.jl](https://discourse.julialang.org/t/ann-casualplots-jl-a-simple-gui-for-easy-plotting-with-julia/133891) provides a GUI-based plotting package targeting casual Julia users—experimental scientists and engineers—who need an accessible alternative to spreadsheet software. Users can select data from Julia variables, DataFrames, CSV, or XLSX files and create plots through a graphical interface with live preview, aiming for 60-80% of commonly expected features.
- A [self-contained juliac demonstration](https://discourse.julialang.org/t/self-contained-juliac-demonstration/134366) provides a complete tutorial for using `juliac`, Julia's command-line compilation tool, to create standalone executables. The demonstration addresses a gap in comprehensive tutorials by automating the entire process of building executables, though discussions reveal concerns about bundle size optimization.
- [SolarPosition.jl](https://discourse.julialang.org/t/ann-solarposition-jl/134263) provides a unified interface to multiple solar positioning algorithms (PSA, NOAA, Walraven, USNO, SPA), completely rewritten in pure Julia with no external dependencies. It's typically 1-2 orders of magnitude faster than Python equivalents and includes recent additions like sunrise/sunset calculations with polar day/night detection. Originally designed for solar photovoltaic engineering.

See also: [JuliaHub corporate blog](https://juliahub.com/blog), [French community newsletter](https://pnavaro.github.io/NouvellesJulia/), [community calendar](https://julialang.org/community/#events), [Turing.jl newsletter](https://github.com/TuringLang/Turing.jl/issues/2498)

You can engage in the discussion of this newsletter on [Discourse](https://discourse.julialang.org/c/community/news/66)

Disclaimer: An LLM was used to convert the initial human-curated list of interesting links into narrative bullet points. The human editor then used these first bullet points drafts to flesh them out into their current state (occasionally with only minimal changes, sometimes with significant rewriting). Please be aware of the [Julia Discourse policy on Generative AI content](https://discourse.julialang.org/t/updates-to-the-site-guidelines-especially-regarding-gen-ai/134315).