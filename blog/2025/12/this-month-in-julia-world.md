@def title = "This Month in Julia World (November 2025)"
@def authors = "Stefan Krastanov"
@def published = "1 December 2025"
@def rss_pubdate = Date(2025, 12, 1)
@def rss = """Community Newsletter for November 2025"""

A monthly newsletter, mostly on julia internals, digestible for casual observers. A biased, incomplete, editorialized list of what a clique of us found interesting this month, with contributions from the community.

If you want to receive the newsletter as an email, subscribe to the [Community--Newsletter category on Discourse](https://discourse.julialang.org/c/community/news/66).

For recent news on Julia and interesting conversations with community members, check out the [JuliaDispatch](https://juliadispatch.fm/) podcast (on many platforms, including [youtube](https://www.youtube.com/@JuliaDispatch/) and [spotify](https://open.spotify.com/show/6Y1zWtFhjqPLsFQWRvZmws)). Highlights from the newsletter get discussed (with more context) during some episodes.

Current status: Julia release is 1.12.2, Julia LTS is 1.10.10. The feature freeze for 1.13 has passed and we are already at 1.13-alpha2. The dev branch is at 1.14-dev

“Internals” Fora and Core Repos (Slack/Zulip/Discourse/Github):

* Pkg’s resolver might start *preferring* versions of dependencies that are already loaded in the current session when you `Pkg.add` them, to avoid unnecessary re-precompilation and keep the active environment and new projects in sync. This is implemented as a weighted preference, not a hard constraint, so it should not introduce new resolver failures. ([GitHub](https://github.com/JuliaLang/Pkg.jl/pull/4507))

* A proposed optional “strict mode” for Julia allows modules to opt into a more restrictive subset of the language to catch error-prone patterns in mature code (e.g. forbidding accidental global mutation, shadowing, or ambiguous constructs). The mode is configured per-module and is expected to land in 1.14. ([GitHub](https://github.com/JuliaLang/julia/pull/60180))

* A design sketch for *cancellation* in Julia proposes explicit cancellation tokens and better integration with the scheduler, with the dual goal of making Ctrl-C more reliable and giving library authors a standard way to cancel long-running tasks without corrupting internal state. Interpreted languages like Python/Ruby have it a bit easier here, as they implicitly have many safe points for interruption. Languages like C++/Julia/Rust/C# need to be a bit more careful and require buy-in from the library developer marking locations where an interrupt can be handled. Check also this [related JuliaCon talk](https://www.youtube.com/watch?v=95TgXZ8Tn1M). ([GitHub](https://github.com/JuliaLang/julia/pull/60281))

* “Local names linking” is an overhaul of how LLVM IR objects are named (when generated by Julia during compilation). Instead of relying on global unique names, Julia now generates names local to each LLVM module, leading to much more deterministic IR and many opportunities for caching. ([GitHub](https://github.com/JuliaLang/julia/pull/60031))

* The internal `Core.@__doc__` macro is becoming a documented part of the public metaprogramming API. It is used to pass docstrings to functions defined by macros. ([GitHub](https://github.com/JuliaLang/julia/pull/60059))

* `show` supports "context flags" that change the way an object is printed. These flags have been used to great effect in enabling "short" output, e.g. when printing an array and its entries. A new flag (`:hexunsigned`) is suggested to control how unsigned integers should be printed -- e.g. in base 10 or in hexadecimal. ([GitHub](https://github.com/JuliaLang/julia/pull/60267))

* A new `getproperty`-like shorthand is suggested to make symbols usable as “property accessors”: e.g. you can broadcast `:.field` over arrays of objects rather than writing small anonymous functions. Related work explores a broader “property lenses” design for composable field access. Over the last few years there have been many similar suggestions around the idea of "function currying", but they have all ended up as libraries, not as a feature of Base. ([GitHub](https://github.com/JuliaLang/julia/pull/60271))

* A long-awaited ABI for pointer-ful `Union` return types is under active development. More `Union` patterns might become stack-allocated and stop showing up as mysterious allocations in profiles. ([GitHub](https://github.com/JuliaLang/julia/pull/55045))

* Precompilation is being extended so that closures can be precompiled more effectively when their types are known at precompile time. This reduces repeated compilation of the same anonymous functions (e.g. common closures passed to `map`, `sort!`, or task spawners) at runtime. ([GitHub](https://github.com/JuliaLang/julia/pull/60259))

* User-facing messages from the precompilation diagnostics for the native-code cache have been rewritten to be clearer to avoid user confusion. ([GitHub](https://github.com/JuliaLang/julia/pull/60012))

In search of contributors and new maintainers:

* **LLM test cases for Julia (novice–moderate, no internals required):** there is an open call to contribute small Julia snippets (and expected behavior) where LLMs currently struggle, to build a better test suite for Julia-aware models. You don’t need compiler knowledge—just the ability to write idiomatic Julia and articulate what the model should do. ([Discourse](https://discourse.julialang.org/t/help-wanted-help-contribute-test-cases-to-improve-llm-performance-on-julia-code/132991/))

* **Documenter.jl version-switch UX (moderate, JavaScript/Web tooling):** Documenter 1.16 introduced a feature where the version selector keeps you on the same *page* when switching manual versions, but not yet the same anchor/section. There is an issue + PR to preserve anchors when switching versions (including the “outdated version” banner link back to “latest stable”), and help is wanted from someone comfortable with front-end JS in a static-docs setting. ([GitHub](https://github.com/JuliaDocs/Documenter.jl/issues/2799))

Ecosystem Fora, Maintenance, and Colab Promises (Slack/Zulip/Discourse/Github):

* **Dependabot gains Julia support:** a large PR against `dependabot-core` adds first-class handling for Julia projects, teaching Dependabot how to understand `Project.toml`/`Manifest.toml` and propose version bumps for Julia packages, similarly to other ecosystems. ([GitHub](https://github.com/dependabot/dependabot-core/pull/12316/files))

* The **Julia Security Working Group** has been launched as a new community working group, with a kickoff meeting and a blog post describing recent security-related efforts and future coordination across the ecosystem. ([Discourse](https://discourse.julialang.org/t/launching-the-julia-security-working-group/134116))

* A “visual log” of loading and precompilation times for many packages across Julia versions provides a time-series view of TTFX behavior—essentially, “how does startup feel today versus a year ago?”—to make regressions and improvements in package load times visible to users and compiler developers. ([Discourse](https://discourse.julialang.org/t/a-visual-log-of-loading-and-precompilation-times-for-many-packages-over-a-variety-of-julia-versions/133887/7))

* The ModelingToolkit developers are soliciting community feedback on a proposed **ModelingToolkit v11 library split and licensing** plan, where some functionality is moved into separate libraries with a copy-left license (open source but "viral" unlike MIT/BSD licenses that permit closed source derivative work). ([Discourse](https://discourse.julialang.org/t/modelingtoolkit-v11-library-split-and-licensing-community-feedback-requested/134396/19))

* Jakob Nissen wrote a blog post, *“Review: Julia trimming for Advent of Code 2025”*, reviewing Julia’s experimental *trimming* ahead-of-time compiler as used in this year’s Advent of Code, and using that as a springboard for broader commentary on Julia’s development, tooling experiments (like JET LS), and their readiness for production use. ([Discourse](https://discourse.julialang.org/t/blog-post-review-of-trimming-for-aoc-2025/134384))

* **Ark.jl** is an archetype-based ECS (entity–component system) ported from a Go library, with a type-stable, well-documented API targeting both games and large agent-based simulations. It would be of great benefit to agent-based models and particle-type simulations. Algebraic data types (Sum Types) have been an alternative approach for this type of work, discussed at length in previous issues of the newsletter. ([Discourse](https://discourse.julialang.org/t/ann-ark-jl-archetype-based-entity-component-system-ecs-for-games-and-simulations/133851))

* **World Age for beginners** is a long-form Discourse post explaining Julia’s “world age” mechanism in accessible terms: why methods defined later in a session aren’t immediately visible to already-compiled code, and how this design underpins Julia’s JIT compilation strategy while remaining mostly invisible to typical users. ([Discourse](https://discourse.julialang.org/t/world-age-for-beginners-one-way-to-compile-a-dynamic-language/134402))

* **RayCore.jl** is a new high-performance ray–triangle intersection engine with bounded-volume-hierarchy acceleration, usable on both CPU and GPU via KernelAbstractions. It’s being positioned as the future raytracing backend for Makie, but is factored out as a standalone library with tutorials from basics to advanced GPU optimization. ([Discourse](https://discourse.julialang.org/t/ann-raycore-jl-high-performance-ray-tracing-for-cpu-and-gpu/133776))

* **PlutoSlides.jl** brings Beamer-like slide authoring to Pluto notebooks, marrying Pluto’s reactive interactivity with a more conventional slideshow experience for talks—e.g. per-slide layouts while retaining live code and interactivity. ([Discourse](https://discourse.julialang.org/t/plutoslides-jl-beamer-style-presentations-for-pluto-notebooks/133655))

* **Jumbo** (formerly JuBox) is a Julia *distribution* bundling ~800 popular scientific packages (Makie, DifferentialEquations, ModelingToolkit, JuMP, etc.) precompiled on CI. It ships platform installers so newcomers and classrooms can avoid heavy precompilation on first use, while still allowing additional packages via Pkg without recompiling the bundled ones. ([Discourse](https://discourse.julialang.org/t/ann-jumbo-a-scientific-julia-distribution/133856))

* A small **Breakout-style game** implemented in pure Julia + GLMakie is shared as a single-file example, with discussion about integrating it into Makie’s official example gallery—nice as a compact reference for game-like interactive graphics. ([Discourse](https://discourse.julialang.org/t/breakout-style-game-in-julia-glmakie-wip/133777))

* **UFFFiles.jl** adds native read/write support for the Universal File Format (UFF) used in experimental/engineering data, avoiding the need to go through Python’s `pyuff` or MATLAB tooling and manually post-process `PyObject`s. ([Discourse](https://discourse.julialang.org/t/ann-ufffiles-jl/133671))

* **LibImageQuant.jl** wraps the `libimagequant`/`pngquant` library and exposes an in-memory `quantize_image(figure_or_matrix)` API so Julia code (including Makie plots) can produce much smaller PNGs via color quantization without going through disk or external commands. ([Discourse](https://discourse.julialang.org/t/ann-libimagequant-jl-smaller-pngs-via-color-quantization/134252))

* A long thread on **Helix + LanguageServer.jl + JuliaFormatter.jl** documents real-world configuration and pain points when moving from VS Code to the Helix editor: language server integration works, but auto-formatting and some LSP behaviors are still rough, and the thread collects config snippets and troubleshooting notes. ([Discourse](https://discourse.julialang.org/t/helix-languageserver-jl-juliaformatter-jl/133755))

* **SolarPosition.jl** is a new package implementing a common Julia interface to several solar position algorithms, rewritten in Julia. It supports time zone–aware computations of sun positions for given observers and time ranges, with example workflows using TimeZones and DataFrames. ([Discourse](https://discourse.julialang.org/t/ann-solarposition-jl/134263))

* A community project, **bitshogi.com**, showcases a mini-Shogi engine written in Julia using bitboards. The site exposes multiple bots (from random/greedy to a minimax bot and an LLM-backed opponent) and highlights Julia’s suitability for small game engines and bitboard-heavy logic. ([Discourse](https://discourse.julialang.org/t/shogi-in-julia-chess-like-game-bitshogi-com/134399))

* **TypstDocs.jl** proposes a workflow for writing Julia package documentation in Typst, leveraging Typst’s modern typesetting and evolving HTML backend, with a particular eye toward math-heavy packages whose authors already keep substantial notes in Typst. The post invites discussion around how such docs could integrate with existing Julia documentation tooling. ([Discourse](https://discourse.julialang.org/t/rfc-typstdocs-jl-julia-package-documentation-in-typst/134422))

* **DearDiary.jl** is a Julia-native alternative to MLflow for tracking experiments in machine learning. ([Discourse](https://discourse.julialang.org/t/deardiary-jl-a-lightweight-but-powerful-machine-learning-experiment-tracking-tool-for-julia/133666))

* The Discourse **site guidelines** have been updated, especially around gen-AI usage: the top section is now explicitly anchored in the Julia Community Standards as the hard rules, with the rest framed as guidelines to support human judgment. There is also clearer guidance about AI-generated content and expectations on how it is used. ([Discourse](https://discourse.julialang.org/t/updates-to-the-site-guidelines-especially-regarding-gen-ai/134315))

Numerical Math ecosystem:

* **FluxOptics.jl** provides differentiable scalar wave propagation for optical systems, with full AD support for gradient-based optimization. Optical components are modeled as composable, differentiable layers (inspired by Flux.jl), enabling tasks like tomography, field retrieval, and inverse design of multi-element, multi-wavelength optical systems. ([Discourse](https://discourse.julialang.org/t/ann-fluxoptics-jl-inverse-optical-design-with-automatic-differentiation/134285))

* **ChenSignatures.jl** implements *path signatures* and log-signatures—iterated integrals of paths that uniquely characterize them up to tree-like equivalence—with applications in rough path theory, time-series ML, and mathematical finance. The package focuses on efficient computation of signatures/log-signatures at various truncation levels in Julia. ([Discourse](https://discourse.julialang.org/t/ann-chensignatures-jl-path-signatures-in-julia/134361))

Mathematical Optimization ecosystem:

* The [**JuMP-dev 2025** videos](https://www.youtube.com/playlist?list=PLP8iPy9hna6RLvzHeEVCwkUkZV3aChElQ) are now online, including the “State of JuMP” talk and other sessions in the playlist, covering new features, ecosystem directions, and case studies around JuMP and related optimization tooling. 

Autodiff ecosystem:

* **DifferentiationInterface.jl** received a French national “Open Science – Free Research Software” prize in the “Promising community” category, recognizing its role as a unified interface layer over multiple AD backends and its rapid adoption (roughly a thousand Julia packages depending on it directly or indirectly). ([Ouvrir la Science](https://www.ouvrirlascience.fr/remise-des-prix-science-ouverte-du-logiciel-libre-de-recherche-edition-2025/))

Notes from other ecosystems:

* **Racket v9.0** was released. Given that Racket is **the** language for macro hackers that love creating domain specific languages, it seems like it would be of interest to the Julia crowd. ([Hacker News](https://news.ycombinator.com/item?id=46023460))

* A short Discourse post links to **Go’s experimental “Green Tea” garbage collector** in Go 1.25, which operates on pages of objects rather than individual objects and comes with an interactive visualization of the GC phases—interesting context for anyone following GC design across languages. ([Discourse](https://discourse.julialang.org/t/the-new-green-tea-garbage-collector-in-go/133612))

* LWN has an in-depth article on **Zig’s new plan for asynchronous programs**, centered on an explicit `Io` interface instead of `async/await` syntax. Asynchronous behavior is parameterized via an `Io` value rather than special language forms, which makes IO “coloring” explicit but keeps the language core simpler; the comment thread compares this with Rust, Go, Haskell, and different coroutine designs. Of interest to anyone excited about [`await` that might come to Julia](https://github.com/JuliaLang/julia/pull/58532). ([LWN.net](https://lwn.net/SubscriberLink/1046084/4c048ee008e1c70e/))

* The **“Advent of Compiler Optimisations 2025”** series (with an HN thread attached) runs a daily article on a compiler optimization throughout December, aimed at explaining real optimizations rather than toy examples—relevant inspiration for people interested in Julia’s compiler pipeline. ([Hacker News](https://news.ycombinator.com/item?id=46119500))

Events:

* [**Advent of Code 2025** is live](https://adventofcode.com/).

See also: [JuliaHub corporate blog](https://juliahub.com/blog), [French community newsletter](https://pnavaro.github.io/NouvellesJulia/), [community calendar](https://julialang.org/community/#events), [Turing.jl newsletter](https://github.com/TuringLang/Turing.jl/issues/2498)

You can engage in the discussion of this newsletter on [Discourse](https://discourse.julialang.org/c/community/news/66)

Disclaimer: An LLM was used to convert the initial human-curated list of interesting links into narrative bullet points. The human editor then used these first bullet points drafts to flesh them out into their current state, including significant rewriting. Please be aware of the [Julia Discourse policy on Generative AI content](https://discourse.julialang.org/t/updates-to-the-site-guidelines-especially-regarding-gen-ai/134315).