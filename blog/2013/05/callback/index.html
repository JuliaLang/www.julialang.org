<!doctype html>
<html lang="en">
<head>
	<!-- parts for all pages -->
	<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="author" content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al.">
<meta name="description" content="The official website for the Julia Language. Julia is a language that is fast, dynamic, easy to use, and open source. Click here to learn more.">
<meta name="robots" content="max-image-preview:large">
<meta name="twitter:site:id" content="1237720952"> <!-- @JuliaLanguage -->
<meta name="google-site-verification" content="9VDSjBtchQj6PQYIVwugTPY7pVCfLYgvkXiRHjc_Bzw" /> <!-- Google News Feed -->


	<link rel="icon" href="/assets/infra/julia.ico">

  <!-- Franklin stylesheets for generated pages -->
  
   <link rel="stylesheet" href="/libs/highlight/github.min.css">
  

	<!-- NOTE: specific stylesheets -->
<link rel="stylesheet" href="/libs/bootstrap/bootstrap.min.css">
<link rel="stylesheet" href="/css/app.css">
<link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/fonts.css">
<link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel="stylesheet">
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<script async defer src="/libs/buttons.js"></script>
<script src="/libs/clipboard.min.js"></script>
<script src="/libs/detectdark.js"></script>


<script defer data-domain="julialang.org" src="https://plausible.io/js/script.js"></script>

<!-- scripts for map rendering -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
crossorigin=""/>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
 integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
 crossorigin=""></script>

<!-- https://github.com/Leaflet/Leaflet.markercluster -->
<script src="https://cdn.jsdelivr.net/npm/leaflet.markercluster@1.4.1/dist/leaflet.markercluster-src.min.js"></script>

<script src="https://kit.fontawesome.com/f030d443fe.js" crossorigin="anonymous"></script>


   <title>Passing Julia Callback Functions to C</title>   

  
  <style>
	  .container ul li p {margin-bottom: 0;}
		.container ol li p {margin-bottom: 0;}
		.container ul ul {margin: .4em 0 .4em 0;}
		.container ul ol {margin: .4em 0 .4em 0;}
		.container ol ul {margin: .4em 0 .4em 0;}
		.container ol ol {margin: .4em 0 .4em 0;}
  </style>
  

  <!-- Specific style for blog pages (except the /blob/index) -->
  
  <style>
    .main { font-family: Georgia; }
    .main pre {
  	  margin-left: auto;
  	  margin-right: auto;
    }
    .main { width: 100%; font-size: 100%; }
    .main code { font-size: 90%; }
    .main pre code { font-size: 90%; }
    @media (min-width: 940px) {
      .main { width: 800px; }
      .container.blog-title { width: 800px;}
    }
  </style>
  

  <!-- OGP Metadata -->
	<meta property="og:title" content="Passing Julia Callback Functions to C">
<meta property="og:description" content=" Passing Julia Callback Functions to C | One of the great strengths of Julia is that it is so easy to call C... ">
<meta property="og:image" content="/assets/images/julia-open-graph.png">


</head>

<body>

<div class="container py-3 py-lg-0">
  <nav class="navbar navbar-expand-lg navbar-light bg-light" id="main-menu">
    <!-- LOGO -->
    <a class="navbar-brand" href="/">
      <img class="julialogo" src="/assets/infra/logo.svg" alt="JuliaLang Logo">
    </a>

    <button class="navbar-toggler ml-auto hidden-sm-up float-xs-left" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

      <!-- MENU: DOWNLOAD | DOCUMENTATION | BLOG ... -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mx-auto">
        <li class="nav-item   flex-md-fill text-md-center">
          <a class="nav-link" href="/downloads/">Download</a>
        </li>
        <li class="nav-item flex-md-fill text-md-center">
          <a class="nav-link" href="https://docs.julialang.org">Documentation</a>
        </li>
        <li class="nav-item   flex-md-fill text-md-center">
          <a class="nav-link" href="/learning/">Learn</a>
        </li>
        <li class="nav-item active flex-md-fill text-md-center">
          <a class="nav-link" href="/blog/">Blog</a>
        </li>
        <li class="nav-item   flex-md-fill text-md-center">
          <a class="nav-link" href="/community/">Community</a>
        </li>
        <li class="nav-item   flex-md-fill text-md-center">
          <a class="nav-link" href="/contribute/">Contribute</a>
        </li>
        <li class="nav-item   flex-md-fill text-md-center">
          <a class="nav-link" href="/jsoc/">JSoC</a>
        </li>
      </ul>
      <span class="navbar-right">
        <a class="github-button" href="https://github.com/JuliaLang/julia" data-size="large" data-show-count="true" aria-label="Star JuliaLang/julia on GitHub">Star</a>
        <a class="github-button" href="https://github.com/sponsors/julialang" data-icon="octicon-heart" data-size="large" aria-label="Sponsor @julialang on GitHub">Sponsor</a>
      </span>
    </div>

  </nav>
</div>


<br><br>


<div class="container blog-title">
  <h1>Passing Julia Callback Functions to C
    <a type="application/rss+xml" href="https://julialang.org/feed.xml">
      <i class="fa fa-rss-square rss-icon"></i>
    </a>
  </h1>
  <h3>
   <span style="font-weight: lighter;"> 10 May 2013 </span>
	|
	
	 <span style="font-weight: bold;"></span> 
  <!-- assumption that only one of the two is defined -->
   <span style="font-weight: bold;"><a href="https://math.mit.edu/~stevenj">Steven G. Johnson</a> </span> 
  </h3>
</div>



<a href="https://github.com/JuliaLang/www.julialang.org/blob/master/blog/2013/05/callback.md" title="Edit this page on GitHub" class="edit-float">
</a>


<!-- Content appended here -->
<div class="container main"><p>One of the great strengths of Julia is that it is so easy to <a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#">call C code</a> natively, with no special &quot;glue&quot; routines or overhead to marshal arguments and convert return values.  For example, if you want to call <a href="https://www.gnu.org/software/gsl/">GNU GSL</a> to compute a special function like a <a href="https://www.gnu.org/software/gsl/doc/html/specfunc.html#c.gsl_sf_debye_1">Debye integral</a>, it is as easy as:</p>
<pre><code class="julia hljs">debye_1(x) = <span class="hljs-keyword">ccall</span>((:gsl_sf_debye_1,:libgsl), <span class="hljs-built_in">Cdouble</span>, (<span class="hljs-built_in">Cdouble</span>,), x)</code></pre>
<p>at which point you can compute <code>debye_1&#40;2&#41;</code>, <code>debye_1&#40;3.7&#41;</code>, and so on.  &#40;Even easier would be to use Jiahao Chen&#39;s <a href="https://github.com/jiahao/GSL.jl">GSL package</a> for Julia, which has already created such wrappers for you.&#41;  This makes a vast array of existing C libraries accessible to you in Julia &#40;along with Fortran libraries and other languages with C-accessible calling conventions&#41;.</p>
<p>In fact, you can even go the other way around, passing Julia routines to C, so that C code is calling Julia code in the form of <em>callback</em> functions.   For example, a C library for numerical integration might expect you to pass the integrand as a <em>function</em> argument, which the library will then call to evaluate the integrand as many times as needed to estimate the integral.  Callback functions are also natural for optimization, root-finding, and many other numerical tasks, as well as in many non-numerical problems.  The purpose of this blog post is to illustrate the techniques for passing Julia functions as callbacks to C routines, which is straightforward and efficient but requires some lower-level understanding of how functions and other values are passed as arguments.</p>
<p>The code in this post requires Julia 0.2 &#40;or a recent <code>git</code> facsimile thereof&#41;; the key features needed for callback functions &#40;especially <code>unsafe_pointer_to_objref</code>&#41; are not available in Julia 0.1.</p>
<h2 id="sorting_with_qsort"><a href="#sorting_with_qsort" class="header-anchor">Sorting with <code>qsort</code></a></h2>
<p>Perhaps the most well-known example of a callback parameter is provided by the <a href="https://pubs.opengroup.org/onlinepubs/009695399/functions/qsort.html">qsort</a> function, part of the ANSI C standard library and declared in C as:</p>
<pre><code class="julia hljs">void qsort(void *base, size_t nmemb, size_t size,
           int(*compare)(<span class="hljs-keyword">const</span> void *a, <span class="hljs-keyword">const</span> void *b));</code></pre>
<p>The <code>base</code> argument is a pointer to an array of length <code>nmemb</code>, with elements of <code>size</code> bytes each. <code>compare</code> is a callback function which takes pointers to two elements <code>a</code> and <code>b</code> and returns an integer less/greater than zero if <code>a</code> should appear before/after <code>b</code> &#40;or zero if any order is permitted&#41;.  Now, suppose that we have a 1d array <code>A</code> of values in Julia that we want to sort using the <code>qsort</code> function &#40;rather than Julia&#39;s built-in <code>sort</code> function&#41;.  Before we worry about calling <code>qsort</code> and passing arguments, we need to write a comparison function that works for some arbitrary type <code>T</code>, e.g.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> mycompare{T}(a_::<span class="hljs-built_in">Ptr</span>{T}, b_::<span class="hljs-built_in">Ptr</span>{T})
    a = unsafe_load(a_)
    b = unsafe_load(b_)
    <span class="hljs-keyword">return</span> a &lt; b ? cint(-<span class="hljs-number">1</span>) : a &gt; b ? cint(+<span class="hljs-number">1</span>) : cint(<span class="hljs-number">0</span>)
<span class="hljs-keyword">end</span>
cint(n) = convert(<span class="hljs-built_in">Cint</span>, n)</code></pre>
<p>Notice that we use the built-in function <code>unsafe_load</code> to fetch the values pointed to by the arguments <code>a_</code> and <code>b_</code> &#40;which is &quot;unsafe&quot; because it will crash if these are not valid pointers, but <code>qsort</code> will always pass valid pointers&#41;.  Also, we have to be a little careful about return values: <code>qsort</code> expects a function returning a C <code>int</code>, so we must be sure to return <code>Cint</code> &#40;the corresponding type in Julia&#41; via a call to <code>convert</code>.</p>
<p>Now, how do we pass this to C?  A function pointer in C is essentially just a pointer to the memory location of the machine code implementing that function, whereas a function value <code>mycompare</code> &#40;of type <code>Function</code>&#41; in Julia is quite different.  Thanks to Julia&#39;s <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT compilation</a> approach,a Julia function may not even be <em>compiled</em> until the first time it is called, and in general the <em>same</em> Julia function may be compiled into <em>multiple</em> machine-code instantiations, which are specialized for arguments of different types &#40;e.g. different <code>T</code> in this case&#41;.  So, you can imagine that <code>mycompare</code> must internally point to a rather complicated data structure &#40;a <code>jl_function_t</code> in <code>julia.h</code>, if you are interested&#41;, which holds information about the argument types, the compiled versions &#40;if any&#41;, and so on.  In general, it must store a <a href="https://en.wikipedia.org/wiki/Closure_&#37;28computer_science&#37;29">closure</a> with information about the environment in which the function was defined; we will talk more about this below.  In any case, it is a very different object than a simple pointer to machine code for one set of argument types.  Fortunately, we can get the latter simply by calling a <a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Closure-cfunctions-1">built-in Julia function</a> called <code>cfunction</code>:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">const</span> mycompare_c = cfunction(mycompare, <span class="hljs-built_in">Cint</span>, (<span class="hljs-built_in">Ptr</span>{<span class="hljs-built_in">Cdouble</span>}, <span class="hljs-built_in">Ptr</span>{<span class="hljs-built_in">Cdouble</span>}))</code></pre>
<p>Here, we pass <code>cfunction</code> three arguments: the function <code>mycompare</code>, the return type <code>Cint</code>, and a tuple of the argument types, in this case to sort an array of <code>Cdouble</code> &#40;<code>Float64</code>&#41; elements.  Julia compiles a version of <code>mycompare</code> specialized for these argument types &#40;if it has not done so already&#41;, and returns a <code>Ptr&#123;Void&#125;</code> holding the address of the machine code, <em>exactly</em> what we need to pass to <code>qsort</code>.  We are now ready to call <code>qsort</code> on some sample data:</p>
<pre><code class="julia hljs">A = [<span class="hljs-number">1.3</span>, -<span class="hljs-number">2.7</span>, <span class="hljs-number">4.4</span>, <span class="hljs-number">3.1</span>]
<span class="hljs-keyword">ccall</span>(:qsort, Void, (<span class="hljs-built_in">Ptr</span>{<span class="hljs-built_in">Cdouble</span>}, <span class="hljs-built_in">Csize_t</span>, <span class="hljs-built_in">Csize_t</span>, <span class="hljs-built_in">Ptr</span>{Void}),
      A, length(A), sizeof(eltype(A)), mycompare_c)</code></pre>
<p>After this executes, <code>A</code> is changed to the sorted array <code>&#91; -2.7, 1.3,
3.1, 4.4&#93;</code>.  Note that Julia knows how to convert an array <code>A::Vector&#123;Cdouble&#125;</code> into a <code>Ptr&#123;Cdouble&#125;</code>, how to compute the <code>sizeof</code> a type in bytes &#40;identical to C&#39;s <code>sizeof</code> operator&#41;, and so on.  For fun, try inserting a <code>println&#40;&quot;mycompare&#40;&#36;a,&#36;b&#41;&quot;&#41;</code> line into mycompare, which will allow you to see the comparisons that <code>qsort</code> is performing &#40;and to verify that it is really calling the Julia function that you passed to it&#41;.</p>
<h2 id="the_problem_with_closures"><a href="#the_problem_with_closures" class="header-anchor">The problem with closures</a></h2>
<p>We aren&#39;t done yet, however.  If you start passing callback functions to C routines, it won&#39;t be long before you discover that <code>cfunction</code> doesn&#39;t always work.  For example, suppose we tried to declare our comparison function inline, via:</p>
<pre><code class="julia hljs">mycomp = cfunction((a_,b_) -&gt; unsafe_load(a_) &lt; unsafe_load(b_) ?
                              cint(-<span class="hljs-number">1</span>) : cint(+<span class="hljs-number">1</span>),
                   <span class="hljs-built_in">Cint</span>, (<span class="hljs-built_in">Ptr</span>{<span class="hljs-built_in">Cdouble</span>}, <span class="hljs-built_in">Ptr</span>{<span class="hljs-built_in">Cdouble</span>}))</code></pre>
<p>Julia barfs on this, printing <code>ERROR: function is not yet c-callable</code>.  In general, <code>cfunction</code> only works for &quot;top-level&quot; functions: named functions defined in the top-level &#40;global or module&#41; scope, but <em>not</em> anonymous &#40;<code>args -&gt; value</code>&#41; functions and not functions defined within other functions &#40;&quot;nested&quot; functions&#41;.  The reason for this stems from one important concept in computer science: a <a href="https://en.wikipedia.org/wiki/Closure_&#37;28computer_science&#37;29">closure</a>.</p>
<p>To understand the need for closures, and the difficulty they pose for callback functions, suppose that we wanted to provide a nicer interface for qsort, one which permitted the user to simply pass a <code>lessthan</code> function returning <code>true</code> or <code>false</code> while hiding all of the low-level business with pointers, <code>Cint</code>, and so on.  We might <em>like</em> to do something of the form:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> qsort!{T}(A::<span class="hljs-built_in">Vector</span>{T}, lessthan::<span class="hljs-built_in">Function</span>)
    <span class="hljs-keyword">function</span> mycompare(a_::<span class="hljs-built_in">Ptr</span>{T}, b_::<span class="hljs-built_in">Ptr</span>{T})
        a = unsafe_load(a_)
        b = unsafe_load(b_)
        <span class="hljs-keyword">return</span> lessthan(a, b) ? cint(-<span class="hljs-number">1</span>) : cint(+<span class="hljs-number">1</span>)
    <span class="hljs-keyword">end</span>
    mycompare_c = cfunction(mycompare, <span class="hljs-built_in">Cint</span>, (<span class="hljs-built_in">Ptr</span>{T}, <span class="hljs-built_in">Ptr</span>{T}))
    <span class="hljs-keyword">ccall</span>(:qsort, Void, (<span class="hljs-built_in">Ptr</span>{T}, <span class="hljs-built_in">Csize_t</span>, <span class="hljs-built_in">Csize_t</span>, <span class="hljs-built_in">Ptr</span>{Void}),
          A, length(A), sizeof(T), mycompare_c)
    A
<span class="hljs-keyword">end</span></code></pre>
<p>Then we could simply call <code>qsort&#33;&#40;&#91;1.3, -2.7, 4.4, 3.1&#93;, &lt;&#41;</code> to sort in ascending order using the built-in <code>&lt;</code> comparison, or any other comparison function we wanted.  Unfortunately <code>cfunction</code> will again barf when you try to call <code>qsort&#33;</code>, and it is no longer so difficult to understand why.  Notice that the nested <code>mycompare</code> function is no longer self-contained: it uses the variable <code>lessthan</code> from the surrounding scope.  This is a common pattern for nested functions and anonymous functions: often, they are parameterized by local variables in the environment where the function is defined.  Technically, the ability to have this kind of dependency is provided by <a href="https://en.wikipedia.org/wiki/Scope_&#37;28computer_science&#37;29">lexical scoping</a> in a programming language like Julia, and is typical of any language in which functions are &quot;<a href="https://en.wikipedia.org/wiki/First-class_function">first-class</a>&quot; objects.  In order to support lexical scoping, a Julia <code>Function</code> object needs to internally carry around a pointer to the variables in the enclosing environment, and this encapsulation is called a <em>closure</em>.</p>
<p>In contrast, a C function pointer is <em>not</em> a closure.  It doesn&#39;t enclose a pointer to the environment in which the function was defined, or anything else for that matter; it is just the address of a stream of instructions.  This makes it hard, in C, to write functions to transform other functions &#40;<a href="https://en.wikipedia.org/wiki/Higher-order_function">higher-order functions</a>&#41; or to parameterize functions by local variables.  This apparently leaves us with two options, neither of which is especially attractive:</p>
<ul>
<li><p>We could store <code>lessthan</code> in a global variable, and reference that from a top-level <code>mycompare</code> function.  &#40;This is the traditional solution for C programmers calling <code>qsort</code> with parameterized comparison functions.&#41; The problem with this strategy is that it is not <a href="https://en.wikipedia.org/wiki/Reentrancy_&#37;28computing&#37;29">re-entrant</a>: it prevents us from calling <code>qsort&#33;</code> recursively &#40;e.g. if the comparison function itself needs to do a sort, for some complicated datastructure&#41;, or from calling <code>qsort&#33;</code> from multiple threads &#40;when a future Julia version supports shared-memory parallelism&#41;. Still, this is better than nothing.</p>
</li>
<li><p>Every time <code>qsort&#33;</code> is called, Julia could JIT-compile a new version of <code>mycompare</code>, which hard-codes the reference to the <code>lessthan</code> argument passed on that call.  This is technically possible and has been implemented in some languages &#40;e.g. reportedly <a href="https://www.gnu.org/software/guile/manual/html_node/Dynamic-FFI.html">GNU Guile</a> and <a href="https://luajit.org/ext_ffi_semantics.html">Lua</a> do something like this&#41;.  However, this strategy comes at a price: it requires that callbacks be recompiled every time a parameter in them changes, which is not true of the global-variable strategy.  Anyway, it is not implemented yet in Julia.</p>
</li>
</ul>
<p>Fortunately, there is often a <em>third</em> option, because C programmers long ago recognized these limitations of function pointers, and devised a workaround: most modern C callback interfaces allow arbitrary data to be passed through to the callback via a &quot;pass-through&quot; &#40;or &quot;thunk&quot;&#41; pointer parameter.  As explained in the next section, we can exploit this technique in Julia to pass a &quot;true&quot; closure as a callback.</p>
<h2 id="passing_closures_via_pass-through_pointers"><a href="#passing_closures_via_pass-through_pointers" class="header-anchor">Passing closures via pass-through pointers</a></h2>
<p>The <code>qsort</code> interface is nowadays considered rather antiquated.  Years ago, it was supplemented on BSD-Unix systems, and eventually in GNU libc, by a function called <code>qsort_r</code> that solves the problem of passing parameters to the callback in a re-entrant way.  This is how the BSD &#40;e.g. MacOS&#41; <code>qsort_r</code> function <a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/qsort_r.3.html">is defined</a>:</p>
<pre><code class="julia hljs">void qsort_r(void *base, size_t nmemb, size_t size, void *thunk,
             int (*compare)(void *thunk, <span class="hljs-keyword">const</span> void *a, <span class="hljs-keyword">const</span> void *b));</code></pre>
<p>Compared to <code>qsort</code>, there is an extra <code>thunk</code> parameter, and this is <em>passed through</em> to the <code>compare</code> function as its first argument.  In this way, you can pass a pointer to <em>arbitrary</em> data through to your callback, and we can exploit this to pass a closure through for an arbitrary Julia callback.</p>
<p>All we need is a way to convert a Julia <code>Function</code> into an opaque <code>Ptr&#123;Void&#125;</code> so that we can pass it through to our callback, and then a way to convert the opaque pointer back into a <code>Function</code>.  The former is automatic if we simply declare the <code>ccall</code> argument as type <code>Any</code> &#40;which passes the argument as an opaque Julia object pointer&#41;, and the latter is accomplished by the built-in function <code>unsafe_pointer_to_objref</code>.  &#40;Technically, we could use type <code>Function</code> or an explicit call to <code>pointer_from_objref</code> instead of <code>Any</code>.&#41;  Using these, we can now define a working high-level <code>qsort&#33;</code> function that takes an arbitrary <code>lessthan</code> comparison-function argument:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> qsort!_compare{T}(lessthan_::<span class="hljs-built_in">Ptr</span>{Void}, a_::<span class="hljs-built_in">Ptr</span>{T}, b_::<span class="hljs-built_in">Ptr</span>{T})
    a = unsafe_load(a_)
    b = unsafe_load(b_)
    lessthan = unsafe_pointer_to_objref(lessthan_)::<span class="hljs-built_in">Function</span>
    <span class="hljs-keyword">return</span> lessthan(a, b) ? cint(-<span class="hljs-number">1</span>) : cint(+<span class="hljs-number">1</span>)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> qsort!{T}(A::<span class="hljs-built_in">Vector</span>{T}, lessthan::<span class="hljs-built_in">Function</span>=&lt;)
    compare_c = cfunction(qsort!_compare, <span class="hljs-built_in">Cint</span>, (<span class="hljs-built_in">Ptr</span>{Void}, <span class="hljs-built_in">Ptr</span>{T}, <span class="hljs-built_in">Ptr</span>{T}))
    <span class="hljs-keyword">ccall</span>(:qsort_r, Void, (<span class="hljs-built_in">Ptr</span>{T}, <span class="hljs-built_in">Csize_t</span>, <span class="hljs-built_in">Csize_t</span>, <span class="hljs-built_in">Any</span>, <span class="hljs-built_in">Ptr</span>{Void}),
          A, length(A), sizeof(T), lessthan, compare_c)
    <span class="hljs-keyword">return</span> A
<span class="hljs-keyword">end</span></code></pre>
<p><code>qsort&#33;_compare</code> is a top-level function, so <code>cfunction</code> has no problem with it, and it will only be compiled once per type <code>T</code> to be sorted &#40;rather than once per call to <code>qsort&#33;</code> or per <code>lessthan</code> function&#41;.  We use the explicit <code>::Function</code> assertion to tell the compiler that we will only pass <code>Function</code> pointers in <code>lessthan_</code>. Note that we gave the <code>lessthan</code> argument a default value of <code>&lt;</code> &#40;default arguments being a <a href="https://github.com/JuliaLang/julia/issues/1817">recent feature</a> added to Julia&#41;.</p>
<p>We can now do <code>qsort&#33;&#40;&#91;1.3, -2.7, 4.4, 3.1&#93;&#41;</code> and it will return the array sorted in ascending order, or <code>qsort&#33;&#40;&#91;1.3, -2.7,
4.4, 3.1&#93;, &gt;&#41;</code> to sort in descending order.</p>
<h4 id="warning_qsort_r_is_not_portable"><a href="#warning_qsort_r_is_not_portable" class="header-anchor">Warning: <code>qsort_r</code> is not portable</a></h4>
<p>The example above has one major problem that has nothing to do with Julia: the <code>qsort_r</code> function is not portable.  The above example won&#39;t work on Windows, since the Windows C library doesn&#39;t define <code>qsort_r</code> &#40;instead, it has a function called <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/qsort-s?view&#61;vs-2019">qsort_s</a>, which of course uses an argument order incompatible with <em>both</em> the BSD and GNU <code>qsort_r</code> functions&#41;.  Worse, it will crash on GNU/Linux systems, which <em>do</em> provide <code>qsort_r</code> but with an <a href="https://www.memoryhole.net/kyle/2009/11/qsort_r.html">incompatible</a> <a href="https://www.cygwin.com/ml/libc-alpha/2008-12/msg00008.html">calling convention</a>. And as a result it is difficult to use <code>qsort_r</code> in a way that does not crash either on GNU/Linux or BSD &#40;e.g. MacOS&#41; systems.  This is how glibc&#39;s <code>qsort_r</code> is defined:</p>
<pre><code class="julia hljs">void qsort_r(void *base, size_t nmemb, size_t size,
             int (*compare)(<span class="hljs-keyword">const</span> void *a, <span class="hljs-keyword">const</span> void *b, void *thunk),
              void *thunk);</code></pre>
<p>Note that the position of the <code>thunk</code> argument is moved, both in <code>qsort_r</code> itself and in the comparison function.   So, the corresponding <code>qsort&#33;</code> Julia code on GNU/Linux systems should be:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> qsort!_compare{T}(a_::<span class="hljs-built_in">Ptr</span>{T}, b_::<span class="hljs-built_in">Ptr</span>{T}, lessthan_::<span class="hljs-built_in">Ptr</span>{Void})
    a = unsafe_load(a_)
    b = unsafe_load(b_)
    lessthan = unsafe_pointer_to_objref(lessthan_)::<span class="hljs-built_in">Function</span>
    <span class="hljs-keyword">return</span> lessthan(a, b) ? cint(-<span class="hljs-number">1</span>) : cint(+<span class="hljs-number">1</span>)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> qsort!{T}(A::<span class="hljs-built_in">Vector</span>{T}, lessthan::<span class="hljs-built_in">Function</span>=&lt;)
    compare_c = cfunction(qsort!_compare, <span class="hljs-built_in">Cint</span>, (<span class="hljs-built_in">Ptr</span>{T}, <span class="hljs-built_in">Ptr</span>{T}, <span class="hljs-built_in">Ptr</span>{Void}))
    <span class="hljs-keyword">ccall</span>(:qsort_r, Void, (<span class="hljs-built_in">Ptr</span>{T}, <span class="hljs-built_in">Csize_t</span>, <span class="hljs-built_in">Csize_t</span>, <span class="hljs-built_in">Ptr</span>{Void}, <span class="hljs-built_in">Any</span>),
          A, length(A), sizeof(T), compare_c, lessthan)
    <span class="hljs-keyword">return</span> A
<span class="hljs-keyword">end</span></code></pre>
<p>If you really needed to call <code>qsort_r</code> from Julia, you could use the above definitions if <code>OS_NAME &#61;&#61; :Linux</code> and the BSD definitions otherwise, with a third version using <code>qsort_s</code> on Windows, but fortunately there is not much need as Julia comes with its own perfectly adequate <code>sort</code> and <code>sort&#33;</code> routines.</p>
<h2 id="passing_closures_in_data_structures"><a href="#passing_closures_in_data_structures" class="header-anchor">Passing closures in data structures</a></h2>
<p>As another example that is oriented more towards numerical computations, we&#39;ll examine how we might call the numerical integration routines in the <a href="https://www.gnu.org/software/gsl/">GNU Scientific Library &#40;GSL&#41;</a>.  There is already a <a href="https://github.com/jiahao/GSL.jl">GSL package</a> that handles the wrapper work below for you, but it is instructive to look at how this is implemented because GSL simulates closures in a slightly different way, with data structures.</p>
<p>Like most modern C libraries accepting callbacks, GSL uses a <code>void*</code> pass-through parameter to allow arbitrary data to be passed through to the callback routine, and we can use that to support arbitrary closures in Julia.   Unlike <code>qsort_r</code>, however, GSL wraps both the C function pointer and the pass-through pointer in a data structure called <code>gsl_function</code>:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">struct</span> {
    double (*<span class="hljs-keyword">function</span>)(double x, void *params);
    void *params;
} gsl_function;</code></pre>
<p>Using the techniques above, we can easily declare a <code>GSL_Function</code> type in Julia that mirrors this C type, and with a constructor <code>GSL_Function&#40;f::Function&#41;</code> that creates a wrapper around an arbitrary Julia function <code>f</code>:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> gsl_function_wrap(x::<span class="hljs-built_in">Cdouble</span>, params::<span class="hljs-built_in">Ptr</span>{Void})
    f = unsafe_pointer_to_objref(params)::<span class="hljs-built_in">Function</span>
    convert(<span class="hljs-built_in">Cdouble</span>, f(x))::<span class="hljs-built_in">Cdouble</span>
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">const</span> gsl_function_wrap_c = cfunction(gsl_function_wrap,
                                      <span class="hljs-built_in">Cdouble</span>, (<span class="hljs-built_in">Cdouble</span>, <span class="hljs-built_in">Ptr</span>{Void}))

type GSL_Function
    func::<span class="hljs-built_in">Ptr</span>{Void}
    params::<span class="hljs-built_in">Any</span>
    GSL_Function(f::<span class="hljs-built_in">Function</span>) = new(gsl_function_wrap_c, f)
<span class="hljs-keyword">end</span></code></pre>
<p>One subtlety with the above code is that we need to explicitly <code>convert</code> the return value of <code>f</code> to a <code>Cdouble</code> &#40;in case the caller&#39;s code returns some other numeric type for some <code>x</code>, such as an <code>Int</code>&#41;. Moreover, we need to explicitly assert &#40;<code>::Cdouble</code>&#41; that the result of the <code>convert</code> was a <code>Cdouble</code>.  As with the <code>qsort</code> example, this is because <code>cfunction</code> only works if Julia can guarantee that <code>gsl_function_wrap</code> returns the specified <code>Cdouble</code> type, and Julia cannot infer the return type of <code>convert</code> since it does not know the return type of <code>f&#40;x&#41;</code>.</p>
<p>Given the above definitions, it is a simple matter to pass this to the <a href="https://www.gnu.org/software/gsl/manual/html_node/QAG-adaptive-integration.html">GSL adaptive-integration</a> routines in a wrapper function <code>gsl_integration_qag</code>:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> gsl_integration_qag(f::<span class="hljs-built_in">Function</span>, a::<span class="hljs-built_in">Real</span>, b::<span class="hljs-built_in">Real</span>, epsrel::<span class="hljs-built_in">Real</span>=<span class="hljs-number">1e-12</span>,
                             maxintervals::<span class="hljs-built_in">Integer</span>=<span class="hljs-number">10</span>^<span class="hljs-number">7</span>)
    s = <span class="hljs-keyword">ccall</span>((:gsl_integration_workspace_alloc,:libgsl), <span class="hljs-built_in">Ptr</span>{Void}, (<span class="hljs-built_in">Csize_t</span>,),
              maxintervals)
    result = <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">Cdouble</span>,<span class="hljs-number">1</span>)
    abserr = <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">Cdouble</span>,<span class="hljs-number">1</span>)
    <span class="hljs-keyword">ccall</span>((:gsl_integration_qag,:libgsl), <span class="hljs-built_in">Cint</span>,
          (<span class="hljs-built_in">Ptr</span>{GSL_Function}, <span class="hljs-built_in">Cdouble</span>,<span class="hljs-built_in">Cdouble</span>, <span class="hljs-built_in">Cdouble</span>, <span class="hljs-built_in">Csize_t</span>, <span class="hljs-built_in">Cint</span>, <span class="hljs-built_in">Ptr</span>{Void},
           <span class="hljs-built_in">Ptr</span>{<span class="hljs-built_in">Cdouble</span>}, <span class="hljs-built_in">Ptr</span>{<span class="hljs-built_in">Cdouble</span>}),
          &amp;GSL_Function(f), a, b, epsrel, maxintervals, <span class="hljs-number">1</span>, s, result, abserr)
    <span class="hljs-keyword">ccall</span>((:gsl_integration_workspace_free,:libgsl), Void, (<span class="hljs-built_in">Ptr</span>{Void},), s)
    <span class="hljs-keyword">return</span> (result[<span class="hljs-number">1</span>], abserr[<span class="hljs-number">1</span>])
<span class="hljs-keyword">end</span></code></pre>
<p>Note that <code>&amp;GSL_Function&#40;f&#41;</code> passes a pointer to a <code>GSL_Function</code> &quot;struct&quot; containing a pointer to <code>gsl_function_wrap_c</code> and <code>f</code>, corresponding to the <code>gsl_function*</code> argument in C.  The return value is a tuple of the estimated integral and an estimated error.</p>
<p>For example, <code>gsl_integration_qag&#40;cos, 0, 1&#41;</code> returns <code>&#40;0.8414709848078965,9.34220461887732e-15&#41;</code>, which computes the correct integral <code>sin&#40;1&#41;</code> to machine precision.</p>
<h2 id="taking_out_the_trash_or_not"><a href="#taking_out_the_trash_or_not" class="header-anchor">Taking out the trash &#40;or not&#41;</a></h2>
<p>In the above examples, we pass an opaque pointer &#40;object reference&#41; to a Julia <code>Function</code> into C.  Whenever one passes pointers to Julia data into C code, one has to ensure that the Julia data is not garbage-collected until the C code is done with it, and functions are no exception to this rule. An anonymous function that is no longer referred to by any Julia variable may be garbage collected, at which point any C pointers to it become invalid.</p>
<p>This sounds scary, but in practice you don&#39;t need to worry about it very often, because Julia guarantees that <code>ccall</code> arguments won&#39;t be garbage-collected until the <code>ccall</code> exits.  So, in all of the above examples, we are safe: the <code>Function</code> only needs to live as long as the <code>ccall</code>.</p>
<p>The only danger arises when you pass a function pointer to C and the C code <em>saves the pointer</em> in some data structure which it will use in a <em>later</em> <code>ccall</code>. In that case, you are responsible for ensuring that the <code>Function</code> variable lives &#40;is referred to by some Julia variable&#41; as long as the C code might need it.</p>
<p>For example, in the GSL <a href="https://www.gnu.org/software/gsl/manual/html_node/One-dimensional-Minimization.html">one-dimensional minimization interface</a>, you don&#39;t simply pass your objective function to a minimization routine and wait until it is minimized.  Instead, you call a GSL routine to create a &quot;minimizer object&quot;, store your function pointer in this object, call routines to iterate the minimization, and then deallocate the minimizer when you are done.  The Julia function must not be garbage-collected until this process is complete.  The easiest way to ensure this is to create a Julia wrapper type around the minimizer object that stores an <em>explicit</em> reference to the Julia function, like this:</p>
<pre><code class="julia hljs">type GSL_Minimizer
    m::<span class="hljs-built_in">Ptr</span>{Void} <span class="hljs-comment"># the gsl_min_fminimizer pointer</span>
    f::<span class="hljs-built_in">Any</span>  <span class="hljs-comment"># explicit reference to objective, to prevent garbage-collection</span>
    <span class="hljs-keyword">function</span> GSL_Minimizer(t)
       m = <span class="hljs-keyword">ccall</span>((:gsl_min_fminimizer_alloc,:libgsl), <span class="hljs-built_in">Ptr</span>{Void}, (<span class="hljs-built_in">Ptr</span>{Void},), t)
       p = new(m, <span class="hljs-literal">nothing</span>)
       finalizer(p, p -&gt; <span class="hljs-keyword">ccall</span>((:gsl_min_fminimizer_free,:libgsl),
                               Void, (<span class="hljs-built_in">Ptr</span>{Void},), p.m))
       p
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre>
<p>This wraps around a <code>gsl_min_fminimizer</code> object of type <code>t</code>, with a placeholder <code>f</code> to store a reference to the objective function &#40;once it is set below&#41;, including a <code>finalizer</code> to deallocate the GSL object when the <code>GSL_Minimizer</code> is garbage-collected.  The parameter <code>t</code> is used to specify the minimization algorithm, which could default to Brent&#39;s algorithm via:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">const</span> gsl_brent = unsafe_load(cglobal((:gsl_min_fminimizer_brent,:libgsl), <span class="hljs-built_in">Ptr</span>{Void}))
GSL_Minimizer() = GSL_Minimizer(gsl_brent)</code></pre>
<p>&#40;The call to <code>cglobal</code> yields a pointer to the <code>gsl_min_fminimizer_brent</code> global variable in GSL, which we then dereference to get the <em>actual</em> pointer via <code>unsafe_load</code>.&#41;</p>
<p>Then, when we set the function to minimize &#40;the &quot;objective&quot;&#41;, we store an extra reference to it in the <code>GSL_Minimizer</code> to prevent garbage-collection for the lifetime of the <code>GSL_Minimizer</code>, again using the <code>GSL_Function</code> type defined above to wrap the callback:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> gsl_minimizer_set!(m::GSL_Minimizer, f, x0, xmin, xmax)
    <span class="hljs-keyword">ccall</span>((:gsl_min_fminimizer_set,:libgsl), <span class="hljs-built_in">Cint</span>,
          (<span class="hljs-built_in">Ptr</span>{Void}, <span class="hljs-built_in">Ptr</span>{GSL_Function}, <span class="hljs-built_in">Cdouble</span>, <span class="hljs-built_in">Cdouble</span>, <span class="hljs-built_in">Cdouble</span>),
          m.m, &amp;GSL_Function(f), x0, xmin, xmax)
    m.f = f
    m
<span class="hljs-keyword">end</span></code></pre>
<p>There are then various GSL routines to iterate the minimizer and to check the current <code>x</code>, objective value, or bounds on the minimum, which are convenient to wrap:</p>
<pre><code class="julia hljs">gsl_minimizer_iterate!(m::GSL_Minimizer) =
    <span class="hljs-keyword">ccall</span>((:gsl_min_fminimizer_iterate,:libgsl), <span class="hljs-built_in">Cint</span>, (<span class="hljs-built_in">Ptr</span>{Void},), m.m)

gsl_minimizer_x(m::GSL_Minimizer) =
    <span class="hljs-keyword">ccall</span>((:gsl_min_fminimizer_x_minimum,:libgsl), <span class="hljs-built_in">Cdouble</span>, (<span class="hljs-built_in">Ptr</span>{Void},), m.m)

gsl_minimizer_f(m::GSL_Minimizer) =
    <span class="hljs-keyword">ccall</span>((:gsl_min_fminimizer_f_minimum,:libgsl), <span class="hljs-built_in">Cdouble</span>, (<span class="hljs-built_in">Ptr</span>{Void},), m.m)

gsl_minimizer_xmin(m::GSL_Minimizer) =
    <span class="hljs-keyword">ccall</span>((:gsl_min_fminimizer_x_lower,:libgsl), <span class="hljs-built_in">Cdouble</span>, (<span class="hljs-built_in">Ptr</span>{Void},), m.m)
gsl_minimizer_xmax(m::GSL_Minimizer) =
    <span class="hljs-keyword">ccall</span>((:gsl_min_fminimizer_x_upper,:libgsl), <span class="hljs-built_in">Cdouble</span>, (<span class="hljs-built_in">Ptr</span>{Void},), m.m)</code></pre>
<p>Putting all of these together, we can minimize a simple function <code>sin&#40;x&#41;</code> in the interval &#91;-3,1&#93;, with a starting guess -1, via:</p>
<pre><code class="julia hljs">m = GSL_Minimizer()
gsl_minimizer_set!(m, sin, -<span class="hljs-number">1</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)
<span class="hljs-keyword">while</span> gsl_minimizer_xmax(m) - gsl_minimizer_xmin(m) &gt; <span class="hljs-number">1e-6</span>
    println(<span class="hljs-string">&quot;iterating at x = <span class="hljs-subst">$(gsl_minimizer_x(m)</span>)&quot;</span>)
    gsl_minimizer_iterate!(m)
<span class="hljs-keyword">end</span>
println(<span class="hljs-string">&quot;found minimum <span class="hljs-subst">$(gsl_minimizer_f(m)</span>) at x = <span class="hljs-subst">$(gsl_minimizer_x(m)</span>)&quot;</span>)</code></pre>
<p>After a few iterations, it prints <code>found minimum -1.0 at x &#61;
-1.5707963269964016</code>, which is the correct minimum &#40;&minus;&pi;/2&#41; to about 10 digits.</p>
<p>At this point, I will shamelessly plug my own <a href="https://github.com/stevengj/NLopt.jl">NLopt package</a> for Julia, which wraps around my free/open-source <a href="https://nlopt.readthedocs.io/en/latest/">NLopt</a> library to provide many more optimization algorithms than GSL, with perhaps a nicer interface.   However, the techniques used to pass callback functions to NLopt are actually quite similar to those used for GSL.</p>
<p>An even more complicated version of these techniques can be found in the <a href="https://github.com/stevengj/PyCall.jl">PyCall package</a> to call Python from Julia.  In order to pass a Julia function to Python, we again use <code>cfunction</code> on a wrapper function that handles the type conversions and so on, and pass the actual Julia closure through via a pass-through pointer.  But in that case, the pass-through pointer consists of a Python object that has been created with a new type that allows it to wrap a Julia object, and garbage-collection is deferred by storing the Julia object in a global dictionary of saved objects &#40;removing it via the Python destructor of the new type&#41;.  That is all somewhat tricky stuff and beyond the scope of this blog post; I only mention it to illustrate the fact that it is possible to implement quite complex inter-language calling behaviors purely in Julia by building on the above techniques.</p>
</div><br><br>

<!-- CONTENT ENDS HERE -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>


    

    <!-- http://tutsplus.github.io/clipboard/ -->

<script>
(function(){

	// Get the elements.
	// - the 'pre' element.
	// - the 'div' with the 'paste-content' id.

	var pre = document.getElementsByTagName('pre');

	// Add a copy button in the 'pre' element.
	// which only has the className of 'language-' or ' hljs'(if enable highlight.js pre-render).

	for (var i = 0; i < pre.length; i++) {
		var tag_name = pre[i].children[0].className
            	var isLanguage = tag_name.startsWith('language-') || tag_name.endsWith(' hljs');
		if ( isLanguage ) {
			var button           = document.createElement('button');
					button.className = 'copy-button';
					button.textContent = 'Copy';

					pre[i].appendChild(button);
		}
	};

	// Run Clipboard

	var copyCode = new Clipboard('.copy-button', {
		target: function(trigger) {
			return trigger.previousElementSibling;
    }
	});

	// On success:
	// - Change the "Copy" text to "Copied".
	// - Swap it to "Copy" in 2s.
	// - Lead user to the "contenteditable" area with Velocity scroll.

	copyCode.on('success', function(event) {
		event.clearSelection();
		event.trigger.textContent = 'Copied';
		window.setTimeout(function() {
			event.trigger.textContent = 'Copy';
		}, 2000);

	});

	// On error (Safari):
	// - Change the  "Press Ctrl+C to copy"
	// - Swap it to "Copy" in 2s.

	copyCode.on('error', function(event) {
		event.trigger.textContent = 'Press "Ctrl + C" to copy';
		window.setTimeout(function() {
			event.trigger.textContent = 'Copy';
		}, 5000);
	});

})();
</script>


    <footer class="container-fluid footer-copy">
  <div class="container">
    <div class="row footrow">
      <ul>
        <li><a href="/project">About</a></li>
        <li><a href="/about/help">Get Help</a></li>
        <li><a href="/governance/">Governance</a></li>
        <li><a href="/research/#publications">Publications</a></li>
        <li><a href="/research/#sponsors">Sponsors</a></li>
      </ul>
      <ul>
        <li><a href="/downloads/">Downloads</a></li>
        <li><a href="/downloads/">All Releases</a></li>
        <li><a href="https://github.com/JuliaLang/julia">Source Code</a></li>
        <li><a href="/downloads/#current_stable_release">Current Stable Release</a></li>
        <li><a href="/downloads/#long_term_support_release">Longterm Support Release</a></li>
      </ul>
      <ul>
        <li><a href="https://docs.julialang.org/en/v1/">Documentation</a></li>
        <li><a href="https://juliaacademy.com">JuliaAcademy</a></li>
        <li><a href="https://www.youtube.com/user/JuliaLanguage">YouTube</a></li>
        <li><a href="/learning/getting-started/">Getting Started</a></li>
        <li><a href="https://docs.julialang.org/en/v1/manual/faq/">FAQ</a></li>
        <li><a href="/learning/books">Books</a></li>
      </ul>
      <ul>
        <li><a href="/community/">Community</a></li>
        <li><a href="/community/standards/">Code of Conduct</a></li>
        <li><a href="/community/stewards/">Stewards</a></li>
        <li><a href="/diversity/">Diversity</a></li>
        <li><a href="https://juliagenderinclusive.github.io">Julia Gender Inclusive</a></li>
        <li><a href="https://juliacon.org">JuliaCon</a></li>
        <li><a href="/community/#julia_user_and_developer_survey">User/Developer Survey</a></li>
        <li><a href="/shop/">Shop Merchandise</a></li>
      </ul>
      <ul>
        <li><a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">Contributing</a></li>
        <li><a href="/contribute">Contributor's Guide</a></li>
        <li><a href="https://github.com/JuliaLang/julia/issues">Issue Tracker</a></li>
        <li><a href="https://github.com/JuliaLang/julia/security/policy">Report a Security Issue</a></li>
        <li><a href="https://github.com/search?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22help+wanted%22">Help Wanted Issues</a></li>
        <li><a href="https://github.com/search?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22good+first+issue%22">Good First Issue</a></li>
        <li><a href="https://docs.julialang.org/en/v1/devdocs/init/">Dev Docs</a></li>
      </ul>
    </div>
    <div id="footer-bottom" class="row">
      <div class="col-md-10 py-2">
        <p>Last modified: October 09, 2024. This site is powered by <a href="https://www.netlify.com">Netlify</a>, <a href="https://franklinjl.org">Franklin.jl</a>, and the <a href="https://julialang.org">Julia Programming Language</a>.</p>
        <p>We thank <a href="https://www.fastly.com">Fastly</a> for their generous infrastructure support.</p>
        <p>©2024 JuliaLang.org <a href="https://github.com/JuliaLang/www.julialang.org/graphs/contributors">contributors</a>. The content on this website is made available under the <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT license</a>.</p>
      </div>
      <div class="col-md-2 py-2">
        <span class="float-sm-right">
          <a class="github-button" href="https://github.com/sponsors/julialang" data-icon="octicon-heart" data-size="large" aria-label="Sponsor @julialang on GitHub">Sponsor</a>
        </span>
      </div>
    </div>
  </div>
</footer>

<script src="/libs/jquery/jquery.min.js"></script>
<script src="/libs/bootstrap/bootstrap.min.js"></script>
<!-- <script src="/libs/highlight/highlight.min.js"></script> -->
<!--  -->

    <script src="/libs/groups.js"></script>
    <script src="/libs/map.js"></script>
  </body>
</html>
