<!doctype html>
<html lang="en">
<head>
	<!-- parts for all pages -->
	<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="author" content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al.">
<meta name="description" content="The official website for the Julia Language. Julia is a language that is fast, dynamic, easy to use, and open source. Click here to learn more.">
<meta name="robots" content="max-image-preview:large">
<meta name="twitter:site:id" content="1237720952"> <!-- @JuliaLanguage -->
<meta name="google-site-verification" content="9VDSjBtchQj6PQYIVwugTPY7pVCfLYgvkXiRHjc_Bzw" /> <!-- Google News Feed -->


	<link rel="icon" href="/previews/PR2365/assets/infra/julia.ico">

  <!-- Franklin stylesheets for generated pages -->
  
   <link rel="stylesheet" href="/previews/PR2365/libs/highlight/github.min.css">
  

	<!-- NOTE: specific stylesheets -->
<link rel="stylesheet" href="/previews/PR2365/libs/bootstrap/bootstrap.min.css">
<link rel="stylesheet" href="/previews/PR2365/css/app.css">
<link rel="stylesheet" href="/previews/PR2365/css/franklin.css">
<link rel="stylesheet" href="/previews/PR2365/css/fonts.css">
<link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel="stylesheet">
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<script async defer src="/previews/PR2365/libs/buttons.js"></script>
<script src="/previews/PR2365/libs/clipboard.min.js"></script>
<script src="/previews/PR2365/libs/detectdark.js"></script>
<script src="/previews/PR2365/libs/animated-banner.js"></script>


<script defer data-domain="julialang.org" src="https://plausible.io/js/script.js"></script>

<!-- scripts for map rendering -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
crossorigin=""/>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
 integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
 crossorigin=""></script>

<!-- https://github.com/Leaflet/Leaflet.markercluster -->
<script src="https://cdn.jsdelivr.net/npm/leaflet.markercluster@1.4.1/dist/leaflet.markercluster-src.min.js"></script>

<script src="https://kit.fontawesome.com/f030d443fe.js" crossorigin="anonymous"></script>


   <title>Multidimensional algorithms and iteration</title>   

  
  <style>
	  .container ul li p {margin-bottom: 0;}
		.container ol li p {margin-bottom: 0;}
		.container ul ul {margin: .4em 0 .4em 0;}
		.container ul ol {margin: .4em 0 .4em 0;}
		.container ol ul {margin: .4em 0 .4em 0;}
		.container ol ol {margin: .4em 0 .4em 0;}
  </style>
  

  <!-- Specific style for blog pages (except the /blob/index) -->
  
  <style>
    .main { font-family: Georgia; }
    .main pre {
  	  margin-left: auto;
  	  margin-right: auto;
    }
    .main { width: 100%; font-size: 100%; }
    .main code { font-size: 90%; }
    .main pre code { font-size: 90%; }
    @media (min-width: 940px) {
      .main { width: 800px; }
      .container.blog-title { width: 800px;}
    }
  </style>
  

  <!-- OGP Metadata -->
	<meta property="og:title" content="Multidimensional algorithms and iteration">
<meta property="og:description" content=" Multidimensional algorithms and iteration | Julia makes it easy to write elegant and... ">
<meta property="og:image" content="/assets/images/julia-open-graph.png">


</head>

<body>

<nav class="navbar navbar-expand-lg navbar-light bg-white" id="main-menu">
  <div class="container">
      <a class="navbar-brand" href="/previews/PR2365/">
          <img src="/previews/PR2365/assets/infra/logo.svg" alt="JuliaLang Logo" class="navbarjulialogo" height="40">
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarContent" aria-controls="navbarContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarContent">
          <ul class="navbar-nav mx-auto mb-2 mb-lg-0">
              <li class="nav-item  ">
                  <a class="nav-link" href="/previews/PR2365/install/">Install</a>
              </li>
              <li class="nav-item">
                  <a class="nav-link" href="https://docs.julialang.org">Docs</a>
              </li>
              <li class="nav-item ">
                  <a class="nav-link" href="/previews/PR2365/learning/">Learn</a>
              </li>
              <li class="nav-item active">
                  <a class="nav-link" href="/previews/PR2365/blog/">Blog</a>
              </li>
              <li class="nav-item ">
                  <a class="nav-link" href="/previews/PR2365/community/">Community</a>
              </li>
              <li class="nav-item ">
                  <a class="nav-link" href="/previews/PR2365/contribute/">Contribute</a>
              </li>
              <li class="nav-item ">
                  <a class="nav-link" href="/previews/PR2365/jsoc/">JSoC</a>
              </li>
          </ul>
          <div class="navbar-action-buttons d-flex gap-4">
              <a class="github-button" href="https://github.com/JuliaLang/julia" data-icon="octicon-star" data-size="large" data-show-count="false" aria-label="Star JuliaLang/julia on GitHub">Star</a>
              <a class="github-button" href="https://github.com/sponsors/julialang" data-icon="octicon-heart" data-size="large" aria-label="Sponsor @julialang on GitHub">Sponsor</a>
          </div>
      </div>
  </div>
</nav>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>


<br><br>


<div class="container blog-title">
  <h1>Multidimensional algorithms and iteration
    <a type="application/rss+xml" href="https://julialang.org/feed.xml">
      <i class="fa fa-rss-square rss-icon"></i>
    </a>
  </h1>
  <h3>
   <span style="font-weight: lighter;"> 1 February 2016 </span>
	|
	
	 <span style="font-weight: bold;"></span> 
  <!-- assumption that only one of the two is defined -->
   <span style="font-weight: bold;"> <a href="http://holylab.wustl.edu">Tim Holy</a> </span> 
  </h3>
</div>



<a href="https://github.com/JuliaLang/www.julialang.org/blob/master/blog/2016/02/iteration.md" title="Edit this page on GitHub" class="edit-float">
</a>


<!-- Content appended here -->
<div class="container main"><p><strong>Note: updated December 2018 for Julia 1.1</strong></p>
<p><strong>Note: updated April 2020 for clarity</strong></p>
<p>Julia makes it easy to write elegant and efficient multidimensional algorithms. The new capabilities rest on two foundations: an iterator called <code>CartesianIndices</code>, and sophisticated array indexing mechanisms.  Before I explain, let me emphasize that developing these capabilities was a collaborative effort, with the bulk of the work done by Matt Bauman &#40;@mbauman&#41;, Jutho Haegeman &#40;@Jutho&#41;, and myself &#40;@timholy&#41;.</p>
<p>These iterators are deceptively simple: just a few principles bring a world of power in writing multidimensional algorithms.  However, like many simple concepts, the implications can take a while to sink in. It&#39;s also possible to confuse these techniques with <a href="https://docs.julialang.org/en/v1/devdocs/cartesian/"><code>Base.Cartesian</code></a>, which is a completely different &#40;and more painful&#41; approach to solving the same problem.  There are still a few occasions where <code>Base.Cartesian</code> is helpful or necessary, but for many problems these new capabilities represent a vastly simplified approach.</p>
<p>Let&#39;s introduce these iterators with an extension of an example taken from the <a href="https://docs.julialang.org/en/v1/manual/arrays/#Iteration-1">manual</a>.</p>
<h1 id="eachindex_cartesianindex_and_cartesianindices"><a href="#eachindex_cartesianindex_and_cartesianindices" class="header-anchor">eachindex, CartesianIndex, and CartesianIndices</a></h1>
<p>There are two recommended &quot;default&quot; ways to iterate over the elements in an <a href="https://docs.julialang.org/en/v1.4/manual/arrays/"><code>AbstractArray</code></a>: if you don&#39;t need an index associated with each element, then you can use</p>
<pre><code class="julia hljs"><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> A    <span class="hljs-comment"># A is an AbstractArray</span>
    <span class="hljs-comment"># Code that does something with the element a</span>
<span class="hljs-keyword">end</span></code></pre>
<p>If instead you also need the index, then use</p>
<pre><code class="julia hljs"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> eachindex(A)
    <span class="hljs-comment"># Code that does something with i and/or A[i]</span>
<span class="hljs-keyword">end</span></code></pre>
<p>In some cases, the first line of this loop expands to <code>for i &#61;
1:length&#40;A&#41;</code>, and <code>i</code> is just an integer.  However, in other cases, this will expand to the equivalent of</p>
<pre><code class="julia hljs"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">CartesianIndices</span>(A)
    <span class="hljs-comment"># i is now a CartesianIndex</span>
    <span class="hljs-comment"># Code that does something with i and/or A[i]</span>
<span class="hljs-keyword">end</span></code></pre>
<p>You can see for yourself what this does with the following:</p>
<pre><code class="julia hljs">julia&gt; A = rand(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)

julia&gt; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">CartesianIndices</span>(A)
          <span class="hljs-meta">@show</span> i
       <span class="hljs-keyword">end</span>
i = <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
i = <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)
i = <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)
i = <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
i = <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)
i = <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)</code></pre>
<p>A <code>CartesianIndex&#123;N&#125;</code> represents an <code>N</code>-dimensional index. <code>CartesianIndex</code>es are based on tuples, and indeed you can access the underlying tuple with <code>Tuple&#40;i&#41;</code>.</p>
<p>A <code>CartesianIndices</code> acts like an array of <code>CartesianIndex</code> values:</p>
<pre><code class="julia hljs">julia&gt; iter = <span class="hljs-built_in">CartesianIndices</span>(A)
<span class="hljs-number">3</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">CartesianIndices</span>{<span class="hljs-number">2</span>,<span class="hljs-built_in">Tuple</span>{Base.OneTo{<span class="hljs-built_in">Int64</span>},Base.OneTo{<span class="hljs-built_in">Int64</span>}}}:
 <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
 <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)
 <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)

julia&gt; supertype(typeof(iter))
<span class="hljs-built_in">AbstractArray</span>{<span class="hljs-built_in">CartesianIndex</span>{<span class="hljs-number">2</span>},<span class="hljs-number">2</span>}</code></pre>
<p>As a consequence <code>iter&#91;2,2&#93;</code> and <code>iter&#91;5&#93;</code> both return <code>CartesianIndex&#40;2, 2&#41;</code>; indeed, the latter is the recommended way to convert from a <a href="https://docs.julialang.org/en/v1/devdocs/subarrays/#Indexing:-cartesian-vs.-linear-indexing-1">linear index</a> to a multidimensional cartesian index.</p>
<p>However, internally <code>iter</code> is just a wrapper around the <code>axes</code> range for each dimension:</p>
<pre><code class="julia hljs">julia&gt; iter.indices
(Base.OneTo(<span class="hljs-number">3</span>), Base.OneTo(<span class="hljs-number">2</span>))</code></pre>
<p>As a consequence, in many applications the creation and usage of these objects has little or no overhead.</p>
<p>You can construct these manually: for example,</p>
<pre><code class="julia hljs">julia&gt; <span class="hljs-built_in">CartesianIndices</span>((-<span class="hljs-number">7</span>:<span class="hljs-number">7</span>, <span class="hljs-number">0</span>:<span class="hljs-number">15</span>))
<span class="hljs-number">15</span>×<span class="hljs-number">16</span> <span class="hljs-built_in">CartesianIndices</span>{<span class="hljs-number">2</span>,<span class="hljs-built_in">Tuple</span>{<span class="hljs-built_in">UnitRange</span>{<span class="hljs-built_in">Int64</span>},<span class="hljs-built_in">UnitRange</span>{<span class="hljs-built_in">Int64</span>}}}:
<span class="hljs-comment"># remaining output suppressed</span></code></pre>
<p>corresponds to an iterator that will loop over <code>-7:7</code> along the first dimension and <code>0:15</code> along the second.</p>
<p>One reason that <code>eachindex</code> is recommended over <code>for i &#61; 1:length&#40;A&#41;</code> is that some <code>AbstractArray</code>s cannot be indexed efficiently with a linear index; in contrast, a much wider class of objects can be efficiently indexed with a multidimensional iterator.  &#40;SubArrays are, generally speaking, <a href="https://docs.julialang.org/en/v1/devdocs/subarrays">a prime example</a>.&#41; <code>eachindex</code> is designed to pick the most efficient iterator for the given array type.  You can even use</p>
<pre><code class="julia hljs"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> eachindex(A, B)
    ...</code></pre>
<p>to increase the likelihood that <code>i</code> will be efficient for accessing both <code>A</code> and <code>B</code>.  &#40;A second reason to use <code>eachindex</code> is that some arrays don&#39;t starting indexing at 1, but that&#39;s a topic for a separate <a href="/previews/PR2365/blog/2017/04/offset-arrays">blog post</a>.&#41;</p>
<p>As we&#39;ll see below, these iterators have another purpose: independent of whether the underlying arrays have efficient linear indexing, multidimensional iteration can be a powerful ally when writing algorithms.  The rest of this blog post will focus on this latter application.</p>
<h1 id="writing_multidimensional_algorithms_with_cartesianindex_iterators"><a href="#writing_multidimensional_algorithms_with_cartesianindex_iterators" class="header-anchor">Writing multidimensional algorithms with CartesianIndex iterators</a></h1>
<h2 id="a_multidimensional_boxcar_filter"><a href="#a_multidimensional_boxcar_filter" class="header-anchor">A multidimensional boxcar filter</a></h2>
<p>Let&#39;s suppose we have a multidimensional array <code>A</code>, and we want to compute the <a href="https://en.wikipedia.org/wiki/Boxcar_averager">&quot;moving average&quot;</a> over a 3-by-3-by-... block around each element.  From any given index position, we&#39;ll want to sum over a region offset by <code>-1:1</code> along each dimension. Edge positions have to be treated specially, of course, to avoid going beyond the bounds of the array.</p>
<p>In many languages, writing a general &#40;N-dimensional&#41; implementation of this conceptually-simple algorithm is somewhat painful, but in Julia it&#39;s a piece of cake:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> boxcar3(A::<span class="hljs-built_in">AbstractArray</span>)
    out = similar(A)
    R = <span class="hljs-built_in">CartesianIndices</span>(A)
    Ifirst, Ilast = first(R), last(R)
    I1 = oneunit(Ifirst)
    <span class="hljs-keyword">for</span> I <span class="hljs-keyword">in</span> R
        n, s = <span class="hljs-number">0</span>, zero(eltype(out))
        <span class="hljs-keyword">for</span> J <span class="hljs-keyword">in</span> max(Ifirst, I-I1):min(Ilast, I+I1)
            s += A[J]
            n += <span class="hljs-number">1</span>
        <span class="hljs-keyword">end</span>
        out[I] = s/n
    <span class="hljs-keyword">end</span>
    out
<span class="hljs-keyword">end</span></code></pre>
<p>&#40;Note that this example is only for Julia versions 1.1 and higher.&#41;</p>
<p>Let&#39;s walk through this line by line:</p>
<ul>
<li><p><code>out &#61; similar&#40;A&#41;</code> allocates the output. In a &quot;real&quot; implementation, you&#39;d want to be a little more careful about the element type of the output &#40;what if the input array element type is <code>Int</code>?&#41;, but we&#39;re cutting a few corners here for simplicity.</p>
</li>
<li><p><code>R &#61; CartesianIndices&#40;A&#41;</code> creates the iterator for the array. Assuming <code>A</code> starts indexing at 1, this ranges from <code>CartesianIndex&#40;1, 1, 1, ...&#41;</code> to <code>CartesianIndex&#40;size&#40;A,1&#41;, size&#40;A,2&#41;, size&#40;A,3&#41;, ...&#41;</code>.  We don&#39;t use <code>eachindex</code>, because we can&#39;t be sure whether that will return a <code>CartesianIndices</code> iterator, and here we explicitly need one.</p>
</li>
<li><p><code>Ifirst &#61; first&#40;R&#41;</code> and <code>Ilast &#61; last&#40;R&#41;</code> return the lower &#40;<code>CartesianIndex&#40;1, 1, 1, ...&#41;</code>&#41; and upper &#40;<code>CartesianIndex&#40;size&#40;A,1&#41;, size&#40;A,2&#41;, size&#40;A,3&#41;, ...&#41;</code>&#41; bounds of the iteration range, respectively.  We&#39;ll use these to ensure that we never access out-of-bounds elements of <code>A</code>.</p>
</li>
<li><p><code>I1 &#61; oneunit&#40;Ifirst&#41;</code> creates an all-1s <code>CartesianIndex</code> with the same dimensionality as <code>Ifirst</code>. We&#39;ll use this in arithmetic operations to define a region-of-interest.</p>
</li>
<li><p><code>for I in R</code>: here we loop over each entry of <code>R</code>, corresponding to both <code>A</code> and <code>out</code>.</p>
</li>
<li><p><code>n &#61; 0</code> and <code>s &#61; zero&#40;eltype&#40;out&#41;&#41;</code> initialize the accumulators. <code>s</code> will hold the sum of neighboring values. <code>n</code> will hold the number of neighbors used; in most cases, after the loop we&#39;ll have <code>n &#61;&#61; 3^N</code>, but for edge points the number of valid neighbors will be smaller.</p>
</li>
<li><p><code>for J in max&#40;Ifirst, I-I1&#41;:min&#40;Ilast, I&#43;I1&#41;</code> is probably the most &quot;clever&quot; line in the algorithm. <code>I-I1</code> is a <code>CartesianIndex</code> that is lower by 1 along each dimension, and <code>I&#43;I1</code> is higher by 1. However, when <code>I</code> represents an edge point, either <code>I-I1</code> or <code>I&#43;I1</code> &#40;or both&#41; might be out-of-bounds. <code>max&#40;Ifirst, I-I1&#41;</code> ensures that each coordinate of <code>J</code> is 1 or larger, while <code>min&#40;Ilast, I&#43;I1&#41;</code> ensures that <code>J&#91;d&#93; &lt;&#61; size&#40;A,d&#41;</code>.</p>
<p>Putting these two together with a colon, <code>Ilower:Iupper</code>, creates a <code>CartesianIndices</code> object that serves as an iterator.</p>
</li>
<li><p>The inner loop accumulates the sum in <code>s</code> and the number of visited neighbors in <code>n</code>.</p>
</li>
<li><p>Finally, we store the average value in <code>out&#91;I&#93;</code>.</p>
</li>
</ul>
<p>Not only is this implementation simple, it is also surprisingly robust: for edge points it computes the average of whatever nearest-neighbors it has available.  It even works if <code>size&#40;A, d&#41; &lt; 3</code> for some dimension <code>d</code>; we don&#39;t need any error checking on the size of <code>A</code>.</p>
<h2 id="computing_a_reduction"><a href="#computing_a_reduction" class="header-anchor">Computing a reduction</a></h2>
<p>For a second example, consider the implementation of multidimensional <em>reductions</em>. A reduction takes an input array, and returns an array &#40;or scalar&#41; of smaller size.  A classic example would be summing along particular dimensions of an array: given a three-dimensional array, you might want to compute the sum along dimension 2, leaving dimensions 1 and 3 intact.</p>
<h3 id="the_core_algorithm"><a href="#the_core_algorithm" class="header-anchor">The core algorithm</a></h3>
<p>An efficient way to write this algorithm requires that the output array, <code>B</code>, is pre-allocated by the caller &#40;later we&#39;ll see how one might go about allocating <code>B</code> programmatically&#41;.  For example, if the input <code>A</code> is of size <code>&#40;l,m,n&#41;</code>, then when summing along just dimension 2 the output <code>B</code> would have size <code>&#40;l,1,n&#41;</code>.</p>
<p>Given this setup, the implementation is shockingly simple:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sumalongdims!(B, A)
    <span class="hljs-comment"># It&#x27;s assumed that B has size 1 along any dimension that we&#x27;re summing,</span>
    <span class="hljs-comment"># and otherwise matches A</span>
    fill!(B, <span class="hljs-number">0</span>)
    Bmax = last(<span class="hljs-built_in">CartesianIndices</span>(B))
    <span class="hljs-keyword">for</span> I <span class="hljs-keyword">in</span> <span class="hljs-built_in">CartesianIndices</span>(A)
        B[min(Bmax,I)] += A[I]
    <span class="hljs-keyword">end</span>
    B
<span class="hljs-keyword">end</span></code></pre>
<p>The key idea behind this algorithm is encapsulated in the single statement <code>B&#91;min&#40;Bmax,I&#41;&#93;</code>.  For our three-dimensional example where <code>A</code> is of size <code>&#40;l,m,n&#41;</code> and <code>B</code> is of size <code>&#40;l,1,n&#41;</code>, the inner loop is essentially equivalent to</p>
<pre><code class="julia hljs">B[i,<span class="hljs-number">1</span>,k] += A[i,j,k]</code></pre>
<p>because <code>min&#40;1,j&#41; &#61; 1</code>.</p>
<h3 id="the_wrapper_and_handling_type-instability_using_function_barriers"><a href="#the_wrapper_and_handling_type-instability_using_function_barriers" class="header-anchor">The wrapper, and handling type-instability using function barriers</a></h3>
<p>As a user, you might prefer an interface more like <code>sumalongdims&#40;A,
dims&#41;</code> where <code>dims</code> specifies the dimensions you want to sum along. <code>dims</code> might be a single integer, like <code>2</code> in our example above, or &#40;should you want to sum along multiple dimensions at once&#41; a tuple or <code>Vector&#123;Int&#125;</code>.  This is indeed the interface used in <code>sum&#40;A; dims&#61;dims&#41;</code>; here we want to write our own &#40;somewhat simpler&#41; implementation.</p>
<p>One possible bare-bones implementation of the wrapper looks like this:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sumalongdims(A, dims)
    sz = [size(A)...]
    sz[[dims...]] .= <span class="hljs-number">1</span>
    B = <span class="hljs-built_in">Array</span>{eltype(A)}(<span class="hljs-literal">undef</span>, sz...)
    sumalongdims!(B, A)
<span class="hljs-keyword">end</span></code></pre>
<p>Obviously, this simple implementation skips all relevant error checking.  However, here the main point I wish to explore is that the allocation of <code>B</code> turns out to be <a href="https://docs.julialang.org/en/v1/manual/faq/#man-type-stability-1">non-inferable</a>: <code>sz</code> is a <code>Vector&#123;Int&#125;</code>, the length &#40;number of elements&#41; of a specific <code>Vector&#123;Int&#125;</code> is not encoded by the type itself, and therefore the dimensionality of <code>B</code> cannot be inferred.</p>
<p>Now, we could fix that in several ways, for example by annotating the result:</p>
<pre><code class="julia hljs">B = <span class="hljs-built_in">Array</span>{eltype(A)}(<span class="hljs-literal">undef</span>, sz...)::<span class="hljs-built_in">Array</span>{eltype(A),ndims(A)}</code></pre>
<p>or by using an implementation that <em>is</em> inferable:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sumalongdims(A, dims)
    sz = ntuple(i-&gt;i ∈ dims ? <span class="hljs-number">1</span> : size(A, i), <span class="hljs-built_in">Val</span>(ndims(A)))
    B = <span class="hljs-built_in">Array</span>{eltype(A)}(<span class="hljs-literal">undef</span>, sz...)
    sumalongdims!(B, A)
<span class="hljs-keyword">end</span></code></pre>
<p>However, here we want to emphasize that this design — having a separate <code>sumalongdims&#33;</code> from <code>sumalongdims</code> — often mitigates the worst aspects of inference problems. This trick, using a <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions-1">function-call to separate a performance-critical step from a potentially type-unstable precursor</a>, is sometimes referred to as introducing a <em>function barrier</em>. It allows Julia&#39;s compiler to generate a well-optimized version of <code>sumalongdims&#33;</code> even if the intermediate type of <code>B</code> is not known.</p>
<p>As a general rule, when writing multidimensional code you should ensure that the main iteration is in a separate function from type-unstable precursors.  &#40;In older versions of Julia, you might see kernel functions annotated with <code>@noinline</code> to prevent the inliner from combining the two back together, but for more recent versions of Julia this should no longer be necessary.&#41;</p>
<p>Of course, in this example there&#39;s a second motivation for making this a standalone function: if this calculation is one you&#39;re going to repeat many times, re-using the same output array can reduce the amount of memory allocation in your code.</p>
<h2 id="filtering_along_a_specified_dimension_exploiting_multiple_indexes"><a href="#filtering_along_a_specified_dimension_exploiting_multiple_indexes" class="header-anchor">Filtering along a specified dimension &#40;exploiting multiple indexes&#41;</a></h2>
<p>One final example illustrates an important new point: when you index an array, you can freely mix <code>CartesianIndex</code>es and integers.  To illustrate this, we&#39;ll write an <a href="https://en.wikipedia.org/wiki/Exponential_smoothing">exponential smoothing filter</a>.  An efficient way to implement such filters is to have the smoothed output value <code>s&#91;i&#93;</code> depend on a combination of the current input <code>x&#91;i&#93;</code> and the previous filtered value <code>s&#91;i-1&#93;</code>; in one dimension, you can write this as</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> expfilt1!(s, x, α)
    <span class="hljs-number">0</span> &lt; α &lt;= <span class="hljs-number">1</span> || error(<span class="hljs-string">&quot;α must be between 0 and 1&quot;</span>)
    s[<span class="hljs-number">1</span>] = x[<span class="hljs-number">1</span>]
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">2</span>:length(x)
        s[i] = α*x[i] + (<span class="hljs-number">1</span>-α)*s[i-<span class="hljs-number">1</span>]
    <span class="hljs-keyword">end</span>
    s
<span class="hljs-keyword">end</span></code></pre>
<p>This would result in an approximately-exponential decay with timescale <code>1/α</code>.</p>
<p>Here, we want to implement this algorithm so that it can be used to exponentially filter an array along any chosen dimension.  Once again, the implementation is surprisingly simple:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> expfiltdim(x, dim::<span class="hljs-built_in">Integer</span>, α)
    s = similar(x)
    Rpre = <span class="hljs-built_in">CartesianIndices</span>(size(x)[<span class="hljs-number">1</span>:dim-<span class="hljs-number">1</span>])
    Rpost = <span class="hljs-built_in">CartesianIndices</span>(size(x)[dim+<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span>])
    _expfilt!(s, x, α, Rpre, size(x, dim), Rpost)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> _expfilt!(s, x, α, Rpre, n, Rpost)
    <span class="hljs-keyword">for</span> Ipost <span class="hljs-keyword">in</span> Rpost
        <span class="hljs-comment"># Initialize the first value along the filtered dimension</span>
        <span class="hljs-keyword">for</span> Ipre <span class="hljs-keyword">in</span> Rpre
            s[Ipre, <span class="hljs-number">1</span>, Ipost] = x[Ipre, <span class="hljs-number">1</span>, Ipost]
        <span class="hljs-keyword">end</span>
        <span class="hljs-comment"># Handle all other entries</span>
        <span class="hljs-keyword">for</span> i = <span class="hljs-number">2</span>:n
            <span class="hljs-keyword">for</span> Ipre <span class="hljs-keyword">in</span> Rpre
                s[Ipre, i, Ipost] = α*x[Ipre, i, Ipost] + (<span class="hljs-number">1</span>-α)*s[Ipre, i-<span class="hljs-number">1</span>, Ipost]
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    s
<span class="hljs-keyword">end</span></code></pre>
<p>Note once again the use of the function barrier technique.  In the core algorithm &#40;<code>_expfilt&#33;</code>&#41;, our strategy is to use <em>two</em> <code>CartesianIndex</code> iterators, <code>Ipre</code> and <code>Ipost</code>, where the first covers dimensions <code>1:dim-1</code> and the second <code>dim&#43;1:ndims&#40;x&#41;</code>; the filtering dimension <code>dim</code> is handled separately by an integer-index <code>i</code>. Because the filtering dimension is specified by an integer input, there is no way to infer how many entries will be within each index-tuple <code>Ipre</code> and <code>Ipost</code>.  Hence, we compute the <code>CartesianIndices</code>s in the type-unstable portion of the algorithm, and then pass them as arguments to the core routine <code>_expfilt&#33;</code>.</p>
<p>What makes this implementation possible is the fact that we can index <code>x</code> as <code>x&#91;Ipre, i, Ipost&#93;</code>.  Note that the total number of indexes supplied is <code>&#40;dim-1&#41; &#43; 1 &#43; &#40;ndims&#40;x&#41;-dim&#41;</code>, which is just <code>ndims&#40;x&#41;</code>. In general, you can supply any combination of integer and <code>CartesianIndex</code> indexes when indexing an <code>AbstractArray</code> in Julia.</p>
<p>The <a href="https://github.com/timholy/AxisAlgorithms.jl">AxisAlgorithms</a> package makes heavy use of tricks such as these, and in turn provides core support for high-performance packages like <a href="https://github.com/JuliaMath/Interpolations.jl">Interpolations</a> that require multidimensional computation.</p>
<h1 id="additional_issues"><a href="#additional_issues" class="header-anchor">Additional issues</a></h1>
<h2 id="cache-efficiency"><a href="#cache-efficiency" class="header-anchor">Cache-efficiency</a></h2>
<p>It&#39;s worth noting one point that has thus far remained unstated: all of the examples here are relatively <em>cache efficient</em>.  This is a key property to observe when writing <a href="/previews/PR2365/blog/2013/09/fast-numeric/">efficient code</a>. In particular, julia arrays are stored in first-to-last dimension order &#40;for matrices, &quot;column-major&quot; order&#41;, and hence you should nest iterations from last-to-first dimensions.  For example, in the filtering example above we were careful to iterate in the order</p>
<pre><code class="julia hljs"><span class="hljs-keyword">for</span> Ipost ...
    <span class="hljs-keyword">for</span> i ...
        <span class="hljs-keyword">for</span> Ipre ...
            x[Ipre, i, Ipost] ...</code></pre>
<p>so that <code>x</code> would be traversed in memory-order.</p>
<h2 id="broadcasting"><a href="#broadcasting" class="header-anchor">Broadcasting</a></h2>
<p><code>CartesianIndex</code>es are <em>not</em> broadcastable:</p>
<pre><code class="julia hljs">julia&gt; I = <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">7</span>)
<span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">7</span>)

julia&gt; I .+ <span class="hljs-number">1</span>
ERROR: iteration is deliberately unsupported <span class="hljs-keyword">for</span> <span class="hljs-built_in">CartesianIndex</span>. Use <span class="hljs-string">`I`</span> rather than <span class="hljs-string">`I...`</span>, or use <span class="hljs-string">`Tuple(I)...`</span>
Stacktrace:
 [<span class="hljs-number">1</span>] error(::<span class="hljs-built_in">String</span>) at ./error.jl:<span class="hljs-number">33</span>
 [<span class="hljs-number">2</span>] iterate(::<span class="hljs-built_in">CartesianIndex</span>{<span class="hljs-number">2</span>}) at ./multidimensional.jl:<span class="hljs-number">154</span>
...</code></pre>
<p>When you want to perform broadcast arithmetic, just extract the underlying tuple:</p>
<pre><code class="julia hljs">julia&gt; <span class="hljs-built_in">Tuple</span>(I) .+ <span class="hljs-number">1</span>
(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>)</code></pre>
<p>If desired you can package this back up in a <code>CartesianIndex</code>, or just use it directly &#40;with splatting&#41; for indexing. The compiler optimizes all these operations away, so there is no actual &quot;cost&quot; to constructing objects in this way.</p>
<p>Why is iteration disallowed? One reason is to support the following:</p>
<pre><code class="julia hljs">julia&gt; R = <span class="hljs-built_in">CartesianIndices</span>((<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">1</span>:<span class="hljs-number">3</span>))
<span class="hljs-number">3</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">CartesianIndices</span>{<span class="hljs-number">2</span>,<span class="hljs-built_in">Tuple</span>{<span class="hljs-built_in">UnitRange</span>{<span class="hljs-built_in">Int64</span>},<span class="hljs-built_in">UnitRange</span>{<span class="hljs-built_in">Int64</span>}}}:
 <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)
 <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
 <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)

julia&gt; R .+ <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">17</span>)
<span class="hljs-number">3</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">CartesianIndices</span>{<span class="hljs-number">2</span>,<span class="hljs-built_in">Tuple</span>{<span class="hljs-built_in">UnitRange</span>{<span class="hljs-built_in">Int64</span>},<span class="hljs-built_in">UnitRange</span>{<span class="hljs-built_in">Int64</span>}}}:
 <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">18</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">19</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">20</span>)
 <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">4</span>, <span class="hljs-number">18</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">4</span>, <span class="hljs-number">19</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">4</span>, <span class="hljs-number">20</span>)
 <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">5</span>, <span class="hljs-number">18</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">5</span>, <span class="hljs-number">19</span>)  <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">5</span>, <span class="hljs-number">20</span>)</code></pre>
<p>The underlying idea is that <code>CartesianIndex&#40;2, 17&#41;</code> needs to act, everywhere, like a pair of scalar indexes; consequently, a <code>CartesianIndex</code> has to be viewed as a single &#40;scalar&#41; entity, rather than as a container in its own right.</p>
<h1 id="summary"><a href="#summary" class="header-anchor">Summary</a></h1>
<p>As is hopefully clear by now, much of the pain of writing generic multidimensional algorithms is eliminated by Julia&#39;s elegant iterators.  The examples here just scratch the surface, but the underlying principles are very simple; it is hoped that these examples will make it easier to write your own algorithms.</p>
</div><br><br>

<!-- CONTENT ENDS HERE -->
    
    
        <script src="/previews/PR2365/libs/highlight/highlight.min.js"></script>


    

    <!-- http://tutsplus.github.io/clipboard/ -->

<script>
(function(){

	// Get the elements.
	// - the 'pre' element.
	// - the 'div' with the 'paste-content' id.

	var pre = document.getElementsByTagName('pre');

	// Add a copy button in the 'pre' element.
	// which only has the className of 'language-' or ' hljs'(if enable highlight.js pre-render).

	for (var i = 0; i < pre.length; i++) {
		var tag_name = pre[i].children[0].className
            	var isLanguage = tag_name.startsWith('language-') || tag_name.endsWith(' hljs');
		if ( isLanguage ) {
			var button           = document.createElement('button');
					button.className = 'copy-button';
					button.textContent = 'Copy';

					pre[i].appendChild(button);
		}
	};

	// Run Clipboard

	var copyCode = new Clipboard('.copy-button', {
		target: function(trigger) {
			return trigger.previousElementSibling;
    }
	});

	// On success:
	// - Change the "Copy" text to "Copied".
	// - Swap it to "Copy" in 2s.
	// - Lead user to the "contenteditable" area with Velocity scroll.

	copyCode.on('success', function(event) {
		event.clearSelection();
		event.trigger.textContent = 'Copied';
		window.setTimeout(function() {
			event.trigger.textContent = 'Copy';
		}, 2000);

	});

	// On error (Safari):
	// - Change the  "Press Ctrl+C to copy"
	// - Swap it to "Copy" in 2s.

	copyCode.on('error', function(event) {
		event.trigger.textContent = 'Press "Ctrl + C" to copy';
		window.setTimeout(function() {
			event.trigger.textContent = 'Copy';
		}, 5000);
	});

})();
</script>


    <footer class="container-fluid footer-copy">
  <div class="container">
    <div class="row footrow">
      <ul>
        <li><a href="/previews/PR2365/project">About</a></li>
        <li><a href="/previews/PR2365/about/help">Get Help</a></li>
        <li><a href="/previews/PR2365/governance/">Governance</a></li>
        <li><a href="/previews/PR2365/research/#publications">Publications</a></li>
        <li><a href="/previews/PR2365/community/sponsors/">Sponsors</a></li>
      </ul>
      <ul>
        <li><a href="/previews/PR2365/install/">Install</a></li>
        <li><a href="/previews/PR2365/downloads/">Manual Downloads</a></li>
        <li><a href="https://github.com/JuliaLang/julia">Source Code</a></li>
        <li><a href="/previews/PR2365/downloads/#current_stable_release">Current Stable Release</a></li>
        <li><a href="/previews/PR2365/downloads/#long_term_support_release">Longterm Support Release</a></li>
      </ul>
      <ul>
        <li><a href="https://docs.julialang.org/en/v1/">Documentation</a></li>
        <li><a href="https://juliaacademy.com">JuliaAcademy</a></li>
        <li><a href="https://www.youtube.com/user/JuliaLanguage">YouTube</a></li>
        <li><a href="/previews/PR2365/learning/getting-started/">Getting Started</a></li>
        <li><a href="https://docs.julialang.org/en/v1/manual/faq/">FAQ</a></li>
        <li><a href="/previews/PR2365/learning/books">Books</a></li>
      </ul>
      <ul>
        <li><a href="/previews/PR2365/community/">Community</a></li>
        <li><a href="/previews/PR2365/community/standards/">Code of Conduct</a></li>
        <li><a href="/previews/PR2365/community/stewards/">Stewards</a></li>
        <li><a href="/previews/PR2365/diversity/">Diversity</a></li>
        <li><a href="https://juliagenderinclusive.github.io">Julia Gender Inclusive</a></li>
        <li><a href="https://juliacon.org">JuliaCon</a></li>
        <li><a href="/previews/PR2365/community/#julia_user_and_developer_survey">User/Developer Survey</a></li>
        <li><a href="/previews/PR2365/shop/">Shop Merchandise</a></li>
      </ul>
      <ul>
        <li><a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">Contributing</a></li>
        <li><a href="/previews/PR2365/contribute">Contributor's Guide</a></li>
        <li><a href="https://github.com/JuliaLang/julia/issues">Issue Tracker</a></li>
        <li><a href="https://github.com/JuliaLang/julia/security/policy">Report a Security Issue</a></li>
        <li><a href="https://github.com/search?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22help+wanted%22">Help Wanted Issues</a></li>
        <li><a href="https://github.com/search?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22good+first+issue%22">Good First Issue</a></li>
        <li><a href="https://docs.julialang.org/en/v1/devdocs/init/">Dev Docs</a></li>
      </ul>
    </div>
    <div id="footer-bottom" class="row">
      <div class="col-md-10 py-2">
        <p>This site is powered by <a href="https://www.netlify.com">Netlify</a>, <a href="https://franklinjl.org">Franklin.jl</a>, and the <a href="https://julialang.org">Julia Programming Language</a>.</p>
        <p>We thank <a href="https://www.fastly.com">Fastly</a> for their generous infrastructure support.</p>
        <p>©2024 JuliaLang.org <a href="https://github.com/JuliaLang/www.julialang.org/graphs/contributors">contributors</a>. The content on this website is made available under the <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT license</a>.</p>
      </div>
      <div class="col-md-2 py-2">
        <span class="float-sm-right">
          <a class="github-button" href="https://github.com/sponsors/julialang" data-icon="octicon-heart" data-size="large" aria-label="Sponsor @julialang on GitHub">Sponsor</a>
        </span>
      </div>
    </div>
  </div>
</footer>

<script src="/previews/PR2365/libs/jquery/jquery.min.js"></script>
<script src="/previews/PR2365/libs/bootstrap/bootstrap.min.js"></script>
<!-- <script src="/previews/PR2365/libs/highlight/highlight.min.js"></script> -->
<!--  -->

    <script src="/previews/PR2365/libs/groups.js"></script>
    <script src="/previews/PR2365/libs/map.js"></script>
  </body>
</html>
